{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Acc\u00e9s a Dades - Fitxers"},{"location":"AD_T1_Sistema_de_fitxers/1_introducci/","text":"1.- Introducci\u00f3 Un fitxer o arxiu \u00e9s un conjunt de bits guardats en un dispositiu (com podria ser per exemple un disc dur). Els fitxers ens garantitzen la persist\u00e8ncia , ja que encara que apaguem l'ordinador podrem recuperar la informaci\u00f3, cosa que no passaria amb la informaci\u00f3 guardada en mem\u00f2ria RAM. El tema de la persist\u00e8ncia \u00e9s justament el que buscarem durant tot el curs. Un fitxer tindr\u00e0 un nom que l'identifica. Aquest nom pot tenir opcionalment una extensi\u00f3, generalment de 3 car\u00e0cters que tradicionalment ha servit per identificar el tipus de fitxer. El nom i l'extensi\u00f3 van separats per un punt. En els sistemes inform\u00e0tics actuals, en els quals un \u00fanic ordinador pot arribar a tenir guardats milions de fitxers, resulta imprescindible un sistema que permeta una gesti\u00f3 efica\u00e7 de localitzaci\u00f3, de manera que els usuaris puguem moure\u2019ns c\u00f2modament entre tants arxius. La major part de sistemes de fitxers han incorporat contenidors jerarquitzats que actuen a mode de directoris facilitant la classificaci\u00f3, la identificaci\u00f3 i localitzaci\u00f3 dels arxius. Els directoris s\u2019han acabat popularitzant sota la versi\u00f3 gr\u00e0fica de carpetes . Dins d'un mateix directori, el nom del fitxer (o subdirectori) ha de ser \u00fanic. Hem de tenir en compte, que a m\u00e9s dels fitxers guardats en el dispositiu de l'ordinador (el disc dur, o un altre dispositiu), la necessitat desmesurada d\u2019espai d\u2019emmagatzematge ha dut els Sistemes Operatius a treballar amb una gran quantitat de dispositius i a permetre l\u2019acc\u00e9s remot a uns altres sistemes de fitxers, distribu\u00efts per la xarxa. Per a poder gestionar tanta varietat de sistemes de fitxers, alguns sistemes operatius com Linux o Unix utilitzen l\u2019estrat\u00e8gia d\u2019unificar tots els sistemes en un \u00fanic sistema de fitxers , per tal d\u2019aconseguir una forma d\u2019acc\u00e9s unificada i amb una \u00fanica jerarquia que facilite la refer\u00e8ncia a qualsevol dels seus components, amb independ\u00e8ncia del dispositiu en el qual es troben realment ubicats. En Linux, siga quin siga el dispositiu o el sistema remot real on es guardar\u00e0 l\u2019arxiu, la ruta tindr\u00e0 sempre la mateixa forma . Observeu que per a rec\u00f3rrer la ruta jer\u00e0rquica on es troba el fitxer s'utilitza la barra de dividir : /dir_1/dir_2/dir_3/.../dir_n/fitxer.txt Per contra, l\u2019estrat\u00e8gia d\u2019altres Sistemes Operatius com Windows passa per mantenir ben diferenciats cadascun dels sistemes i dispositius on es tinga acc\u00e9s. Per distingir el sistema al qual es vol fer refer\u00e8ncia, Windows utilitza una denominaci\u00f3 espec\u00edfica del dispositiu o servidor, que incorpora a la ruta del fitxer o directori a referenciar. Encara que Microsoft ha apostat clarament per la convenci\u00f3 UNC ( Uniform Naming Convention ), l\u2019evoluci\u00f3 d\u2019aquest sistema operatiu, que t\u00e9 com a origen l\u2019MS-DOS, ha fet que coexistesca amb una altra convenci\u00f3 tamb\u00e9 molt estesa, la que utilitza una lletra de l\u2019alfabet seguida de dos punts per a identificar el dispositiu on es troba el fitxer. A continuaci\u00f3 il\u00b7lustrem amb un exemple les dues convencions. Observeu com en els dos casos s'utilitza la contra-barra : F:\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt \\\\\\Servidor_1\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1. Introducci\u00f3"},{"location":"AD_T1_Sistema_de_fitxers/1_introducci/#1-introduccio","text":"Un fitxer o arxiu \u00e9s un conjunt de bits guardats en un dispositiu (com podria ser per exemple un disc dur). Els fitxers ens garantitzen la persist\u00e8ncia , ja que encara que apaguem l'ordinador podrem recuperar la informaci\u00f3, cosa que no passaria amb la informaci\u00f3 guardada en mem\u00f2ria RAM. El tema de la persist\u00e8ncia \u00e9s justament el que buscarem durant tot el curs. Un fitxer tindr\u00e0 un nom que l'identifica. Aquest nom pot tenir opcionalment una extensi\u00f3, generalment de 3 car\u00e0cters que tradicionalment ha servit per identificar el tipus de fitxer. El nom i l'extensi\u00f3 van separats per un punt. En els sistemes inform\u00e0tics actuals, en els quals un \u00fanic ordinador pot arribar a tenir guardats milions de fitxers, resulta imprescindible un sistema que permeta una gesti\u00f3 efica\u00e7 de localitzaci\u00f3, de manera que els usuaris puguem moure\u2019ns c\u00f2modament entre tants arxius. La major part de sistemes de fitxers han incorporat contenidors jerarquitzats que actuen a mode de directoris facilitant la classificaci\u00f3, la identificaci\u00f3 i localitzaci\u00f3 dels arxius. Els directoris s\u2019han acabat popularitzant sota la versi\u00f3 gr\u00e0fica de carpetes . Dins d'un mateix directori, el nom del fitxer (o subdirectori) ha de ser \u00fanic. Hem de tenir en compte, que a m\u00e9s dels fitxers guardats en el dispositiu de l'ordinador (el disc dur, o un altre dispositiu), la necessitat desmesurada d\u2019espai d\u2019emmagatzematge ha dut els Sistemes Operatius a treballar amb una gran quantitat de dispositius i a permetre l\u2019acc\u00e9s remot a uns altres sistemes de fitxers, distribu\u00efts per la xarxa. Per a poder gestionar tanta varietat de sistemes de fitxers, alguns sistemes operatius com Linux o Unix utilitzen l\u2019estrat\u00e8gia d\u2019unificar tots els sistemes en un \u00fanic sistema de fitxers , per tal d\u2019aconseguir una forma d\u2019acc\u00e9s unificada i amb una \u00fanica jerarquia que facilite la refer\u00e8ncia a qualsevol dels seus components, amb independ\u00e8ncia del dispositiu en el qual es troben realment ubicats. En Linux, siga quin siga el dispositiu o el sistema remot real on es guardar\u00e0 l\u2019arxiu, la ruta tindr\u00e0 sempre la mateixa forma . Observeu que per a rec\u00f3rrer la ruta jer\u00e0rquica on es troba el fitxer s'utilitza la barra de dividir : /dir_1/dir_2/dir_3/.../dir_n/fitxer.txt Per contra, l\u2019estrat\u00e8gia d\u2019altres Sistemes Operatius com Windows passa per mantenir ben diferenciats cadascun dels sistemes i dispositius on es tinga acc\u00e9s. Per distingir el sistema al qual es vol fer refer\u00e8ncia, Windows utilitza una denominaci\u00f3 espec\u00edfica del dispositiu o servidor, que incorpora a la ruta del fitxer o directori a referenciar. Encara que Microsoft ha apostat clarament per la convenci\u00f3 UNC ( Uniform Naming Convention ), l\u2019evoluci\u00f3 d\u2019aquest sistema operatiu, que t\u00e9 com a origen l\u2019MS-DOS, ha fet que coexistesca amb una altra convenci\u00f3 tamb\u00e9 molt estesa, la que utilitza una lletra de l\u2019alfabet seguida de dos punts per a identificar el dispositiu on es troba el fitxer. A continuaci\u00f3 il\u00b7lustrem amb un exemple les dues convencions. Observeu com en els dos casos s'utilitza la contra-barra : F:\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt \\\\\\Servidor_1\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Introducci\u00f3"},{"location":"AD_T1_Sistema_de_fitxers/2_la_classe_file_generalitats/","text":"2.- La classe File. Generalitats. En Java, i tamb\u00e9 en Kotlin per ser una esp\u00e8cie d'extensi\u00f3 de Java, per a gestionar el sistema de fitxers s\u2019utilitza b\u00e0sicament la classe \u2018 File \u2019. \u00c9s una classe que s\u2019ha d\u2019entendre com una refer\u00e8ncia a la ruta o localitzaci\u00f3 de fitxers del sistema. NO representa el contingut de cap fitxer, sin\u00f3 la ruta del sistema on es localitza el fitxer. Com que es tracta d\u2019una ruta, la classe pot representar tant fitxers com carpetes o directoris . Si fem servir una classe per a representar rutes, s\u2019aconsegueix una total independ\u00e8ncia respecte de la notaci\u00f3 que utilitza cada sistema operatiu per descriure-les. Recordem que Java i Kotlin s\u00f3n llenguatges multiplataforma i, per tant, s'ha d'intentar fer programes que es puguen executar en qualsevol Sistema Operatiu (Windows o Linux). L\u2019estrat\u00e8gia utilitzada per cada SO no afecta la funcionalitat de la classe File , ja que aquesta, en col\u00b7laboraci\u00f3 amb la m\u00e0quina virtual, adaptar\u00e0 les sol\u00b7licituds al SO amfitri\u00f3 de forma transparent al programador , \u00e9s a dir, sense necessitat que el programador haja d\u2019indicar o configurar res. Els objectes creats de la classe File es troben estretament vinculats a la ruta amb la qual s\u2019han creat. Aix\u00f2 significa que les inst\u00e0ncies de la classe File durant tot el seu cicle de vida nom\u00e9s representaran una \u00fanica ruta, la que se\u2019ls va associar en el moment de la creaci\u00f3. La classe File no disposa de cap m\u00e8tode ni mecanisme per modificar la ruta associada. En cas de necessitar noves rutes, caldr\u00e0 sempre crear un nou objecte i no ser\u00e0 possible reutilitzar els ja creats vinculant-los a rutes diferents. Per a crear un objecte File es pot utilitzar qualsevol dels 3 constructors seg\u00fcents: File(String directori_i_fitxer ) : indiquem en un \u00fanic par\u00e0metre tant el directori com el fitxer, \u00e9s a dir, el fitxer amb la seua ruta. Recordeu que en sistemes Linux per a la ruta utilitzem la barra de dividir, mentre que en Windows la contra-barra. Com que aquest car\u00e0cter \u00e9s el d' escape , s'haur\u00e0 de posar dues vegades: val fitxer_1 = File(\"/home/usuari/AD/T1/exemple1.txt\") val fitxer_1 = File(\"C:\\\\\\AD\\\\\\T1\\\\\\exemple1.txt\") Nota Cap de les refer\u00e8ncies anteriors s\u00f3n desitjables, ja que nosaltres intentarem fer programes que funcionen en qualsevol plataforma, i la primera refer\u00e8ncia no funcionar\u00e0 en Windows, i la segona no funcionar\u00e0 en Linux. Al llarg del tema aprendrem com fer les refer\u00e8ncies de manera que funcionen en qualsevol plataforma. Per una altra banda, observeu com hem utilitzat la paraula reservada val per a crear una constant. Quasi sempre la utilitzarem per als File, ja que nom\u00e9s en algunes ocasions voldrem reutilitzar la variable assignant-li un altre valor Per a fer refer\u00e8ncia a un directori s'utilitza la mateixa t\u00e8cnica, com ja hav\u00edem vist: val dir = File(\"/home/usuari/AD/T1\") En els exemples anteriors hem posat una ruta absoluta, que comen\u00e7a des de l'arrel. Si no la posem absoluta (si no comen\u00e7a per / ) ser\u00e0 relativa i comen\u00e7ar\u00e0 en el directori actiu. Si suposem que el directori actiu \u00e9s /home/usuari , d'aquesta manera far\u00edem refer\u00e8ncia al mateix lloc: val dir = File(\"AD/T1\"); Nota Observeu que les anteriors sent\u00e8ncies no donarien cap error encara que els subdirectoris i fitxers no existisquen. No \u00e9s cap contradicci\u00f3, ja que podria ser que f\u00e9rem refer\u00e8ncia en un File a un fitxer o directori justament per a crear-lo. M\u00e9s avant veurem que tenim m\u00e8todes per a detectar l'exist\u00e8ncia real File(String directori , String fitxer ) : en el primer par\u00e0metre (String) indiquem el directori amb ruta, i en el segon el fitxer (sense ruta). Far\u00e0 refer\u00e8ncia a un fitxer amb el nom com el segon par\u00e0metre col\u00b7locat en el directori referenciat en el primer par\u00e0metre. Observeu com el segon par\u00e0metre podria ser tamb\u00e9 un directori, i per tant seria una refer\u00e8ncia a un subdirectori del directori referenciat en el primer par\u00e0metre. val fitxer_2 = File(\"/home/usuari/AD/T1\" , \"exemple2.txt\") File(File directori , String fitxer ) : Ara el directori \u00e9s un File creat anteriorment val fitxer_3 = File(dir , \"exemple3.txt\") En els exemples anteriors hem posat directament les rutes. Per\u00f2 els programadors de Java i de Kotlin han de fer un esfor\u00e7 per independitzar les aplicacions implementades de les plataformes on s\u2019executaran. Per tant, haurem d'anar amb cura, fent servir t\u00e8cniques que eviten escriure les rutes directament al codi. Per aix\u00f2 encara que ara al principi utilitzarem els 3 constructors, en el futur haur\u00edem d'utilitzar massivament el tercer, ja que com veieu la manera d'especificar la ruta de localitzaci\u00f3 del fitxer, \u00e9s per mig d'un altre File, i no ha fet falta posar cap barra de dividir ni cap contra-barra. Per tant hem fet refer\u00e8ncia a un fitxer (o subdirectori) dins d'un directori sense cap barra ni contra-barra , i per tant ens val per qualsevol Sistema Operatiu. La classe File encapsula pr\u00e0cticament tota la funcionalitat necess\u00e0ria per gestionar un sistema de fitxers organitzat en arbre de directoris. \u00c9s una gesti\u00f3 completa que inclou: Funcions de manipulaci\u00f3 i consulta de la pr\u00f2pia estructura jer\u00e0rquica (creaci\u00f3, eliminaci\u00f3, obtenci\u00f3 de la ubicaci\u00f3, etc. de fitxers o directoris) Funcions de manipulaci\u00f3 i consulta de les caracter\u00edstiques particulars dels elements (noms, mida o capacitat, etc.) Funcions de manipulaci\u00f3 i consulta d\u2019atributs espec\u00edfics de cada Sistema Operatiu, com per exemple els permisos d\u2019escriptura, d\u2019execuci\u00f3, atributs d\u2019ocultaci\u00f3. Nom\u00e9s funcionar\u00e0 si el sistema operatiu amfitri\u00f3 suporta tamb\u00e9 la funcionalitat d'aquestos atributs. En la classe original de Java no ens permet accedir al contingut dels fitxers. Aix\u00f2 es resoldr\u00e0 en el seg\u00fcent tema. Kotlin s\u00ed que ens permetr\u00e0 accedir al contingut dels fitxers a partir de la classe File, per\u00f2 per coher\u00e8ncia ho deixarem per al proper tema. Nota Tots els exemples i exercicis de cada tema els col\u00b7locarem en un \u00fanic projecte de Kotlin amb el nom del tema. en aquest cas l'anomenarem Tema1 . Els exemples els col\u00b7locarem en un paquet anomenat exemple i els exercicis en un paquet anomenat exercicis . Mirem un exemple. Anem a fer un programa per a traure la llista de fitxers i directoris del directori actual. Per a fer refer\u00e8ncia al directori actual, utilitzarem \".\", que ens serveix per a tots els Sistemes. Per defecte, el directori actiu \u00e9s el directori del projecte. Per a obtenir la llista d'elements (fitxers i directoris) utilitzarem el m\u00e8tode list() de la classe File . Veurem aquest m\u00e8tode, juntament amb els m\u00e8todes m\u00e9s importants en la seg\u00fcent pregunta. Copieu-vos el seg\u00fcent en un fitxer Kotlin anomenat Exemple_1_1.kt package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list()) println(e); } I aquest seria el resultat: que s\u00f3n els fitxers del directori arrel del projecte Tema1 (situat en la carpeta IdeaProjects ). Observeu que fins i tot mostra els fitxers ocults (que s\u00f3n els que comencen per un punt) I aprofitant la potencialitat de Kotlin, podem traure f\u00e0cilment aquesta llista ordenada alfab\u00e8ticament, senzillament posant .sorted() . D'aquesta manera, el programa anterior Exemple_1_1.kt ens quedar\u00e0 ara: package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list().sorted()) println(e); } I aquest seria el resultat: Si vulgu\u00e9rem traure el contingut d'un directori concret, el posar\u00edem en el moment de definir el File, en compte del punt per a indicar el directori actual. Una altra modificaci\u00f3 seria demanar per teclat el directori del qual volem mostrar el contingut. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_1_2.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.list().sorted()) System.out.println(e); } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2. La classe File. Generalitats."},{"location":"AD_T1_Sistema_de_fitxers/2_la_classe_file_generalitats/#2-la-classe-file-generalitats","text":"En Java, i tamb\u00e9 en Kotlin per ser una esp\u00e8cie d'extensi\u00f3 de Java, per a gestionar el sistema de fitxers s\u2019utilitza b\u00e0sicament la classe \u2018 File \u2019. \u00c9s una classe que s\u2019ha d\u2019entendre com una refer\u00e8ncia a la ruta o localitzaci\u00f3 de fitxers del sistema. NO representa el contingut de cap fitxer, sin\u00f3 la ruta del sistema on es localitza el fitxer. Com que es tracta d\u2019una ruta, la classe pot representar tant fitxers com carpetes o directoris . Si fem servir una classe per a representar rutes, s\u2019aconsegueix una total independ\u00e8ncia respecte de la notaci\u00f3 que utilitza cada sistema operatiu per descriure-les. Recordem que Java i Kotlin s\u00f3n llenguatges multiplataforma i, per tant, s'ha d'intentar fer programes que es puguen executar en qualsevol Sistema Operatiu (Windows o Linux). L\u2019estrat\u00e8gia utilitzada per cada SO no afecta la funcionalitat de la classe File , ja que aquesta, en col\u00b7laboraci\u00f3 amb la m\u00e0quina virtual, adaptar\u00e0 les sol\u00b7licituds al SO amfitri\u00f3 de forma transparent al programador , \u00e9s a dir, sense necessitat que el programador haja d\u2019indicar o configurar res. Els objectes creats de la classe File es troben estretament vinculats a la ruta amb la qual s\u2019han creat. Aix\u00f2 significa que les inst\u00e0ncies de la classe File durant tot el seu cicle de vida nom\u00e9s representaran una \u00fanica ruta, la que se\u2019ls va associar en el moment de la creaci\u00f3. La classe File no disposa de cap m\u00e8tode ni mecanisme per modificar la ruta associada. En cas de necessitar noves rutes, caldr\u00e0 sempre crear un nou objecte i no ser\u00e0 possible reutilitzar els ja creats vinculant-los a rutes diferents. Per a crear un objecte File es pot utilitzar qualsevol dels 3 constructors seg\u00fcents: File(String directori_i_fitxer ) : indiquem en un \u00fanic par\u00e0metre tant el directori com el fitxer, \u00e9s a dir, el fitxer amb la seua ruta. Recordeu que en sistemes Linux per a la ruta utilitzem la barra de dividir, mentre que en Windows la contra-barra. Com que aquest car\u00e0cter \u00e9s el d' escape , s'haur\u00e0 de posar dues vegades: val fitxer_1 = File(\"/home/usuari/AD/T1/exemple1.txt\") val fitxer_1 = File(\"C:\\\\\\AD\\\\\\T1\\\\\\exemple1.txt\") Nota Cap de les refer\u00e8ncies anteriors s\u00f3n desitjables, ja que nosaltres intentarem fer programes que funcionen en qualsevol plataforma, i la primera refer\u00e8ncia no funcionar\u00e0 en Windows, i la segona no funcionar\u00e0 en Linux. Al llarg del tema aprendrem com fer les refer\u00e8ncies de manera que funcionen en qualsevol plataforma. Per una altra banda, observeu com hem utilitzat la paraula reservada val per a crear una constant. Quasi sempre la utilitzarem per als File, ja que nom\u00e9s en algunes ocasions voldrem reutilitzar la variable assignant-li un altre valor Per a fer refer\u00e8ncia a un directori s'utilitza la mateixa t\u00e8cnica, com ja hav\u00edem vist: val dir = File(\"/home/usuari/AD/T1\") En els exemples anteriors hem posat una ruta absoluta, que comen\u00e7a des de l'arrel. Si no la posem absoluta (si no comen\u00e7a per / ) ser\u00e0 relativa i comen\u00e7ar\u00e0 en el directori actiu. Si suposem que el directori actiu \u00e9s /home/usuari , d'aquesta manera far\u00edem refer\u00e8ncia al mateix lloc: val dir = File(\"AD/T1\"); Nota Observeu que les anteriors sent\u00e8ncies no donarien cap error encara que els subdirectoris i fitxers no existisquen. No \u00e9s cap contradicci\u00f3, ja que podria ser que f\u00e9rem refer\u00e8ncia en un File a un fitxer o directori justament per a crear-lo. M\u00e9s avant veurem que tenim m\u00e8todes per a detectar l'exist\u00e8ncia real File(String directori , String fitxer ) : en el primer par\u00e0metre (String) indiquem el directori amb ruta, i en el segon el fitxer (sense ruta). Far\u00e0 refer\u00e8ncia a un fitxer amb el nom com el segon par\u00e0metre col\u00b7locat en el directori referenciat en el primer par\u00e0metre. Observeu com el segon par\u00e0metre podria ser tamb\u00e9 un directori, i per tant seria una refer\u00e8ncia a un subdirectori del directori referenciat en el primer par\u00e0metre. val fitxer_2 = File(\"/home/usuari/AD/T1\" , \"exemple2.txt\") File(File directori , String fitxer ) : Ara el directori \u00e9s un File creat anteriorment val fitxer_3 = File(dir , \"exemple3.txt\") En els exemples anteriors hem posat directament les rutes. Per\u00f2 els programadors de Java i de Kotlin han de fer un esfor\u00e7 per independitzar les aplicacions implementades de les plataformes on s\u2019executaran. Per tant, haurem d'anar amb cura, fent servir t\u00e8cniques que eviten escriure les rutes directament al codi. Per aix\u00f2 encara que ara al principi utilitzarem els 3 constructors, en el futur haur\u00edem d'utilitzar massivament el tercer, ja que com veieu la manera d'especificar la ruta de localitzaci\u00f3 del fitxer, \u00e9s per mig d'un altre File, i no ha fet falta posar cap barra de dividir ni cap contra-barra. Per tant hem fet refer\u00e8ncia a un fitxer (o subdirectori) dins d'un directori sense cap barra ni contra-barra , i per tant ens val per qualsevol Sistema Operatiu. La classe File encapsula pr\u00e0cticament tota la funcionalitat necess\u00e0ria per gestionar un sistema de fitxers organitzat en arbre de directoris. \u00c9s una gesti\u00f3 completa que inclou: Funcions de manipulaci\u00f3 i consulta de la pr\u00f2pia estructura jer\u00e0rquica (creaci\u00f3, eliminaci\u00f3, obtenci\u00f3 de la ubicaci\u00f3, etc. de fitxers o directoris) Funcions de manipulaci\u00f3 i consulta de les caracter\u00edstiques particulars dels elements (noms, mida o capacitat, etc.) Funcions de manipulaci\u00f3 i consulta d\u2019atributs espec\u00edfics de cada Sistema Operatiu, com per exemple els permisos d\u2019escriptura, d\u2019execuci\u00f3, atributs d\u2019ocultaci\u00f3. Nom\u00e9s funcionar\u00e0 si el sistema operatiu amfitri\u00f3 suporta tamb\u00e9 la funcionalitat d'aquestos atributs. En la classe original de Java no ens permet accedir al contingut dels fitxers. Aix\u00f2 es resoldr\u00e0 en el seg\u00fcent tema. Kotlin s\u00ed que ens permetr\u00e0 accedir al contingut dels fitxers a partir de la classe File, per\u00f2 per coher\u00e8ncia ho deixarem per al proper tema. Nota Tots els exemples i exercicis de cada tema els col\u00b7locarem en un \u00fanic projecte de Kotlin amb el nom del tema. en aquest cas l'anomenarem Tema1 . Els exemples els col\u00b7locarem en un paquet anomenat exemple i els exercicis en un paquet anomenat exercicis . Mirem un exemple. Anem a fer un programa per a traure la llista de fitxers i directoris del directori actual. Per a fer refer\u00e8ncia al directori actual, utilitzarem \".\", que ens serveix per a tots els Sistemes. Per defecte, el directori actiu \u00e9s el directori del projecte. Per a obtenir la llista d'elements (fitxers i directoris) utilitzarem el m\u00e8tode list() de la classe File . Veurem aquest m\u00e8tode, juntament amb els m\u00e8todes m\u00e9s importants en la seg\u00fcent pregunta. Copieu-vos el seg\u00fcent en un fitxer Kotlin anomenat Exemple_1_1.kt package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list()) println(e); } I aquest seria el resultat: que s\u00f3n els fitxers del directori arrel del projecte Tema1 (situat en la carpeta IdeaProjects ). Observeu que fins i tot mostra els fitxers ocults (que s\u00f3n els que comencen per un punt) I aprofitant la potencialitat de Kotlin, podem traure f\u00e0cilment aquesta llista ordenada alfab\u00e8ticament, senzillament posant .sorted() . D'aquesta manera, el programa anterior Exemple_1_1.kt ens quedar\u00e0 ara: package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list().sorted()) println(e); } I aquest seria el resultat: Si vulgu\u00e9rem traure el contingut d'un directori concret, el posar\u00edem en el moment de definir el File, en compte del punt per a indicar el directori actual. Una altra modificaci\u00f3 seria demanar per teclat el directori del qual volem mostrar el contingut. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_1_2.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.list().sorted()) System.out.println(e); } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- La classe File. Generalitats."},{"location":"AD_T1_Sistema_de_fitxers/3_funcionalitat_de_la_classe_file/","text":"3.- Funcionalitat de la classe File La classe File cont\u00e9 una s\u00e8rie de m\u00e8todes que ens permeten traure informaci\u00f3 relativa al fitxer o directori al que apunta, aix\u00ed com poder navegar (obtenint el pare o accedint a algun dels directoris fills). Tamb\u00e9 ens permetran manipular ambdues coses, modificant la informaci\u00f3 i l'estructura de directoris (crear directoris nous, esborrar, canviar el nom, ...). Veurem alguns d'ells, agrupats per categories. Per cert, com que ens interessa fer les aplicacions sense haver de dependre de la plataforma, ens ser\u00e0 molt \u00fatil poder situar-nos en l'arrel del dispositiu sense haver de posar-lo a m\u00e0. Aix\u00f2 s'aconsegueix amb el m\u00e8tode static de File anomenat listRoots() . En sistemes Linux tornar\u00e0 un \u00fanic element, per\u00f2 en sistemes Windows tornar\u00e0 l'arrel de cada unitat del sistema, per aix\u00f2 \u00e9s un array. Aquesta \u00e9s una manera d'obtenir un File que apunta a l'arrel (i en el cas de Windows a l'arrel de C:): val f = File.listRoots()[0] Si en Windows vulgu\u00e9rem anar a l'arrel de D: , haur\u00edem de posar File.listRoots() [1] , i aix\u00ed successivament. Una altra cosa que pot dur a engany \u00e9s que perfectament pot no existir el fitxer o directori especificat en la creaci\u00f3 del File. Recordeu que no estem accedint encara al contingut dels fitxers. I perfectament podem crear un File d'un fitxer o directori que no existeix, justament per a crear-lo. M\u00e8todes per a obtenir el nom o la ruta getName() Torna el nom del fitxer o directori getPath() Torna la ruta (relativa) getAbsolutePath() Torna la ruta absoluta getCanonicalPath() Torna la ruta absoluta sense possibles redund\u00e0ncies getPath() d\u00f3na la ruta fins arribar al fitxer, per\u00f2 relativa, tal i com s'especifica en el moment de crear el File. getAbsolutePath() d\u00f3na la ruta absoluta, des de l'arrel. En determinades ocasions poden haver redund\u00e0ncies en la ruta getCanonicalPath() d\u00f3na la ruta absoluta, des de l'arrel, i sense redund\u00e0ncies. T\u00e9 com a inconvenient una utilitzaci\u00f3 m\u00e9s complicada que getAbsolutePath. En el seg\u00fcent exemple s'intenta mostrar aix\u00f2 de les redund\u00e0ncies, que getCanonicalPath() resol completament. Observeu com per a il\u00b7lustrar l'exemple fem refer\u00e8ncia a un fitxer d'una forma complicada. Suposem que el directori actiu \u00e9s /home/usuari/workspace/Tema1 , i volem fer refer\u00e8ncia a un fitxer situat en un subdirectori anomenat fitxers . Si copiem el seg\u00fcent codi en el fitxer Exemple_1_3.kt : package exemples import java.io.File fun main(args: Array<String>) { val f = File(\"fitxers/../fitxers/f1.txt\") println(\"Nom del fitxer: \" + f.getName()) println(\"Ruta del fitxer: \" + f.getPath()) println(\"Ruta absoluta del fitxer: \" + f.getAbsolutePath()) println(\"Ruta can\u00f2nica del fitxer: \" + f.getCanonicalPath()) } Si suposem que el directori actiu \u00e9s /home/usuari/IdeaProjects/Tema1 (recordeu que per defecte el directori actiu \u00e9s el directori on est\u00e0 el projecte), el resultat ser\u00e0: Nom del fitxer: f1.txt Ruta del fitxer: fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/f1.txt Recordeu que no cal que existesca el fitxer f1.txt , o el subdirectori fitxers . M\u00e8todes per a obtenir els fills o el pare list() Torna un array de Strings amb els noms de tots els elements continguts en el File listFiles() Torna un array de Files amb tots els elements continguts en el File getParent() Torna el nom (string) del pare (si no existeix per ser l'arrel, tornar\u00e0 nul) getParentFile() Torna el pare com un File (si no existeix per ser l'arrel, tornar\u00e0 nul) Ja hem vist la utilitat de list() , que torna un array de strings. En ocasions ens ser\u00e0 de molt\u00edssima utilitat listFiles() , ja que torna un array de Files. Si a a\u00e7\u00f2 adjuntem els m\u00e8todes getParent() i getParentFile() , veiem que podrem navegar pel sistema de fitxers. M\u00e8todes per veure l'exist\u00e8ncia i caracter\u00edstiques exists() Torna true si el fitxer o directori existeix isDirectory() Torna true si \u00e9s un directori isFile() Torna true si \u00e9s un fitxer length() Torna la grand\u00e0ria del fitxer en bytes lastModified() Torna la data de modificaci\u00f3 del fitxer o directori setLastModified() Actualitza la data de modificaci\u00f3 del fitxer o directori Com ja hav\u00edem comentat abans, en el moment de crear el File, pot ser existesca o no el fitxer o directori, \u00e9s a dir, que potser es corresponga o no amb un fitxer real. Si volem comprovar l'exist\u00e8ncia podem utilitzar el m\u00e8tode exists() . Anem a modificar l'exemple 2, on torn\u00e0vem tots els fitxers i directoris d'un directori introdu\u00eft per teclat. Primer ens assegurem que existeix i \u00e9s un directori. Despr\u00e9s el millorarem tornant la grand\u00e0ria de cada fitxer si \u00e9s un fitxer, i especificant que \u00e9s un directori, si ho \u00e9s. Ens convindr\u00e0 listFiles() per a poder mirar si \u00e9s un fitxer o directori, la grand\u00e0ria, ... Tamb\u00e9 hem aprofitat per crear el m\u00e8tode est\u00e0tic llistat(File) , que mostrar\u00e0 el contingut del directori on apunta el File, i aix\u00ed estructurar-lo un poc millor. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_1_4.kt package exemples import java.io.BufferedReader import java.io.File import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) if (f.exists()) { if (f.isDirectory()) { llistaDirectori(f) } else println(\"No \u00e9s un directori\") } else println(\"No existeix el directori\") } fun llistaDirectori(f: File) { val s = \"Llista de fitxers i directoris del directori \" + f.getCanonicalPath() println(s) println(\"-\".repeat(s.length)) for (e in f.listFiles().sorted()) { if (e.isFile()) println(e.getName() + \"\\t \" + e.length()) if (e.isDirectory()) println(e.getName() + \"\\t <Directori>\") } } I aquest seria el resultat si introdu\u00efm el directori actual ( . ) M\u00e8todes per als permisos Els seg\u00fcents m\u00e8todes ens permeten consultar i modificar els permisos del File, al m\u00e9s pur estil Linux canRead() Torna true si es t\u00e9 perm\u00eds de lectura sobre el fitxer o directori canWrite() Torna true si es t\u00e9 perm\u00eds d'escriptura sobre el fitxer o directori canExecute() Torna true si \u00e9s executable setReadable(Boolean,Boolean) D\u00f3na perm\u00eds o no de lectura sobre el fitxer, segons el primer par\u00e0metre. En el segon indiquem si afecta nom\u00e9s al propietari (true) o a tot el m\u00f3n (false) setWritable(Boolean,Boolean) D\u00f3na perm\u00eds d'escriptura o no, segons el valor del primer par\u00e0metre. El segon actua igual que abans setExecutable(Boolean,Boolean) D\u00f3na perm\u00eds d'execuci\u00f3, segons el valor del primer par\u00e0metre. El segon actua igual que abans M\u00e8todes de creaci\u00f3 i esborrat Ens permetran crear diectoris, fitxers buits i esborrar-los createNewFile() Crea un fitxer nou buit associat al File, sempre que no existesca ja un amb el mateix nom delete() Esborra el fitxer o directori mkdir() Crea un directori amb el nom indicat en la creaci\u00f3 del File. Ha d'existir el directori pare mkdirs() Com l'anterior, per\u00f2 si cal crea tots els directoris de la ruta necessaris renameTo(String nou_nom) Canvia el nom del fitxer o directori M\u00e8todes sobre l'espai del dispositiu Tamb\u00e9 disposem de m\u00e8todes que ens diuen l'espai total i lliure del dispositiu on est\u00e0 situat el File getFreeSpace() Torna l'espai lliure del dispositiu on est\u00e0 situat el File getUsableSpace() Torna l'espai utilitzable per l'aplicaci\u00f3 (menor que l'espai lliure) getTotalSpace() Torna l'espai total del dispositiu on est\u00e0 situat el File M\u00e8todes espec\u00edfics de Kotlin Kotlin afegeix funcionalitat a la classe File. Aix\u00ed el seg\u00fcents m\u00e8todes s\u00f3n espec\u00edfics de Kotlin, i no els trobar\u00edem en Java walk() Torna una seq\u00fc\u00e8ncia per a visitar tots els fitxers i subdirectoris, i els seus continguts. Es pot indicar la manera d'accedir als subdirectoris amb par\u00e0mentres. La manera d'actuar per defecte \u00e9s primer mostrar el propi directori, i despr\u00e9s els descendents walkTopDown() El mateix que l'anterior en l'opci\u00f3 per defecte walkBottomUp() Igual que l'anterior, per\u00f2 mostrant abans els descendents i despr\u00e9s el propi directori Per tant s\u00f3n una forma c\u00f2moda per a accedir a tota l'estructura de directoris i fitxers que pengen de l'actual directori. Modificarem l'exemple 2, per a mostrar ara tots els descendents del directori intru\u00eft per teclat. Copieu el seg\u00fcent codi en en un fitxer anomenat Exemple_1_5.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.walk().sorted()) System.out.println(e); } I el resultat seria, si introdu\u00efm el directori actual ( . ): Es pot observar que primer mostra un determinat directori i despr\u00e9s tot el seu contingut. Per exemple ./src est\u00e0 abans que tots els seus descendents. Amb walkBottomUp() seria a l'inrev\u00e8s, per exemple primer tots els descendents de ./src , i despr\u00e9s el propi ./src Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3. Funcionalitat de la classe File"},{"location":"AD_T1_Sistema_de_fitxers/3_funcionalitat_de_la_classe_file/#3-funcionalitat-de-la-classe-file","text":"La classe File cont\u00e9 una s\u00e8rie de m\u00e8todes que ens permeten traure informaci\u00f3 relativa al fitxer o directori al que apunta, aix\u00ed com poder navegar (obtenint el pare o accedint a algun dels directoris fills). Tamb\u00e9 ens permetran manipular ambdues coses, modificant la informaci\u00f3 i l'estructura de directoris (crear directoris nous, esborrar, canviar el nom, ...). Veurem alguns d'ells, agrupats per categories. Per cert, com que ens interessa fer les aplicacions sense haver de dependre de la plataforma, ens ser\u00e0 molt \u00fatil poder situar-nos en l'arrel del dispositiu sense haver de posar-lo a m\u00e0. Aix\u00f2 s'aconsegueix amb el m\u00e8tode static de File anomenat listRoots() . En sistemes Linux tornar\u00e0 un \u00fanic element, per\u00f2 en sistemes Windows tornar\u00e0 l'arrel de cada unitat del sistema, per aix\u00f2 \u00e9s un array. Aquesta \u00e9s una manera d'obtenir un File que apunta a l'arrel (i en el cas de Windows a l'arrel de C:): val f = File.listRoots()[0] Si en Windows vulgu\u00e9rem anar a l'arrel de D: , haur\u00edem de posar File.listRoots() [1] , i aix\u00ed successivament. Una altra cosa que pot dur a engany \u00e9s que perfectament pot no existir el fitxer o directori especificat en la creaci\u00f3 del File. Recordeu que no estem accedint encara al contingut dels fitxers. I perfectament podem crear un File d'un fitxer o directori que no existeix, justament per a crear-lo. M\u00e8todes per a obtenir el nom o la ruta getName() Torna el nom del fitxer o directori getPath() Torna la ruta (relativa) getAbsolutePath() Torna la ruta absoluta getCanonicalPath() Torna la ruta absoluta sense possibles redund\u00e0ncies getPath() d\u00f3na la ruta fins arribar al fitxer, per\u00f2 relativa, tal i com s'especifica en el moment de crear el File. getAbsolutePath() d\u00f3na la ruta absoluta, des de l'arrel. En determinades ocasions poden haver redund\u00e0ncies en la ruta getCanonicalPath() d\u00f3na la ruta absoluta, des de l'arrel, i sense redund\u00e0ncies. T\u00e9 com a inconvenient una utilitzaci\u00f3 m\u00e9s complicada que getAbsolutePath. En el seg\u00fcent exemple s'intenta mostrar aix\u00f2 de les redund\u00e0ncies, que getCanonicalPath() resol completament. Observeu com per a il\u00b7lustrar l'exemple fem refer\u00e8ncia a un fitxer d'una forma complicada. Suposem que el directori actiu \u00e9s /home/usuari/workspace/Tema1 , i volem fer refer\u00e8ncia a un fitxer situat en un subdirectori anomenat fitxers . Si copiem el seg\u00fcent codi en el fitxer Exemple_1_3.kt : package exemples import java.io.File fun main(args: Array<String>) { val f = File(\"fitxers/../fitxers/f1.txt\") println(\"Nom del fitxer: \" + f.getName()) println(\"Ruta del fitxer: \" + f.getPath()) println(\"Ruta absoluta del fitxer: \" + f.getAbsolutePath()) println(\"Ruta can\u00f2nica del fitxer: \" + f.getCanonicalPath()) } Si suposem que el directori actiu \u00e9s /home/usuari/IdeaProjects/Tema1 (recordeu que per defecte el directori actiu \u00e9s el directori on est\u00e0 el projecte), el resultat ser\u00e0: Nom del fitxer: f1.txt Ruta del fitxer: fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/f1.txt Recordeu que no cal que existesca el fitxer f1.txt , o el subdirectori fitxers . M\u00e8todes per a obtenir els fills o el pare list() Torna un array de Strings amb els noms de tots els elements continguts en el File listFiles() Torna un array de Files amb tots els elements continguts en el File getParent() Torna el nom (string) del pare (si no existeix per ser l'arrel, tornar\u00e0 nul) getParentFile() Torna el pare com un File (si no existeix per ser l'arrel, tornar\u00e0 nul) Ja hem vist la utilitat de list() , que torna un array de strings. En ocasions ens ser\u00e0 de molt\u00edssima utilitat listFiles() , ja que torna un array de Files. Si a a\u00e7\u00f2 adjuntem els m\u00e8todes getParent() i getParentFile() , veiem que podrem navegar pel sistema de fitxers. M\u00e8todes per veure l'exist\u00e8ncia i caracter\u00edstiques exists() Torna true si el fitxer o directori existeix isDirectory() Torna true si \u00e9s un directori isFile() Torna true si \u00e9s un fitxer length() Torna la grand\u00e0ria del fitxer en bytes lastModified() Torna la data de modificaci\u00f3 del fitxer o directori setLastModified() Actualitza la data de modificaci\u00f3 del fitxer o directori Com ja hav\u00edem comentat abans, en el moment de crear el File, pot ser existesca o no el fitxer o directori, \u00e9s a dir, que potser es corresponga o no amb un fitxer real. Si volem comprovar l'exist\u00e8ncia podem utilitzar el m\u00e8tode exists() . Anem a modificar l'exemple 2, on torn\u00e0vem tots els fitxers i directoris d'un directori introdu\u00eft per teclat. Primer ens assegurem que existeix i \u00e9s un directori. Despr\u00e9s el millorarem tornant la grand\u00e0ria de cada fitxer si \u00e9s un fitxer, i especificant que \u00e9s un directori, si ho \u00e9s. Ens convindr\u00e0 listFiles() per a poder mirar si \u00e9s un fitxer o directori, la grand\u00e0ria, ... Tamb\u00e9 hem aprofitat per crear el m\u00e8tode est\u00e0tic llistat(File) , que mostrar\u00e0 el contingut del directori on apunta el File, i aix\u00ed estructurar-lo un poc millor. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_1_4.kt package exemples import java.io.BufferedReader import java.io.File import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) if (f.exists()) { if (f.isDirectory()) { llistaDirectori(f) } else println(\"No \u00e9s un directori\") } else println(\"No existeix el directori\") } fun llistaDirectori(f: File) { val s = \"Llista de fitxers i directoris del directori \" + f.getCanonicalPath() println(s) println(\"-\".repeat(s.length)) for (e in f.listFiles().sorted()) { if (e.isFile()) println(e.getName() + \"\\t \" + e.length()) if (e.isDirectory()) println(e.getName() + \"\\t <Directori>\") } } I aquest seria el resultat si introdu\u00efm el directori actual ( . ) M\u00e8todes per als permisos Els seg\u00fcents m\u00e8todes ens permeten consultar i modificar els permisos del File, al m\u00e9s pur estil Linux canRead() Torna true si es t\u00e9 perm\u00eds de lectura sobre el fitxer o directori canWrite() Torna true si es t\u00e9 perm\u00eds d'escriptura sobre el fitxer o directori canExecute() Torna true si \u00e9s executable setReadable(Boolean,Boolean) D\u00f3na perm\u00eds o no de lectura sobre el fitxer, segons el primer par\u00e0metre. En el segon indiquem si afecta nom\u00e9s al propietari (true) o a tot el m\u00f3n (false) setWritable(Boolean,Boolean) D\u00f3na perm\u00eds d'escriptura o no, segons el valor del primer par\u00e0metre. El segon actua igual que abans setExecutable(Boolean,Boolean) D\u00f3na perm\u00eds d'execuci\u00f3, segons el valor del primer par\u00e0metre. El segon actua igual que abans M\u00e8todes de creaci\u00f3 i esborrat Ens permetran crear diectoris, fitxers buits i esborrar-los createNewFile() Crea un fitxer nou buit associat al File, sempre que no existesca ja un amb el mateix nom delete() Esborra el fitxer o directori mkdir() Crea un directori amb el nom indicat en la creaci\u00f3 del File. Ha d'existir el directori pare mkdirs() Com l'anterior, per\u00f2 si cal crea tots els directoris de la ruta necessaris renameTo(String nou_nom) Canvia el nom del fitxer o directori M\u00e8todes sobre l'espai del dispositiu Tamb\u00e9 disposem de m\u00e8todes que ens diuen l'espai total i lliure del dispositiu on est\u00e0 situat el File getFreeSpace() Torna l'espai lliure del dispositiu on est\u00e0 situat el File getUsableSpace() Torna l'espai utilitzable per l'aplicaci\u00f3 (menor que l'espai lliure) getTotalSpace() Torna l'espai total del dispositiu on est\u00e0 situat el File M\u00e8todes espec\u00edfics de Kotlin Kotlin afegeix funcionalitat a la classe File. Aix\u00ed el seg\u00fcents m\u00e8todes s\u00f3n espec\u00edfics de Kotlin, i no els trobar\u00edem en Java walk() Torna una seq\u00fc\u00e8ncia per a visitar tots els fitxers i subdirectoris, i els seus continguts. Es pot indicar la manera d'accedir als subdirectoris amb par\u00e0mentres. La manera d'actuar per defecte \u00e9s primer mostrar el propi directori, i despr\u00e9s els descendents walkTopDown() El mateix que l'anterior en l'opci\u00f3 per defecte walkBottomUp() Igual que l'anterior, per\u00f2 mostrant abans els descendents i despr\u00e9s el propi directori Per tant s\u00f3n una forma c\u00f2moda per a accedir a tota l'estructura de directoris i fitxers que pengen de l'actual directori. Modificarem l'exemple 2, per a mostrar ara tots els descendents del directori intru\u00eft per teclat. Copieu el seg\u00fcent codi en en un fitxer anomenat Exemple_1_5.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.walk().sorted()) System.out.println(e); } I el resultat seria, si introdu\u00efm el directori actual ( . ): Es pot observar que primer mostra un determinat directori i despr\u00e9s tot el seu contingut. Per exemple ./src est\u00e0 abans que tots els seus descendents. Amb walkBottomUp() seria a l'inrev\u00e8s, per exemple primer tots els descendents de ./src , i despr\u00e9s el propi ./src Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Funcionalitat de la classe File"},{"location":"AD_T1_Sistema_de_fitxers/Idea/","text":"Instal.laci\u00f3 de IntelliJ Idea Ultimate Tots els nostres programes seran en KOTLIN , que \u00e9s un llenguatge que est\u00e0 per damunt de Java, de manera que tots els programes, classes... realitzats en Java els podrem utilitzar sense problemes, i a m\u00e9s ens permetr\u00e0 una programaci\u00f3 molt m\u00e9s c\u00f2moda. A m\u00e9s, \u00e9s el llenguatge que utilitzareu tant en el m\u00f2dul de PMDM com en el de DI Com a pas previ i inicial instal\u00b7larem l'entorn de treball des d'on programarem, un IDE. Enguany instal\u00b7larem IntelliJ IDEA , la versi\u00f3 Ultimate , que \u00e9s la que ens proporcionar\u00e0 totes les eines per a poder treballar sense problemes. Un altre entorn molt habitual \u00e9s Eclipse , que \u00e9s el que hem utilitzat en anys anteriors, per\u00f2 que amb el plugin de Kotlin va molt lent. En IntelliJ vaja molt m\u00e9s fi. En el moment de fer aquestos apunts l'\u00faltima versi\u00f3 \u00e9s la 2022.2.1. El seg\u00fcent v\u00eddeo mostra tot el proc\u00e9s d'instal\u00b7laci\u00f3 i creaci\u00f3 del primer projecte. Correspon a una versi\u00f3 anterior, per\u00f2 totalment similar a l'actual Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Idea"},{"location":"AD_T1_Sistema_de_fitxers/Idea/#installacio-de-intellij-idea-ultimate","text":"Tots els nostres programes seran en KOTLIN , que \u00e9s un llenguatge que est\u00e0 per damunt de Java, de manera que tots els programes, classes... realitzats en Java els podrem utilitzar sense problemes, i a m\u00e9s ens permetr\u00e0 una programaci\u00f3 molt m\u00e9s c\u00f2moda. A m\u00e9s, \u00e9s el llenguatge que utilitzareu tant en el m\u00f2dul de PMDM com en el de DI Com a pas previ i inicial instal\u00b7larem l'entorn de treball des d'on programarem, un IDE. Enguany instal\u00b7larem IntelliJ IDEA , la versi\u00f3 Ultimate , que \u00e9s la que ens proporcionar\u00e0 totes les eines per a poder treballar sense problemes. Un altre entorn molt habitual \u00e9s Eclipse , que \u00e9s el que hem utilitzat en anys anteriors, per\u00f2 que amb el plugin de Kotlin va molt lent. En IntelliJ vaja molt m\u00e9s fi. En el moment de fer aquestos apunts l'\u00faltima versi\u00f3 \u00e9s la 2022.2.1. El seg\u00fcent v\u00eddeo mostra tot el proc\u00e9s d'instal\u00b7laci\u00f3 i creaci\u00f3 del primer projecte. Correspon a una versi\u00f3 anterior, per\u00f2 totalment similar a l'actual Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Instal.laci\u00f3 de IntelliJ Idea Ultimate"},{"location":"AD_T1_Sistema_de_fitxers/exercicis/","text":"Exercicis Exercici T1_1 Realitza un programa en un fitxer anomenat Exercici_1.kt en el paquet exercicis , que permeta navegar pels directoris de la unitat principal del sistema d'arxius. Ha de comen\u00e7ar per l'arrel (/ en Linux; c:\\ en Windows). Recordeu que el m\u00e8tode est\u00e0tic File.listRoots()[0] ens d\u00f3na l'arrel. Ha d'indicar el directori que est\u00e0 mostrant. Ha de posar com a primera opci\u00f3 anar al directori pare (opci\u00f3 0). Ha de posar un n\u00famero davant de cada arxiu o subdirectori que s'est\u00e0 mostrant. Observeu que aquest n\u00famero comen\u00e7a amb 1 (el 0 \u00e9s per al pare). Si us heu guardat en un array la llista de fitxers i directoris del directori actual, recordeu que el primer element \u00e9s el 0 (per\u00f2 vosaltres el mostrareu amb un 1 davant). En cas de ser un arxiu ha de dir la grand\u00e0ria. En cas de ser un subdirectori, ha d'indicar-lo amb < directori> Posteriorment ha de deixar introduir un n\u00famero. Les opcions seran: -1 per acabar 0 anar al directori pare. Si s'ha triat el 0 (per anar al pare) s'ha de controlar que existeix el pare (en el cas de l'arrel, no en t\u00e9). Si no en t\u00e9, no s'ha de fer res. Qualsevol altre n\u00famero ha de servir per canviar a aquest directori com a directori actiu. Si era un fitxer, no ha de fer res (en la imatge, no s'ha de poder anar al 9, ja que \u00e9s un fitxer). S'ha de controlar que hi ha perm\u00eds de lectura sobre un directori, abans de canviar a ell, sin\u00f3 donar\u00e0 error (en la imatge, per exemple, segurament no es podr\u00e0 canviar al directori root , ja que no tindrem perm\u00eds de lectura sobre ell). Aquesta comprovaci\u00f3 s'ha de fer abans de canviar al directori triat. I s'ha de controlar que el n\u00famero introdu\u00eft est\u00e0 en el rang correcte (en la imatge, de -1 fins a 28) La seg\u00fcent imatge mostra el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"AD_T1_Sistema_de_fitxers/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_T1_Sistema_de_fitxers/exercicis/#exercici-t1_1","text":"Realitza un programa en un fitxer anomenat Exercici_1.kt en el paquet exercicis , que permeta navegar pels directoris de la unitat principal del sistema d'arxius. Ha de comen\u00e7ar per l'arrel (/ en Linux; c:\\ en Windows). Recordeu que el m\u00e8tode est\u00e0tic File.listRoots()[0] ens d\u00f3na l'arrel. Ha d'indicar el directori que est\u00e0 mostrant. Ha de posar com a primera opci\u00f3 anar al directori pare (opci\u00f3 0). Ha de posar un n\u00famero davant de cada arxiu o subdirectori que s'est\u00e0 mostrant. Observeu que aquest n\u00famero comen\u00e7a amb 1 (el 0 \u00e9s per al pare). Si us heu guardat en un array la llista de fitxers i directoris del directori actual, recordeu que el primer element \u00e9s el 0 (per\u00f2 vosaltres el mostrareu amb un 1 davant). En cas de ser un arxiu ha de dir la grand\u00e0ria. En cas de ser un subdirectori, ha d'indicar-lo amb < directori> Posteriorment ha de deixar introduir un n\u00famero. Les opcions seran: -1 per acabar 0 anar al directori pare. Si s'ha triat el 0 (per anar al pare) s'ha de controlar que existeix el pare (en el cas de l'arrel, no en t\u00e9). Si no en t\u00e9, no s'ha de fer res. Qualsevol altre n\u00famero ha de servir per canviar a aquest directori com a directori actiu. Si era un fitxer, no ha de fer res (en la imatge, no s'ha de poder anar al 9, ja que \u00e9s un fitxer). S'ha de controlar que hi ha perm\u00eds de lectura sobre un directori, abans de canviar a ell, sin\u00f3 donar\u00e0 error (en la imatge, per exemple, segurament no es podr\u00e0 canviar al directori root , ja que no tindrem perm\u00eds de lectura sobre ell). Aquesta comprovaci\u00f3 s'ha de fer abans de canviar al directori triat. I s'ha de controlar que el n\u00famero introdu\u00eft est\u00e0 en el rang correcte (en la imatge, de -1 fins a 28) La seg\u00fcent imatge mostra el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici T1_1"},{"location":"AD_T1_Sistema_de_fitxers/objectius/","text":"Objectius L'objectiu d'aquest apartat \u00e9s senzillament arribar als fitxers, per\u00f2 no al seu contingut, que es veur\u00e0 en el proper tema. Tan sols arribarem a \"veure\" el fitxer, amb la seua ruta. De fet la manera d'arribar a un directori i a un fitxer ser\u00e0 id\u00e8ntica. I del fitxer o directori podrem arribar a veure i tamb\u00e9 modificar les caracter\u00edstiques externes: nom, grand\u00e0ria, data d'\u00faltima modificaci\u00f3, permisos, ... \u00c9s un tema molt curtet que es podria haver englobat amb els dos temes seg\u00fcents, tamb\u00e9 de fitxers. Per\u00f2 hem preferit separar-lo per ser principi de curs, per a poder anar \"rodant\" sense presses. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T1_Sistema_de_fitxers/objectius/#objectius","text":"L'objectiu d'aquest apartat \u00e9s senzillament arribar als fitxers, per\u00f2 no al seu contingut, que es veur\u00e0 en el proper tema. Tan sols arribarem a \"veure\" el fitxer, amb la seua ruta. De fet la manera d'arribar a un directori i a un fitxer ser\u00e0 id\u00e8ntica. I del fitxer o directori podrem arribar a veure i tamb\u00e9 modificar les caracter\u00edstiques externes: nom, grand\u00e0ria, data d'\u00faltima modificaci\u00f3, permisos, ... \u00c9s un tema molt curtet que es podria haver englobat amb els dos temes seg\u00fcents, tamb\u00e9 de fitxers. Per\u00f2 hem preferit separar-lo per ser principi de curs, per a poder anar \"rodant\" sense presses. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/1__magatzems_i_fluxos_de_dades/","text":"1 - Magatzems i fluxos de dades En la major part de programes necessitem guardar informaci\u00f3 de forma permanent, de manera que perduren, encara que finalitze l'execuci\u00f3 del programa, o que servesquen de dades inicials. Els fitxers ens proporcionen la forma m\u00e9s senzilla de guardar informaci\u00f3. En el tema anterior vam veure com poder accedir tant a un directori com a un fitxer, per\u00f2 no vam accedir al contingut d'aquestos. Dels fitxers nom\u00e9s pod\u00edem veure les seues caracter\u00edstiques externes: nom, tipus, permisos, grand\u00e0ria, ... Per\u00f2 en cap moment vam accedir al seu contingut. Ser\u00e0 el que veurem en aquest tema. En un fitxer, com d\u00e8iem, quedar\u00e0 guardada la informaci\u00f3 de forma permanent. Ser\u00e0 una seq\u00fc\u00e8ncia de bits , un darrere de l'altre que representaran les dades guardades, b\u00e9 siguen car\u00e0cters d'un text, dades num\u00e9riques, o els bytes d'una imatge, per exemple. Aquesta seq\u00fc\u00e8ncia de bits ens aporta una visi\u00f3 est\u00e0tica de les dades, ja que queden guardades al llarg del temps. Posant un exemple cl\u00e0ssic, els pantans i dip\u00f2sits on s'emmagatzema l'aigua serien comparables als fitxers. Per\u00f2 per a nosaltres aquestos pantans i dip\u00f2sits queden lluny. I quan parlem d'aigua corrent tenim m\u00e9s tend\u00e8ncia a pensar en les canonades i aixetes que ens porten aquesta aigua emmagatzemada fins a nosaltres. Doncs de forma similar, des del punt de vista de l\u2019aplicaci\u00f3, el que realment cobra import\u00e0ncia \u00e9s la transfer\u00e8ncia de dades, m\u00e9s que el magatzem, que arriben aquestes dades a l'aplicaci\u00f3 o que l'aplicaci\u00f3 les puga transferir fins al fitxer. L\u2019eina que ens permet controlar aquestes transfer\u00e8ncies, de forma similar a les aixetes i canonades, l\u2019anomenem flux de dades . \u00c9s un concepte associat a la transmissi\u00f3 seq\u00fcencial d\u2019una s\u00e8rie de dades des de l\u2019aplicaci\u00f3 al dispositiu d\u2019emmagatzematge o a l\u2019inrev\u00e9s. Ens d\u00f3na una visi\u00f3 eminentment din\u00e0mica de la informaci\u00f3. Java utilitza els streams (fluxos de dades) per a poder accedir a la informaci\u00f3. Per\u00f2 els streams no limiten la transfer\u00e8ncia de dades d'un fitxer, sin\u00f3 que es generalitza per a qualsevol font de dades: mem\u00f2ria, xarxa, fins i tot altres aplicacions. D'aquesta manera es generalitza l'acc\u00e9s a la informaci\u00f3 des de qualsevol proced\u00e8ncia: si connectem un stream a un fitxer, estarem accedint a un fitxer, per\u00f2 si connectem el stream a un altre programa estarem accedint a les dades proporcionades per un altre programa. Intentarem veure exemples d'acc\u00e9s a diferents fonts a trav\u00e9s d'un stream, per\u00f2 ho aplicarem sobretot a l'acc\u00e9s a fitxers, clar. Fluxos d'entrada i d'eixida La primera diferenciaci\u00f3 que farem en els fluxos de dades \u00e9s si s\u00f3n d'entrada o d'eixida: Fluxos d'entrada s\u00f3n aquells que serviran per introduir dades des de l'exterior al programa, \u00e9s a dir a la zona de mem\u00f2ria controlada pel programa (variables, ...) Fluxos d'eixida s\u00f3n aquells que serviran per a guardar les dades des de les variables del programa fins a l'exterior, per exemple un fitxer, per a que es guarden de forma permanent. Fluxos i tipus de dades Per mig del stream aconseguirem que una dada es guarde en un fitxer, o millor dit una s\u00e8rie de dades. Quan guardem moltes dades, es compactaran unes al costat de les altres (el que hav\u00edem comentat com a seq\u00fcenciaci\u00f3 de bits). Si intentem recuperar-les, haurem d'anar amb molt de compte amb la grand\u00e0ria de cadascuna de les dades i el seu tipus. Anem a posar un exemple: Suposem que volem guardar una dada num\u00e8rica en un enter ( int ). Els enters, en Java, es guarden en 32 bits. Si volem guardar el n\u00famero 1.213.156.417 , ens quedar\u00e0 en binari (els hem posat en grups de 8 bits, per facilitar la lectura): 01001000 01001111 01001100 01000001 Suposem ara que volem guardar dos n\u00fameros enters, per\u00f2 del tipus short , que nom\u00e9s ocupa 16 bits. El n\u00famero 18.511 es representa en binari com 01001000 01001111, i el n\u00famero 19.521 es representa 01001100 01000001. Si posem una dada darrere de l'altra (com es guardar\u00e0 en un fitxer), el resultat ser\u00e0: 01001000 01001111 01001100 01000001 Suposem ara que volem guardar la paraula HOLA. Si guardem el codi ASCII de cada lletra tindrem: H (01001000), O (01001111), L (01001100) i A (01000001) 01001000 01001111 01001100 01000001 En resum, les 3 informacions (el n\u00famero de 32 bits, els 2 n\u00fameros de 16 bits, i la paraula HOLA) es guarden de forma id\u00e8ntica, com a seq\u00fc\u00e8ncia de bits. Per tant, l'\u00fanica manera de poder recuperar la informaci\u00f3 \u00e9s saber de quin tipus \u00e9s i la mida, a banda de l'ordre com est\u00e0 guardada, clar. Els fluxos de dades de Java transfereixen les dades de manera transparent al programador. No cal indicar la quantitat de bits que cal transferir, sin\u00f3 que es dedueix a partir del tipus de dada que la variable representa. Per\u00f2 sempre haurem de tenir present el tipus de dades i l'ordre. Hi ha, per\u00f2, una excepci\u00f3 amb el tipus char . La multitud d\u2019est\u00e0ndards de codificaci\u00f3 de car\u00e0cters existents en l\u2019actualitat i la diversitat de formats utilitzats a l\u2019hora d\u2019implementar les codificacions, usant segons el cas 8, 16, 32 bits o fins i tot una longitud variable en funci\u00f3 del car\u00e0cter a representar, fan que siga molt dif\u00edcil tractar aquest tipus de dades com una simple seq\u00fc\u00e8ncia de bytes. Internament, Java representa el tipus car\u00e0cter amb una codificaci\u00f3 UNICODE de 16 bits (UTF-16) per tal de suportar m\u00faltiples alfabets a banda de l\u2019occidental. Tot i aix\u00ed, \u00e9s capa\u00e7 de gestionar fonts de dades (fitxers entre d\u2019altres) de diverses codificacions (ASCII, ISO-8859, UTF-8, UTF-16\u2026). En funci\u00f3 de la codificaci\u00f3 triada, el n\u00famero de bits utilitzats en l\u2019emmagatzematge variar\u00e0. Es fa necessari, doncs, un tractament especial a l\u2019hora de manipular aquestes dades. Com veurem, Java disposa d\u2019una jerarquia espec\u00edfica de classes orientades a fluxos de car\u00e0cters per tal de fer aquestos canvis i transformacions totalment transparents al programador. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Magatzems i fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/1__magatzems_i_fluxos_de_dades/#1-magatzems-i-fluxos-de-dades","text":"En la major part de programes necessitem guardar informaci\u00f3 de forma permanent, de manera que perduren, encara que finalitze l'execuci\u00f3 del programa, o que servesquen de dades inicials. Els fitxers ens proporcionen la forma m\u00e9s senzilla de guardar informaci\u00f3. En el tema anterior vam veure com poder accedir tant a un directori com a un fitxer, per\u00f2 no vam accedir al contingut d'aquestos. Dels fitxers nom\u00e9s pod\u00edem veure les seues caracter\u00edstiques externes: nom, tipus, permisos, grand\u00e0ria, ... Per\u00f2 en cap moment vam accedir al seu contingut. Ser\u00e0 el que veurem en aquest tema. En un fitxer, com d\u00e8iem, quedar\u00e0 guardada la informaci\u00f3 de forma permanent. Ser\u00e0 una seq\u00fc\u00e8ncia de bits , un darrere de l'altre que representaran les dades guardades, b\u00e9 siguen car\u00e0cters d'un text, dades num\u00e9riques, o els bytes d'una imatge, per exemple. Aquesta seq\u00fc\u00e8ncia de bits ens aporta una visi\u00f3 est\u00e0tica de les dades, ja que queden guardades al llarg del temps. Posant un exemple cl\u00e0ssic, els pantans i dip\u00f2sits on s'emmagatzema l'aigua serien comparables als fitxers. Per\u00f2 per a nosaltres aquestos pantans i dip\u00f2sits queden lluny. I quan parlem d'aigua corrent tenim m\u00e9s tend\u00e8ncia a pensar en les canonades i aixetes que ens porten aquesta aigua emmagatzemada fins a nosaltres. Doncs de forma similar, des del punt de vista de l\u2019aplicaci\u00f3, el que realment cobra import\u00e0ncia \u00e9s la transfer\u00e8ncia de dades, m\u00e9s que el magatzem, que arriben aquestes dades a l'aplicaci\u00f3 o que l'aplicaci\u00f3 les puga transferir fins al fitxer. L\u2019eina que ens permet controlar aquestes transfer\u00e8ncies, de forma similar a les aixetes i canonades, l\u2019anomenem flux de dades . \u00c9s un concepte associat a la transmissi\u00f3 seq\u00fcencial d\u2019una s\u00e8rie de dades des de l\u2019aplicaci\u00f3 al dispositiu d\u2019emmagatzematge o a l\u2019inrev\u00e9s. Ens d\u00f3na una visi\u00f3 eminentment din\u00e0mica de la informaci\u00f3. Java utilitza els streams (fluxos de dades) per a poder accedir a la informaci\u00f3. Per\u00f2 els streams no limiten la transfer\u00e8ncia de dades d'un fitxer, sin\u00f3 que es generalitza per a qualsevol font de dades: mem\u00f2ria, xarxa, fins i tot altres aplicacions. D'aquesta manera es generalitza l'acc\u00e9s a la informaci\u00f3 des de qualsevol proced\u00e8ncia: si connectem un stream a un fitxer, estarem accedint a un fitxer, per\u00f2 si connectem el stream a un altre programa estarem accedint a les dades proporcionades per un altre programa. Intentarem veure exemples d'acc\u00e9s a diferents fonts a trav\u00e9s d'un stream, per\u00f2 ho aplicarem sobretot a l'acc\u00e9s a fitxers, clar. Fluxos d'entrada i d'eixida La primera diferenciaci\u00f3 que farem en els fluxos de dades \u00e9s si s\u00f3n d'entrada o d'eixida: Fluxos d'entrada s\u00f3n aquells que serviran per introduir dades des de l'exterior al programa, \u00e9s a dir a la zona de mem\u00f2ria controlada pel programa (variables, ...) Fluxos d'eixida s\u00f3n aquells que serviran per a guardar les dades des de les variables del programa fins a l'exterior, per exemple un fitxer, per a que es guarden de forma permanent. Fluxos i tipus de dades Per mig del stream aconseguirem que una dada es guarde en un fitxer, o millor dit una s\u00e8rie de dades. Quan guardem moltes dades, es compactaran unes al costat de les altres (el que hav\u00edem comentat com a seq\u00fcenciaci\u00f3 de bits). Si intentem recuperar-les, haurem d'anar amb molt de compte amb la grand\u00e0ria de cadascuna de les dades i el seu tipus. Anem a posar un exemple: Suposem que volem guardar una dada num\u00e8rica en un enter ( int ). Els enters, en Java, es guarden en 32 bits. Si volem guardar el n\u00famero 1.213.156.417 , ens quedar\u00e0 en binari (els hem posat en grups de 8 bits, per facilitar la lectura): 01001000 01001111 01001100 01000001 Suposem ara que volem guardar dos n\u00fameros enters, per\u00f2 del tipus short , que nom\u00e9s ocupa 16 bits. El n\u00famero 18.511 es representa en binari com 01001000 01001111, i el n\u00famero 19.521 es representa 01001100 01000001. Si posem una dada darrere de l'altra (com es guardar\u00e0 en un fitxer), el resultat ser\u00e0: 01001000 01001111 01001100 01000001 Suposem ara que volem guardar la paraula HOLA. Si guardem el codi ASCII de cada lletra tindrem: H (01001000), O (01001111), L (01001100) i A (01000001) 01001000 01001111 01001100 01000001 En resum, les 3 informacions (el n\u00famero de 32 bits, els 2 n\u00fameros de 16 bits, i la paraula HOLA) es guarden de forma id\u00e8ntica, com a seq\u00fc\u00e8ncia de bits. Per tant, l'\u00fanica manera de poder recuperar la informaci\u00f3 \u00e9s saber de quin tipus \u00e9s i la mida, a banda de l'ordre com est\u00e0 guardada, clar. Els fluxos de dades de Java transfereixen les dades de manera transparent al programador. No cal indicar la quantitat de bits que cal transferir, sin\u00f3 que es dedueix a partir del tipus de dada que la variable representa. Per\u00f2 sempre haurem de tenir present el tipus de dades i l'ordre. Hi ha, per\u00f2, una excepci\u00f3 amb el tipus char . La multitud d\u2019est\u00e0ndards de codificaci\u00f3 de car\u00e0cters existents en l\u2019actualitat i la diversitat de formats utilitzats a l\u2019hora d\u2019implementar les codificacions, usant segons el cas 8, 16, 32 bits o fins i tot una longitud variable en funci\u00f3 del car\u00e0cter a representar, fan que siga molt dif\u00edcil tractar aquest tipus de dades com una simple seq\u00fc\u00e8ncia de bytes. Internament, Java representa el tipus car\u00e0cter amb una codificaci\u00f3 UNICODE de 16 bits (UTF-16) per tal de suportar m\u00faltiples alfabets a banda de l\u2019occidental. Tot i aix\u00ed, \u00e9s capa\u00e7 de gestionar fonts de dades (fitxers entre d\u2019altres) de diverses codificacions (ASCII, ISO-8859, UTF-8, UTF-16\u2026). En funci\u00f3 de la codificaci\u00f3 triada, el n\u00famero de bits utilitzats en l\u2019emmagatzematge variar\u00e0. Es fa necessari, doncs, un tractament especial a l\u2019hora de manipular aquestes dades. Com veurem, Java disposa d\u2019una jerarquia espec\u00edfica de classes orientades a fluxos de car\u00e0cters per tal de fer aquestos canvis i transformacions totalment transparents al programador. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Magatzems i fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/","text":"2 - Manipulaci\u00f3 dels fluxos de dades En Java, i per tant tamb\u00e9 en Kotlin, no tindrem una \u00fanica classe per a manipular els fluxos de dades i aix\u00ed arribar al contingut dels fitxers. \u00c9s una cosa que de vegades se li critica a Java, que hi ha una jerarquia molt extensa de fluxos, i s\u00f3n moltes classes a recordar i utilitzar. Per contra fa que siga molt vers\u00e0til. En l'\u00faltim punt del tema veurem la simplificaci\u00f3 que ens proposa Kotlin. Aquestes classes es trobaran en dues jerarquies, la dels fluxos orientats a bytes i la dels fluxos orientats a car\u00e0cters . Si les nostres dades s\u00f3n num\u00e8riques o de qualsevol altre tipus que puguem imaginar (imatges per exemple), ens convindran les primeres. Si la informaci\u00f3 \u00e9s de car\u00e0cters, haurem d'utilitzar la segona jerarquia. La ra\u00f3 de que existesca aquesta segona jerarquia orientada a car\u00e0cters \u00e9s la multitud de sistemes de codificaci\u00f3 existents. Com hav\u00edem comentat en la pregunta anterior, Java utilitza internament codificaci\u00f3 UNICODE de 16 bits (UTF-16), on cada car\u00e0cter ocupa 16 bits i aix\u00ed poder suportar tots els llenguatges com el grec, \u00e0rab, cir\u00edl\u00b7lic, xin\u00e8s, .... Per\u00f2 UTF-8 est\u00e0 molt est\u00e9s, i en aquesta codificaci\u00f3 de vegades un car\u00e0cter ocupa 8 bits, i de vegades 16. I no podem oblidar altres sistemes de codificaci\u00f3, com ASCII, ISO-8859, ... La jerarquia de classes orientades a car\u00e0cter suportar\u00e0 totes les codificacions. 2.1 - Fluxos orientats a bytes - Classes L'arrel, la base de tota la jerarquia s\u00f3n InputStream i OutputStream , respectivament per a fluxos d'entrada i d'eixida. Comentarem els fluxos d'entrada, i els d'eixida s\u00f3n totalment paral\u00b7lels. La super-classe InputStream servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de bytes, una tuberia (per a dur dades des d'una altra aplicaci\u00f3)... Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileInputStream ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten de la super-classe i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileInputStream Per a llegir informaci\u00f3 d'un fitxer PipedInputStream Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) ByteArrayInputStream L'entrada ser\u00e0 un array de bytes SequenceInputStream Servir\u00e0 per enlla\u00e7ar dues entrades en una de sola, seq\u00fcencialment Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades, per\u00f2 posarem algun exemple de les altres (concretament ByteArrayInputStream ). Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de OutputStream : Classe Explicaci\u00f3 FileOutputStream Per a guardar informaci\u00f3 en un fitxer PipedOutputStream Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) ByteArrayOutputStream L'eixida ser\u00e0 un array de bytes Constructors de FileInputStream Com hem comentat, qui m\u00e9s ens interessa de tots els InputStream \u00e9s el FileInpuStream , per a poder accedir a la informaci\u00f3 d'un fitxer. Dos s\u00f3n els constructors de FileInputStream: FileInputStream ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileInputStream ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileOutputStream Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileOutputStream ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileOutputStream ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. FileOutputStream ( f : File, afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true , en cas que ja existira el fitxer, la informaci\u00f3 s'afegir\u00e0 al final, en compte de substituir el que ja hi havia. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). FileOutputStream ( nom_f : String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. 2.1.1 - M\u00e8todes del InputStream Nota Per a fer els primers exemples, i \u00fanicament per comoditat, utilitzarem fitxers de text, encara que estiguem en fluxos orientats a byte. A\u00e7\u00f2 no \u00e9s l'adequat, ja que per a fitxers de text haur\u00edem d'utilitzar fluxos orientats a car\u00e0cter. Per\u00f2 com dic \u00e9s per comoditat, perqu\u00e8 ser\u00e0 molt f\u00e0cil crear fitxers des de qualsevol editor de textos, i que despr\u00e9s utilitzarem des de Java o Kotlin. L'inconvenient ser\u00e0 que no tots els car\u00e0cters eixiran de forma correcta, justament per utilitzar els fluxos de dades orientats a byte. El primer m\u00e8tode que hem de veure del InputStream \u00e9s aquell que ens permet una lectura senzilla: int read() : llig el seg\u00fcent byte del flux d'entrada i el retorna com un enter . Si no hi ha cap byte disponible perqu\u00e8 s\u2019ha arribat al final de la seq\u00fc\u00e8ncia de bytes, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent byte per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre byte, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de bytes, ...). I observeu com es tracta d'una lectura seq\u00fcencial. Comencem pel primer byte del fitxer, i a cada read llig el seg\u00fcent byte fins arribar al final. Els tractaments que veurem en aquest tema seran sempre seq\u00fcencials. Abans de veure altres m\u00e8todes, mirem un exemple. Per a aquest exemple fa falta un fitxer anomenat f1.txt , que pot ser un fitxer de text creat amb qualsevol editor senzillet, com per exemple gedit o el Bloc de notes . Ha d'estar en el directori del projecte (el projecte Tema2 ), i aix\u00ed no caldr\u00e0 posar la ruta. Per exemple podr\u00edem posar el seg\u00fcent contingut: Hola, qu\u00e8 tal? El que far\u00e0 el programa \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). L'heu de copiar en un fitxer anomenat Exemple_2_01.kt dins d'un paquet anomenat exemples en el projecte del Tema 2: package exemples import java.io.FileInputStream fun main(args: Array<String>){ val f_in = FileInputStream(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } El resultat en Ubuntu ser\u00e0 aquest: H o l a , q u \u00c3 \u00a8 t a l ? Potser en Windows si que apareguen b\u00e9 tots els car\u00e0cters, ja que utilitza per defecte una altra codificaci\u00f3. Per\u00f2 no li donarem ara import\u00e0ncia al fet que no apareguen b\u00e9 els car\u00e0cters especials. Observeu com estem utilitzant un InputStream , concretament un FileInputStream , per a llegir un fitxer de text. A\u00e7\u00f2 no \u00e9s el m\u00e9s apropiat, com ja hav\u00edem comentat abans, sin\u00f3 que haur\u00edem d'utilitzar algun flux orientat a car\u00e0cters, i no orientat a bytes. El programa funcionar\u00e0 si utilitzem codificaci\u00f3 ASCII (o ISO-8859) ja que cada car\u00e0cter es guarda en un byte. Si ens despistem i el fitxer el gaurdem en UTF-8, no eixiran b\u00e9 els car\u00e0cters com \u00e7, \u00f1 o vocals accentuades (que es guarden en 2 bytes). I si el guardem en UTF-16, encara eixir\u00e0 pitjor. Hem utilitzat el constructor que accepta un String com a par\u00e0metre. Queda m\u00e9s curt, per\u00f2 seria totalment equivalent substituir la construcci\u00f3 anterior per aquestes dues l\u00ednies val f = File(\"f1.txt\") val f_in = FileInputStream(f) El read obt\u00e9 un enter, que despr\u00e9s l'intentem convertir en car\u00e0cter. Finalitzem quan l'enter \u00e9s -1. Aquest segon exemple t\u00e9 l'entrada no des d'un fitxer, sin\u00f3 des d'un ByteArrayInputStream . A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu-lo en un fitxer anomenat Exemple_2_02.kt : package exemples import java.io.ByteArrayInputStream fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = ByteArrayInputStream(ent_1.toByteArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Una altra vegada els car\u00e0cters especial eixiran malament, ja que en compte de un InputStream (en aquest cas ByteArrayInputStream ) el m\u00e9s adequat seria un flux orientat a car\u00e0cters, per\u00f2 com a exemple s\u00ed que ens val. Mirem un tercer exemple, per veure el SequenceInputStream , on es poden enganxar de forma sequencial diferents InputStream. Despr\u00e9s d'aquest exemple ja ens centrarem en els fitxers, que \u00e9s el que ens interessa. Copieu-lo en un fitxer anomenat Exemple_2_03.kt : package exemples import java.io.ByteArrayInputStream import java.io.FileInputStream import java.io.SequenceInputStream fun main(args: Array<String>) { val f1 = FileInputStream(\"f1.txt\") val ent_1 = \"Aquest \u00e9s un byte array\" val f2 = ByteArrayInputStream(ent_1.toByteArray()) val f_in = SequenceInputStream(f1,f2) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del InputStream s\u00f3n: int read( buffer : ByteArray) : llig un n\u00famero determinat de bytes de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de bytes llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou bytes, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de bytes que realment s'han llegit com un enter. Si no hi haguera cap byte disponible, es retornar\u00e0 -1. int available() : indica quants bytes hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle (si hi ha 0 bytes disponibles, \u00e9s que ja hem acabat), encara que hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip( despl : Long) : salta, despreciant-los, tant bytes com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de bytes especificat per diferents raons. Torna el n\u00famero de bytes realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . Fa falta que existesca un fitxer anomenat f2.txt en l'arrel del projecte, com es comenta despr\u00e9s. Copieu-lo en un fitxer anomenat Exemple_2_04.kt : package exemples import java.io.FileInputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") var buffer = ByteArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que es guarda en un buffer de bytes (bytes, no car\u00e0cters), haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) convertint cada byte en car\u00e0cter. Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Si per exemple el contingut de f2.txt \u00e9s aquest: Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. Aquesta seria l'eixida: Hola. Aquest \uffc3\uffa9s un text m\uffc3\uffa9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\uffc3\uffa0cters. Com que ho llegim des d'un InputStream, els car\uffc3 \uffa0cters especials potser no isq uen b\uffc3\uffa9. Recordeu que estem llegint un fitxer de text des d'un InputStream, cosa gens convenient ja que els car\u00e0cters com \u00e7, \u00f1, o vocals accentuades dif\u00edcilment podrem fer que apareguen b\u00e9. Ho arreglarem amb els fluxos orientats a car\u00e0cter. 2.1.2 - M\u00e8todes del OutputStream Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un byte (recordeu que estem en fluxos orientats a bytes). void write( byte : Int) : escriu el byte passat com a par\u00e0metre en el flux d'eixida. Encara que el par\u00e0metre \u00e9s de tipus int, nom\u00e9s s'escriur\u00e0 un byte. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en qu\u00e8 guardarem en un fitxer el contingut d'una cadena (encara que ja sabem que no \u00e9s el m\u00e9s apropiat utilitzar fluxos orientats a bytes per a informaci\u00f3 de car\u00e0cters). En aquest primer exemple del OutputStream treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant tancar \u00e9s una operaci\u00f3 ben important que no hem d'oblidar . Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_11.kt : package exemples import java.io.FileOutputStream fun main(args: Array<String>) { val text = \"Contingut per al fitxer.\" val f_out = FileOutputStream(\"f3.txt\") for (c in text) f_out.write(c.toInt()) f_out.close() } Observeu com hem convertit cada car\u00e0cter a Int per a que puga funcionar, ja que el m\u00e8tode write() accepta un enter. En el constructor del OutputStream no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat. Contingut per al fitxer. La codificaci\u00f3 del fitxer haur\u00e0 segut la que tinga per defecte el Sistema Operatiu, que en el cas d'Ubuntu \u00e9s UTF-8, i en el cas de Windows \u00e9s ISO-8859. Anem a provar a substituir el constructor, posant ara val f_out = FileOutputStream(\"f3.txt\",true) Si l'executem una altra vegada, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer.Contingut per al fitxer. Altres m\u00e8todes del OutputStream s\u00f3n: void write( buffer : ByteArray) : escriu el contingut de l'array de bytes al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer : ByteArray, pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants bytes com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els bytes que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. En aquest exemple es copia el contingut del fitxer f2.txt en el fitxer f4.txt , per\u00f2 en compte d'anar byte a byte, anirem de 30 en 30, amb un buffer de 30 posicions. Podr\u00edem cometre l'error de la l\u00ednia 13 del seg\u00fcent programa, la del comentari, d'escriure sempre els 30 car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_12.kt : package exemples import java.io.FileInputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") val f_out = FileOutputStream(\"f4.txt\") var buffer = ByteArray(30) var num = f_in.read(buffer) while (num != -1) { f_out.write(buffer) // a\u00e7\u00f2 \u00e9s un error num = f_in.read(buffer) } f_in.close(); f_out.close(); } D'aquesta manera, l'\u00faltima vegada que \u00e9s llig \u00e9s molt possible que no hi hagen exactament 30 car\u00e0cters. Si hi ha menys de 30 car\u00e0cters, nom\u00e9s es llegiran els que queden al principi del buffer, i en la resta del buffer hi ha la informaci\u00f3 anterior, la de la pen\u00faltima lectura. En definitiva, tenim \"basura\", i si no ho controlem el resultat no ser\u00e0 el correcte. Aquest ser`el contingut de f4.txt : Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. pecials potser no isq Ha eixit d'aquesta manera perqu\u00e8 l'\u00faltima vegada nom\u00e9s s'han llegit 9 bytes. Els 21 restants tenen la informaci\u00f3 encara de la pen\u00faltima lectura. Per a fer-lo de forma correcta, ens aprofitem de que read(buffer) torna el n\u00famero de bytes realment llegits, per escriure exactament aquest n\u00famero. Per tant substituirem la l\u00ednia 13, la del comentari, per aquesta altra: f_out.write(buffer,0,num) // ara s\u00ed que funcionar\u00e0 b\u00e9 Ara el contingut de f4.txt ser\u00e0 id\u00e8ntic al de f2.txt Nota important Per a assegurar-nos que realment escrivim en el fitxer i no es queda res en la mem\u00f2ria interm\u00e8dia, hem de tancar sempre els fluxos d'eixida . Si ens oblidem de tancar-los, \u00e9s molt f\u00e0cil que no s'acabe d'escriure f\u00edsicament en el fitxer. 2.2 - Fluxos orientats a car\u00e0cters - Classes Treballar amb car\u00e0cters implica una dificultat apreciable, a causa sobretot de la diversitat de codificacions existents. Per poder solucionar-ho, Java disposa de dues jerarquies, una d'entrada i una d'eixida, diferents de les que ja hem vist per a bytes (que eren InputStream i OutputStream). Aquestes jerarquies per a car\u00e0cters seran molt semblants a les de bytes, per\u00f2 sempre orientades a car\u00e0cters. Kotlin, per heretar de Java, tamb\u00e9 les tindr\u00e0, encara que com veurem en l'\u00faltima pregunta, podrem simplificar les coses. Igual que en els casos anteriors, tindrem unes classes abstractes, Reader i Writer , que no es poden instanciar directament (no podrem crear un objecte d'aquestes classes). Serviran per a homogene\u00eftzar tots els fluxos d'entrada i d'exida orientats a car\u00e0cter. La super-classe Reader servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de car\u00e0cters, una canonada (\"tuberia\", per a dur dades des d'una altra aplicaci\u00f3). Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileReader ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten d'ella i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileReader Per a llegir car\u00e0cters d'un fitxer PipedReader Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) CharArrayReader L'entrada ser\u00e0 un array de car\u00e0cters StringReader L'entrada ser\u00e0 un string Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades. Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de Writer : Classe Explicaci\u00f3 FileWriter Per a guardar car\u00e0cters en un fitxer Piped Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) CharArrayWriter L'eixida ser\u00e0 un array de car\u00e0cters StringWriter L'eixida ser\u00e0 un string Hem de fer constar que les classes d\u2019emmagatzematge intern (utilitzem Java o Kotlin), com ara CharArrayReader , CharArrayWriter , StringReader , StringWriter , PipedReader , PipedWriter utilitzen sempre la codificaci\u00f3 pr\u00f2pia de Java (unicode de 16 bits: UTF-16 ), ja que guarden les dades a la mem\u00f2ria basant-se en els tipus dades de tractament de car\u00e0cters de Java o Kotlin (C har i String ). En canvi les classes FileReader o FileWriter agafen la codificaci\u00f3 per defecte del sistema operatiu amfitri\u00f3 . L\u2019usuari no pot seleccionar diferents sistemes de codificaci\u00f3 en crear les inst\u00e0ncies. Aix\u00ed, una m\u00e0quina virtual Java sobre Windows utilitzar\u00e0, per defecte, la codificaci\u00f3 ISO-8859-1, per\u00f2 si corre sobre Linux, la codificaci\u00f3 ser\u00e0 UTF-8. De tota manera veurem que s\u00ed que podrem arribar a especificar quin \u00e9s el joc de car\u00e0cters que volem utilitzar en la pregunta 3.3. Intentarem veure exemples de tot. Constructors de FileReader De forma totalment paral\u00b7lela als fluxos orientats a byte, el FileReader t\u00e9 dos constructors, acceptant com a par\u00e0metre un File o un String (amb el nom del fitxer). La difer\u00e8ncia ara \u00e9s que la unitat de transfer\u00e8ncia ser\u00e0 el car\u00e0cter (en compte d'un byte): FileReader ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileReader ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileWriter Tamb\u00e9 totalment paral\u00b7lel al FileOutputStream. Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileWriter ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileWriter ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. File Writer (f: File , afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true en compte de substituir el que ja hi havia, la informaci\u00f3 s'afegir\u00e0 al final. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). File Writer (nom_f: String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. 2.2.1 - M\u00e8todes del Reader Els m\u00e8todes del Reader s\u00f3n absolutament similars als del InputStream . La difer\u00e8ncia \u00e9s que ara llegir\u00e0 sempre un car\u00e0cter. I no ens haurem de preocupar pel format en qu\u00e8 est\u00e0 guardat, i de i ocupa un o dos bytes. Sempre el llegir\u00e0 b\u00e9, siga quina siga la codificaci\u00f3 utilitzada, com ja hav\u00edem comentat abans: int read() : llig el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com un enter. Si no hi ha cap car\u00e0cter disponible perqu\u00e8 s\u2019ha assolit el final de la seq\u00fc\u00e8ncia, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent car\u00e0cter per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre car\u00e0cter, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de car\u00e0cters, ...). Abans de veure altres m\u00e8todes, mirem un exemple que \u00e9s id\u00e8ntic al primer exemple del InputStream, per\u00f2 canviant FileInputStream per FileReader. Llegir\u00e0 el mateix fitxer anomenat f1.txt , utilitzat en aquell moment, per\u00f2 ara segurament llegir\u00e0 tots els car\u00e0cters b\u00e9. El que far\u00e0 \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_21.kt : package exemples import java.io.FileReader fun main(args: Array<String>){ val f_in = FileReader(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } Ara segurament s\u00ed que haur\u00e0 llegit b\u00e9 tots els car\u00e0cters, incloent \u00f1, \u00e7, vocals accentuades, etc. Si encara tenim el mateix contingut en f1.txt , el resultat ser\u00e0 ara: H o l a , q u \u00e8 t a l ? El m\u00e9s normal \u00e9s que en crear el fitxer f1.txt amb algun editor, el guardem amb la codificaci\u00f3 per defecte, que en cas de Windows \u00e9s ASCII (o ISO-8859) i en el cas de Linux \u00e9s UTF-8. I despr\u00e9s des de Java, el FileReader utilitzar\u00e0 la codificaci\u00f3 per defecte del Sistema Operatiu. \u00c9s a dir que en Linux el fitxer ha d'estar guardat en UTF-8 per a que el puga llegir b\u00e9, i en Windows en ASCII. Mirem tamb\u00e9 l'exemple equivalent al segon. All\u00e0 utilitz\u00e0vem un ByteArrayInputStream com a entrada. Ara podr\u00edem utilitzar un CharArrayReader , per\u00f2 ho farem amb un StringReader , i quedar\u00e0 m\u00e9s curt. A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_22.kt : package exemples import java.io.CharArrayReader fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = CharArrayReader(ent_1.toCharArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del Reader s\u00f3n: int read(char[ ] buffer ) : llig un n\u00famero determinat de car\u00e0cters de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de car\u00e0cters llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou car\u00e0cters, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de car\u00e0cters que realment s'han llegit com un enter. Si no hi haguera cap car\u00e0cter disponible, es retornaria -1. int available() : indica quants car\u00e0cters hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle: si hi ha 0 car\u00e0cters disponibles, \u00e9s que ja hem acabat. Tot i aix\u00f2, hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip(long despl ) : salta, despreciant-los, tants car\u00e0cters com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de car\u00e0cters especificat per diferents raons. Torna el n\u00famero de car\u00e0cters realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . \u00c9s id\u00e8ntic al de l'apartat del InputStream. La difer\u00e8ncia \u00e9s que ara s'haurien de llegir b\u00e9 tots els car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_23.kt : package exemples import java.io.FileReader fun main(args: Array<String>) { val f_in = FileReader(\"f2.txt\") var buffer = CharArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que ara es guarda en un buffer de car\u00e0cters, haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) . Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Aquesta seria l'eixida: Hola. Aquest \u00e9s un text m\u00e9s ll arg, per veure com gestiona el s bytes amb un buffer de 30 ca r\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cte rs especials potser no isquen b\u00e9. Efectivament, s'han llegit tots els car\u00e0cters perfectament. 2.2.2 - M\u00e8todes del Writer Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un car\u00e0cter. void write( car : Int) : escriu el car\u00e0cter passat com a par\u00e0metre en el flux d'eixida. En cas que siga un FileWriter, escriur\u00e0 el car\u00e0cter amb la codificaci\u00f3 per defecte del S.O. : en Windows ISO-8839 i en Linux UTF-8. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en el qual guardarem en un fitxer el contingut d'una cadena, ara ja sense por als car\u00e0cters estranys. En aquest primer exemple del Writer treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_31.kt : Nota Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant \u00e9s una operaci\u00f3 ben important que no hem d'oblidar. package exemples import java.io.FileWriter fun main(args: Array<String>) { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" val f_out = FileWriter (\"f5.txt\") for (c in text) { f_out.write(c.toInt()) } f_out.close() } En el constructor del Writer no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat en f5.txt Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Anem a provar a substituir el constructor, posant ara val f_out = FileWriter (\"f5.txt\", true) Si l'executem, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Altres m\u00e8todes del Writer s\u00f3n: void write( buffer : CharArray) : escriu el contingut de l'array de car\u00e0cters al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer: CharArray , pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants car\u00e0cters com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els car\u00e0cters que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. Aquestos m\u00e8todes s\u00f3n totalment similars als del OutputStream. A banda d'aquestos, el Writer t\u00e9 un altre, que pot ser especialment \u00fatil per a car\u00e0cters: void write( text : String) : escriu tot el contingut del String en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Manipulaci\u00f3 dels fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#2-manipulacio-dels-fluxos-de-dades","text":"En Java, i per tant tamb\u00e9 en Kotlin, no tindrem una \u00fanica classe per a manipular els fluxos de dades i aix\u00ed arribar al contingut dels fitxers. \u00c9s una cosa que de vegades se li critica a Java, que hi ha una jerarquia molt extensa de fluxos, i s\u00f3n moltes classes a recordar i utilitzar. Per contra fa que siga molt vers\u00e0til. En l'\u00faltim punt del tema veurem la simplificaci\u00f3 que ens proposa Kotlin. Aquestes classes es trobaran en dues jerarquies, la dels fluxos orientats a bytes i la dels fluxos orientats a car\u00e0cters . Si les nostres dades s\u00f3n num\u00e8riques o de qualsevol altre tipus que puguem imaginar (imatges per exemple), ens convindran les primeres. Si la informaci\u00f3 \u00e9s de car\u00e0cters, haurem d'utilitzar la segona jerarquia. La ra\u00f3 de que existesca aquesta segona jerarquia orientada a car\u00e0cters \u00e9s la multitud de sistemes de codificaci\u00f3 existents. Com hav\u00edem comentat en la pregunta anterior, Java utilitza internament codificaci\u00f3 UNICODE de 16 bits (UTF-16), on cada car\u00e0cter ocupa 16 bits i aix\u00ed poder suportar tots els llenguatges com el grec, \u00e0rab, cir\u00edl\u00b7lic, xin\u00e8s, .... Per\u00f2 UTF-8 est\u00e0 molt est\u00e9s, i en aquesta codificaci\u00f3 de vegades un car\u00e0cter ocupa 8 bits, i de vegades 16. I no podem oblidar altres sistemes de codificaci\u00f3, com ASCII, ISO-8859, ... La jerarquia de classes orientades a car\u00e0cter suportar\u00e0 totes les codificacions.","title":"2 - Manipulaci\u00f3 dels fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#21-fluxos-orientats-a-bytes-classes","text":"L'arrel, la base de tota la jerarquia s\u00f3n InputStream i OutputStream , respectivament per a fluxos d'entrada i d'eixida. Comentarem els fluxos d'entrada, i els d'eixida s\u00f3n totalment paral\u00b7lels. La super-classe InputStream servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de bytes, una tuberia (per a dur dades des d'una altra aplicaci\u00f3)... Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileInputStream ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten de la super-classe i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileInputStream Per a llegir informaci\u00f3 d'un fitxer PipedInputStream Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) ByteArrayInputStream L'entrada ser\u00e0 un array de bytes SequenceInputStream Servir\u00e0 per enlla\u00e7ar dues entrades en una de sola, seq\u00fcencialment Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades, per\u00f2 posarem algun exemple de les altres (concretament ByteArrayInputStream ). Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de OutputStream : Classe Explicaci\u00f3 FileOutputStream Per a guardar informaci\u00f3 en un fitxer PipedOutputStream Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) ByteArrayOutputStream L'eixida ser\u00e0 un array de bytes Constructors de FileInputStream Com hem comentat, qui m\u00e9s ens interessa de tots els InputStream \u00e9s el FileInpuStream , per a poder accedir a la informaci\u00f3 d'un fitxer. Dos s\u00f3n els constructors de FileInputStream: FileInputStream ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileInputStream ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileOutputStream Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileOutputStream ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileOutputStream ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. FileOutputStream ( f : File, afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true , en cas que ja existira el fitxer, la informaci\u00f3 s'afegir\u00e0 al final, en compte de substituir el que ja hi havia. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). FileOutputStream ( nom_f : String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer.","title":"2.1 - Fluxos orientats a bytes - Classes"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#211-metodes-del-inputstream","text":"Nota Per a fer els primers exemples, i \u00fanicament per comoditat, utilitzarem fitxers de text, encara que estiguem en fluxos orientats a byte. A\u00e7\u00f2 no \u00e9s l'adequat, ja que per a fitxers de text haur\u00edem d'utilitzar fluxos orientats a car\u00e0cter. Per\u00f2 com dic \u00e9s per comoditat, perqu\u00e8 ser\u00e0 molt f\u00e0cil crear fitxers des de qualsevol editor de textos, i que despr\u00e9s utilitzarem des de Java o Kotlin. L'inconvenient ser\u00e0 que no tots els car\u00e0cters eixiran de forma correcta, justament per utilitzar els fluxos de dades orientats a byte. El primer m\u00e8tode que hem de veure del InputStream \u00e9s aquell que ens permet una lectura senzilla: int read() : llig el seg\u00fcent byte del flux d'entrada i el retorna com un enter . Si no hi ha cap byte disponible perqu\u00e8 s\u2019ha arribat al final de la seq\u00fc\u00e8ncia de bytes, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent byte per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre byte, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de bytes, ...). I observeu com es tracta d'una lectura seq\u00fcencial. Comencem pel primer byte del fitxer, i a cada read llig el seg\u00fcent byte fins arribar al final. Els tractaments que veurem en aquest tema seran sempre seq\u00fcencials. Abans de veure altres m\u00e8todes, mirem un exemple. Per a aquest exemple fa falta un fitxer anomenat f1.txt , que pot ser un fitxer de text creat amb qualsevol editor senzillet, com per exemple gedit o el Bloc de notes . Ha d'estar en el directori del projecte (el projecte Tema2 ), i aix\u00ed no caldr\u00e0 posar la ruta. Per exemple podr\u00edem posar el seg\u00fcent contingut: Hola, qu\u00e8 tal? El que far\u00e0 el programa \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). L'heu de copiar en un fitxer anomenat Exemple_2_01.kt dins d'un paquet anomenat exemples en el projecte del Tema 2: package exemples import java.io.FileInputStream fun main(args: Array<String>){ val f_in = FileInputStream(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } El resultat en Ubuntu ser\u00e0 aquest: H o l a , q u \u00c3 \u00a8 t a l ? Potser en Windows si que apareguen b\u00e9 tots els car\u00e0cters, ja que utilitza per defecte una altra codificaci\u00f3. Per\u00f2 no li donarem ara import\u00e0ncia al fet que no apareguen b\u00e9 els car\u00e0cters especials. Observeu com estem utilitzant un InputStream , concretament un FileInputStream , per a llegir un fitxer de text. A\u00e7\u00f2 no \u00e9s el m\u00e9s apropiat, com ja hav\u00edem comentat abans, sin\u00f3 que haur\u00edem d'utilitzar algun flux orientat a car\u00e0cters, i no orientat a bytes. El programa funcionar\u00e0 si utilitzem codificaci\u00f3 ASCII (o ISO-8859) ja que cada car\u00e0cter es guarda en un byte. Si ens despistem i el fitxer el gaurdem en UTF-8, no eixiran b\u00e9 els car\u00e0cters com \u00e7, \u00f1 o vocals accentuades (que es guarden en 2 bytes). I si el guardem en UTF-16, encara eixir\u00e0 pitjor. Hem utilitzat el constructor que accepta un String com a par\u00e0metre. Queda m\u00e9s curt, per\u00f2 seria totalment equivalent substituir la construcci\u00f3 anterior per aquestes dues l\u00ednies val f = File(\"f1.txt\") val f_in = FileInputStream(f) El read obt\u00e9 un enter, que despr\u00e9s l'intentem convertir en car\u00e0cter. Finalitzem quan l'enter \u00e9s -1. Aquest segon exemple t\u00e9 l'entrada no des d'un fitxer, sin\u00f3 des d'un ByteArrayInputStream . A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu-lo en un fitxer anomenat Exemple_2_02.kt : package exemples import java.io.ByteArrayInputStream fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = ByteArrayInputStream(ent_1.toByteArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Una altra vegada els car\u00e0cters especial eixiran malament, ja que en compte de un InputStream (en aquest cas ByteArrayInputStream ) el m\u00e9s adequat seria un flux orientat a car\u00e0cters, per\u00f2 com a exemple s\u00ed que ens val. Mirem un tercer exemple, per veure el SequenceInputStream , on es poden enganxar de forma sequencial diferents InputStream. Despr\u00e9s d'aquest exemple ja ens centrarem en els fitxers, que \u00e9s el que ens interessa. Copieu-lo en un fitxer anomenat Exemple_2_03.kt : package exemples import java.io.ByteArrayInputStream import java.io.FileInputStream import java.io.SequenceInputStream fun main(args: Array<String>) { val f1 = FileInputStream(\"f1.txt\") val ent_1 = \"Aquest \u00e9s un byte array\" val f2 = ByteArrayInputStream(ent_1.toByteArray()) val f_in = SequenceInputStream(f1,f2) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del InputStream s\u00f3n: int read( buffer : ByteArray) : llig un n\u00famero determinat de bytes de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de bytes llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou bytes, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de bytes que realment s'han llegit com un enter. Si no hi haguera cap byte disponible, es retornar\u00e0 -1. int available() : indica quants bytes hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle (si hi ha 0 bytes disponibles, \u00e9s que ja hem acabat), encara que hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip( despl : Long) : salta, despreciant-los, tant bytes com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de bytes especificat per diferents raons. Torna el n\u00famero de bytes realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . Fa falta que existesca un fitxer anomenat f2.txt en l'arrel del projecte, com es comenta despr\u00e9s. Copieu-lo en un fitxer anomenat Exemple_2_04.kt : package exemples import java.io.FileInputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") var buffer = ByteArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que es guarda en un buffer de bytes (bytes, no car\u00e0cters), haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) convertint cada byte en car\u00e0cter. Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Si per exemple el contingut de f2.txt \u00e9s aquest: Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. Aquesta seria l'eixida: Hola. Aquest \uffc3\uffa9s un text m\uffc3\uffa9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\uffc3\uffa0cters. Com que ho llegim des d'un InputStream, els car\uffc3 \uffa0cters especials potser no isq uen b\uffc3\uffa9. Recordeu que estem llegint un fitxer de text des d'un InputStream, cosa gens convenient ja que els car\u00e0cters com \u00e7, \u00f1, o vocals accentuades dif\u00edcilment podrem fer que apareguen b\u00e9. Ho arreglarem amb els fluxos orientats a car\u00e0cter.","title":"2.1.1 - M\u00e8todes del InputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#212-metodes-del-outputstream","text":"Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un byte (recordeu que estem en fluxos orientats a bytes). void write( byte : Int) : escriu el byte passat com a par\u00e0metre en el flux d'eixida. Encara que el par\u00e0metre \u00e9s de tipus int, nom\u00e9s s'escriur\u00e0 un byte. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en qu\u00e8 guardarem en un fitxer el contingut d'una cadena (encara que ja sabem que no \u00e9s el m\u00e9s apropiat utilitzar fluxos orientats a bytes per a informaci\u00f3 de car\u00e0cters). En aquest primer exemple del OutputStream treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant tancar \u00e9s una operaci\u00f3 ben important que no hem d'oblidar . Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_11.kt : package exemples import java.io.FileOutputStream fun main(args: Array<String>) { val text = \"Contingut per al fitxer.\" val f_out = FileOutputStream(\"f3.txt\") for (c in text) f_out.write(c.toInt()) f_out.close() } Observeu com hem convertit cada car\u00e0cter a Int per a que puga funcionar, ja que el m\u00e8tode write() accepta un enter. En el constructor del OutputStream no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat. Contingut per al fitxer. La codificaci\u00f3 del fitxer haur\u00e0 segut la que tinga per defecte el Sistema Operatiu, que en el cas d'Ubuntu \u00e9s UTF-8, i en el cas de Windows \u00e9s ISO-8859. Anem a provar a substituir el constructor, posant ara val f_out = FileOutputStream(\"f3.txt\",true) Si l'executem una altra vegada, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer.Contingut per al fitxer. Altres m\u00e8todes del OutputStream s\u00f3n: void write( buffer : ByteArray) : escriu el contingut de l'array de bytes al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer : ByteArray, pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants bytes com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els bytes que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. En aquest exemple es copia el contingut del fitxer f2.txt en el fitxer f4.txt , per\u00f2 en compte d'anar byte a byte, anirem de 30 en 30, amb un buffer de 30 posicions. Podr\u00edem cometre l'error de la l\u00ednia 13 del seg\u00fcent programa, la del comentari, d'escriure sempre els 30 car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_12.kt : package exemples import java.io.FileInputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") val f_out = FileOutputStream(\"f4.txt\") var buffer = ByteArray(30) var num = f_in.read(buffer) while (num != -1) { f_out.write(buffer) // a\u00e7\u00f2 \u00e9s un error num = f_in.read(buffer) } f_in.close(); f_out.close(); } D'aquesta manera, l'\u00faltima vegada que \u00e9s llig \u00e9s molt possible que no hi hagen exactament 30 car\u00e0cters. Si hi ha menys de 30 car\u00e0cters, nom\u00e9s es llegiran els que queden al principi del buffer, i en la resta del buffer hi ha la informaci\u00f3 anterior, la de la pen\u00faltima lectura. En definitiva, tenim \"basura\", i si no ho controlem el resultat no ser\u00e0 el correcte. Aquest ser`el contingut de f4.txt : Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. pecials potser no isq Ha eixit d'aquesta manera perqu\u00e8 l'\u00faltima vegada nom\u00e9s s'han llegit 9 bytes. Els 21 restants tenen la informaci\u00f3 encara de la pen\u00faltima lectura. Per a fer-lo de forma correcta, ens aprofitem de que read(buffer) torna el n\u00famero de bytes realment llegits, per escriure exactament aquest n\u00famero. Per tant substituirem la l\u00ednia 13, la del comentari, per aquesta altra: f_out.write(buffer,0,num) // ara s\u00ed que funcionar\u00e0 b\u00e9 Ara el contingut de f4.txt ser\u00e0 id\u00e8ntic al de f2.txt Nota important Per a assegurar-nos que realment escrivim en el fitxer i no es queda res en la mem\u00f2ria interm\u00e8dia, hem de tancar sempre els fluxos d'eixida . Si ens oblidem de tancar-los, \u00e9s molt f\u00e0cil que no s'acabe d'escriure f\u00edsicament en el fitxer.","title":"2.1.2 - M\u00e8todes del OutputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#22-fluxos-orientats-a-caracters-classes","text":"Treballar amb car\u00e0cters implica una dificultat apreciable, a causa sobretot de la diversitat de codificacions existents. Per poder solucionar-ho, Java disposa de dues jerarquies, una d'entrada i una d'eixida, diferents de les que ja hem vist per a bytes (que eren InputStream i OutputStream). Aquestes jerarquies per a car\u00e0cters seran molt semblants a les de bytes, per\u00f2 sempre orientades a car\u00e0cters. Kotlin, per heretar de Java, tamb\u00e9 les tindr\u00e0, encara que com veurem en l'\u00faltima pregunta, podrem simplificar les coses. Igual que en els casos anteriors, tindrem unes classes abstractes, Reader i Writer , que no es poden instanciar directament (no podrem crear un objecte d'aquestes classes). Serviran per a homogene\u00eftzar tots els fluxos d'entrada i d'exida orientats a car\u00e0cter. La super-classe Reader servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de car\u00e0cters, una canonada (\"tuberia\", per a dur dades des d'una altra aplicaci\u00f3). Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileReader ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten d'ella i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileReader Per a llegir car\u00e0cters d'un fitxer PipedReader Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) CharArrayReader L'entrada ser\u00e0 un array de car\u00e0cters StringReader L'entrada ser\u00e0 un string Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades. Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de Writer : Classe Explicaci\u00f3 FileWriter Per a guardar car\u00e0cters en un fitxer Piped Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) CharArrayWriter L'eixida ser\u00e0 un array de car\u00e0cters StringWriter L'eixida ser\u00e0 un string Hem de fer constar que les classes d\u2019emmagatzematge intern (utilitzem Java o Kotlin), com ara CharArrayReader , CharArrayWriter , StringReader , StringWriter , PipedReader , PipedWriter utilitzen sempre la codificaci\u00f3 pr\u00f2pia de Java (unicode de 16 bits: UTF-16 ), ja que guarden les dades a la mem\u00f2ria basant-se en els tipus dades de tractament de car\u00e0cters de Java o Kotlin (C har i String ). En canvi les classes FileReader o FileWriter agafen la codificaci\u00f3 per defecte del sistema operatiu amfitri\u00f3 . L\u2019usuari no pot seleccionar diferents sistemes de codificaci\u00f3 en crear les inst\u00e0ncies. Aix\u00ed, una m\u00e0quina virtual Java sobre Windows utilitzar\u00e0, per defecte, la codificaci\u00f3 ISO-8859-1, per\u00f2 si corre sobre Linux, la codificaci\u00f3 ser\u00e0 UTF-8. De tota manera veurem que s\u00ed que podrem arribar a especificar quin \u00e9s el joc de car\u00e0cters que volem utilitzar en la pregunta 3.3. Intentarem veure exemples de tot. Constructors de FileReader De forma totalment paral\u00b7lela als fluxos orientats a byte, el FileReader t\u00e9 dos constructors, acceptant com a par\u00e0metre un File o un String (amb el nom del fitxer). La difer\u00e8ncia ara \u00e9s que la unitat de transfer\u00e8ncia ser\u00e0 el car\u00e0cter (en compte d'un byte): FileReader ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileReader ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileWriter Tamb\u00e9 totalment paral\u00b7lel al FileOutputStream. Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileWriter ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileWriter ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. File Writer (f: File , afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true en compte de substituir el que ja hi havia, la informaci\u00f3 s'afegir\u00e0 al final. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). File Writer (nom_f: String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer.","title":"2.2 - Fluxos orientats a car\u00e0cters - Classes"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#221-metodes-del-reader","text":"Els m\u00e8todes del Reader s\u00f3n absolutament similars als del InputStream . La difer\u00e8ncia \u00e9s que ara llegir\u00e0 sempre un car\u00e0cter. I no ens haurem de preocupar pel format en qu\u00e8 est\u00e0 guardat, i de i ocupa un o dos bytes. Sempre el llegir\u00e0 b\u00e9, siga quina siga la codificaci\u00f3 utilitzada, com ja hav\u00edem comentat abans: int read() : llig el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com un enter. Si no hi ha cap car\u00e0cter disponible perqu\u00e8 s\u2019ha assolit el final de la seq\u00fc\u00e8ncia, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent car\u00e0cter per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre car\u00e0cter, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de car\u00e0cters, ...). Abans de veure altres m\u00e8todes, mirem un exemple que \u00e9s id\u00e8ntic al primer exemple del InputStream, per\u00f2 canviant FileInputStream per FileReader. Llegir\u00e0 el mateix fitxer anomenat f1.txt , utilitzat en aquell moment, per\u00f2 ara segurament llegir\u00e0 tots els car\u00e0cters b\u00e9. El que far\u00e0 \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_21.kt : package exemples import java.io.FileReader fun main(args: Array<String>){ val f_in = FileReader(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } Ara segurament s\u00ed que haur\u00e0 llegit b\u00e9 tots els car\u00e0cters, incloent \u00f1, \u00e7, vocals accentuades, etc. Si encara tenim el mateix contingut en f1.txt , el resultat ser\u00e0 ara: H o l a , q u \u00e8 t a l ? El m\u00e9s normal \u00e9s que en crear el fitxer f1.txt amb algun editor, el guardem amb la codificaci\u00f3 per defecte, que en cas de Windows \u00e9s ASCII (o ISO-8859) i en el cas de Linux \u00e9s UTF-8. I despr\u00e9s des de Java, el FileReader utilitzar\u00e0 la codificaci\u00f3 per defecte del Sistema Operatiu. \u00c9s a dir que en Linux el fitxer ha d'estar guardat en UTF-8 per a que el puga llegir b\u00e9, i en Windows en ASCII. Mirem tamb\u00e9 l'exemple equivalent al segon. All\u00e0 utilitz\u00e0vem un ByteArrayInputStream com a entrada. Ara podr\u00edem utilitzar un CharArrayReader , per\u00f2 ho farem amb un StringReader , i quedar\u00e0 m\u00e9s curt. A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_22.kt : package exemples import java.io.CharArrayReader fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = CharArrayReader(ent_1.toCharArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del Reader s\u00f3n: int read(char[ ] buffer ) : llig un n\u00famero determinat de car\u00e0cters de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de car\u00e0cters llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou car\u00e0cters, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de car\u00e0cters que realment s'han llegit com un enter. Si no hi haguera cap car\u00e0cter disponible, es retornaria -1. int available() : indica quants car\u00e0cters hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle: si hi ha 0 car\u00e0cters disponibles, \u00e9s que ja hem acabat. Tot i aix\u00f2, hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip(long despl ) : salta, despreciant-los, tants car\u00e0cters com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de car\u00e0cters especificat per diferents raons. Torna el n\u00famero de car\u00e0cters realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . \u00c9s id\u00e8ntic al de l'apartat del InputStream. La difer\u00e8ncia \u00e9s que ara s'haurien de llegir b\u00e9 tots els car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_23.kt : package exemples import java.io.FileReader fun main(args: Array<String>) { val f_in = FileReader(\"f2.txt\") var buffer = CharArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que ara es guarda en un buffer de car\u00e0cters, haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) . Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Aquesta seria l'eixida: Hola. Aquest \u00e9s un text m\u00e9s ll arg, per veure com gestiona el s bytes amb un buffer de 30 ca r\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cte rs especials potser no isquen b\u00e9. Efectivament, s'han llegit tots els car\u00e0cters perfectament.","title":"2.2.1 - M\u00e8todes del Reader"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#222-metodes-del-writer","text":"Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un car\u00e0cter. void write( car : Int) : escriu el car\u00e0cter passat com a par\u00e0metre en el flux d'eixida. En cas que siga un FileWriter, escriur\u00e0 el car\u00e0cter amb la codificaci\u00f3 per defecte del S.O. : en Windows ISO-8839 i en Linux UTF-8. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en el qual guardarem en un fitxer el contingut d'una cadena, ara ja sense por als car\u00e0cters estranys. En aquest primer exemple del Writer treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_31.kt : Nota Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant \u00e9s una operaci\u00f3 ben important que no hem d'oblidar. package exemples import java.io.FileWriter fun main(args: Array<String>) { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" val f_out = FileWriter (\"f5.txt\") for (c in text) { f_out.write(c.toInt()) } f_out.close() } En el constructor del Writer no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat en f5.txt Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Anem a provar a substituir el constructor, posant ara val f_out = FileWriter (\"f5.txt\", true) Si l'executem, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Altres m\u00e8todes del Writer s\u00f3n: void write( buffer : CharArray) : escriu el contingut de l'array de car\u00e0cters al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer: CharArray , pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants car\u00e0cters com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els car\u00e0cters que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. Aquestos m\u00e8todes s\u00f3n totalment similars als del OutputStream. A banda d'aquestos, el Writer t\u00e9 un altre, que pot ser especialment \u00fatil per a car\u00e0cters: void write( text : String) : escriu tot el contingut del String en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2.2 - M\u00e8todes del Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/","text":"3 - Fluxos decoradors Anomenem classes \" decoradores \" a aquelles que hereten d'una classe determinada i serveixen per a dotar d'una funcionalitat extra que no tenia la classe original. En els fluxos, en els d'entrada i en els d'eixida, veurem uns quants \"decoradors\" que ens permetran una funcionalitat extra: llegir o escriure una l\u00ednia sencera (en compte de byte a byte, o car\u00e0cter a car\u00e0cter), o guardar amb determinat format de dades, ... En el cas de car\u00e0cters tamb\u00e9 ens permetran triar la codificaci\u00f3 (ISO-8859-1, UTF-8, UTF-16, ...). Anirem veient-los poc a poc, classificats per la classe arrel, \u00e9s a dir, per una banda els decoradors del InputStream i OutputStream (orientats a byte), i per una altra banda els de Reader i Writer (orientats a car\u00e0cter) 3.1 - Decoradors de InputStream i OtputStream Com hem comentat ens serviran per a donar una funcionalitat extra. S\u00f3n els que estan de verd en la seg\u00fcent imatge: Fixem-nos primers en els decoradors de InputStream : Classe Explicaci\u00f3 FilterInputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) LineNumberInputStream Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del InputStream (no la veurem) DataInputStream Permet llegir dades de qualsevol tipus de dades: enter, real, boole\u00e0, ... BufferedInputStream Munta un buffer d'entrada (no la veurem) PushBackInputStream Permet retrocedir un byte en la lectura, i per tant permet anar cap arrere (no la veurem) ObjectInputStream Permet llegir tot un objecte I de forma quasi paral\u00b7lela tenim els decoradors de OutputStream : Classe Explicaci\u00f3 FilterOutputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Data Out putStream Permet guardar al flux de dades d'eixida dades de qualsevol tipus: enter, real, boole\u00e0, ... Buffered Out putStream Munta un buffer d'eixida (no la veurem) PrintStream Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println Object Out putStream Permet escriure (serialitzar) tot un objecte Comentem-los un poquet m\u00e9s. BufferedInputStream i BufferedOutputStream ens ofereixen un buffer d'entrada i d'eixida respectivament, per a fer la transfer\u00e8ncia m\u00e9s efectiva. En la pr\u00e0ctica ens oferir\u00e0 poques funcionalitats \u00fatils (a banda de l'efici\u00e8ncia en la transfer\u00e8ncia, clar). Quan anem als decoradors de fluxos orientats a car\u00e0cters, s\u00ed que trobarem utilitats als decoradors semblants a aquestos, com per exemple llegir o escriure una l\u00ednia sencera de car\u00e0cters. Per\u00f2 aquestos orientats a bytes, no els veurem. DataInputStream i DataOutputStream ens oferiran la possibilitat de llegir o escriure c\u00f2modament dades de diferents tipus: enter, real, boole\u00e0, strings, ... Els veurem en detall en el proper Tema 3 ObjectInputStream i ObjectOutputStream (que curiosament s\u00f3n els \u00fanics que no depenen de FilterInputStream i FilterOutputStream ) ens permetran guardar o recuperar de cop tot un objecte, \u00e9s a dir totes les seues propietats (les dades de l'objecte). No ens haurem de preocupar ni de l'ordre ni del tipus de les propietats de l'objecte: quan escrivim l'objecte, es guardaran totes les dades de forma compacta; i quan llegim es recuperaran de forma correcta. \u00c9s per tant una parella de classes d'extrema utilitat per a guardar objectes, que en definitiva s\u00f3n l'ess\u00e8ncia de la programaci\u00f3 en Java. Els veurem en detall en el proper Tema 3 . PrintStream L'\u00fanic que ens queda \u00e9s el que veurem ara amb un poquet m\u00e9s de detall, el PrintStream . Ens permetr\u00e0 b\u00e0sicament 3 coses: Escriure dades de m\u00e9s d'un tipus de dades. Per exemple print(5.25) escriu un n\u00famero real, i print(\"Hola\") escriu tot un string. Donar un determinat format a l'eixida, amb tota la funcionalitat a qu\u00e8 estem acostumats amb printf Escriure tota una l\u00ednia amb println , \u00e9s a dir, acabar una dada amb el retorn de carro, per a baixar de l\u00ednia. Mirem un exemple que ens pot donar idea de la seua funcionalitat. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_41.kt : package exemples import java.io.PrintStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_out = PrintStream(FileOutputStream (\"f6.txt\")) val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Es crear\u00e0 el fitxer f6.txt (si ja existia esborrar\u00e0 el contingut anterior) amb el seg\u00fcent contingut: Hola.Qu\u00e8 tal? 8.25 El n\u00famero 27 en hexadecimal \u00e9s 1b En realitat el PrintStream , a banda del constructor que accepta un OutputStream , tamb\u00e9 t\u00e9 un altre que accepta un File i fins i tot un altre que accepta un String amb el nom del fitxer. Per tant, la seg\u00fcent sent\u00e8ncia tamb\u00e9 ens funcionaria: val f_out = PrintStream(\"f6.txt\") 3.2 - Decoradors de Reader i Writer Mirem ara els decoradors de la jerarquia Reader i Writer . Tornen a ser els de color verd. Els de color gris InputStreamReader i OutputStreamWriter s\u00f3n conversors que permeten passar un InputStream a un Reader i un OutputStream a Writer . Els veurem en la seg\u00fcent pregunta. Fixem-nos primers en els decoradors de Reader : Classe Explicaci\u00f3 FilterReader No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) PushBackInputStream Permet retrocedir un car\u00e0cter en la lectura, i per tant permet anar cap arrere (no la veurem) Buffered Reader**** Munta un buffer d'entrada, i permet entre altres coses llegir una l\u00ednia sencera LineNumber Reader**** Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del fitxer (no la veurem) I de forma quasi paral\u00b7lela tenim els decoradors de Writer : Classe Explicaci\u00f3 FilterWriter No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Buffered Writer**** Munta un buffer d'eixida, i permet entre altres coses escriure una l\u00ednia sencera Print Writer**** Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println El PrintWriter funciona quasi exactament igual que el PrintStream , i per a car\u00e0cters \u00e9s m\u00e9s \u00fatil que l'altre (per ser Writer ), per tant \u00e9s el candidat a recordar. El BufferedReader s\u00ed que ens oferir\u00e0 facilitats interessants, com llegir una l\u00ednia sencera. En canvi el BufferedWriter no ens ofereix tantes facilitats com el PrintWriter , \u00e9s un poc m\u00e9s inc\u00f2mode. BufferedReader i BufferedWriter. PrintWriter BufferedReader i BufferedWriter munten un buffer (d'entrada i d'eixida respectivament) de car\u00e0cters per a fer m\u00e9s eficient la transfer\u00e8ncia. A banda d'aix\u00f2 tindran uns m\u00e8todes que ens seran molt \u00fatils. BufferedReader m\u00e8tode readLine() que ens permet llegir una l\u00ednia sencera del fitxer (fins al final de l\u00ednia). A\u00e7\u00f2 \u00e9s de molta utilitat en els fitxers de text. BufferedWriter m\u00e8tode newLine() que permet introduir el car\u00e0cter de baixada de l\u00ednia m\u00e8tode write( cad : String, com : Int, llarg : Int) que permet escriure tot un string, o una part d'ell, especificant on comen\u00e7a el que volem escriure i la llarg\u00e0ria Com veieu el BufferedReader s\u00ed que ens ofereix la possibilitat de llegir una l\u00ednia sencera, per\u00f2 en canvi el BufferedWriter es queda un poc curt. Per aix\u00f2 preferirem el PrintWriter . PrintWriter m\u00e8todes print( qualsevol_tipu s ) , que permeten imprimir una dada de qualsevol tipus: boole\u00e0, char, tots els num\u00e8rics, string, ... Ser\u00e0 segurament el que m\u00e9s utilitzarem. m\u00e8todes println ( qualsevol_tipu s ) * , a banda de tot el de *print , baixen de l\u00ednia m\u00e8tode printf() , que permet donar un format Veiem un senzill exemple per a copiar el contingut d'un fitxer de text i modificar-lo lleugerament. El m\u00e9s c\u00f2mode ser\u00e0 anar l\u00ednia a l\u00ednia. Per tant utilitzarem el BufferedReader per a llegir l\u00ednies, i el PrintWriter per a escriure l\u00ednies. La lleugera modificaci\u00f3 consistir\u00e0 en posar el n\u00famero de l\u00ednia davant. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_51.kt : package exemples import java.io.BufferedReader import java.io.FileReader import java.io.PrintWriter import java.io.FileWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f7_ent.txt\")) val f_eix = PrintWriter(FileWriter (\"f7_eix.txt\")) var cad = f_ent.readLine(); var i = 0 while (cad != null) { i++ f_eix.println(\"\" + i + \".- \" + cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Si en el fitxer d'entrada ( f7_ent.txt ) tenim guardada la seg\u00fcent informaci\u00f3 (introdu\u00efda amb el notepad o gedit): Primera Segona Tercera En el fitxer d'eixida ( f7_eix.txt ) tindrem: 1.- Primera 2.- Segona 3.- Tercera 3.3 - Conversors: InputStreamReader i OutputStreamWriter Una vegada vistes les jerarquies de les classes InputStream-OutputStream per una banda, i Reader-Writer per una altra, veurem ara unes classes que serviran per a passar d'una jeraquia a una altra. \u00c9s a dir, poder passar un InputStream a Reader , o el que \u00e9s el mateix, un flux orientat a bytes en un flux orientat a car\u00e0cters. I el mateix amb el OutputStream i el Writer. InputStreamReader : passa un InputStream a Reader . Accepta com a par\u00e0metre el InputStream i d\u00f3na com a resultat un Reader . OutputStreamWriter : passa un OutputStream a Writer . Accepta com a par\u00e0metre el OutputStream i d\u00f3na com a resultat un Writer . A m\u00e9s en el constructor dels dos, InputStreamReader i OutputStreamWriter , tenim la possibilitat d'especificar el tipus de codificaci\u00f3, a m\u00e9s del InputStream o OutputStream. A\u00e7\u00f2 ens ser\u00e0 molt \u00fatil, perqu\u00e8 fins el moment no pod\u00edem triar el tipus de codificaci\u00f3 d'un FileReader o FileWriter que era UTF-8 en el cas de Linux, i ASCII (millor dit la seua extensi\u00f3 ISO-8859-1) en el cas de Windows. Mirem aquest exemple, en el qual transformem el mateix fitxer d'una configuraci\u00f3 a una altra. Aprofitem algun dels fitxers que ja disposem (per exemple f5.txt, que tenia car\u00e0cters especials com vocals accentuades). En l'exemple el tindrem en codificaci\u00f3 UTF-8, ja que est\u00e0 provat en Linux. El transformarem a ISO-8859-1. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_61.kt : package exemples import java.io.InputStreamReader import java.io.FileInputStream import java.io.OutputStreamWriter import java.io.FileOutputStream fun main(args: Array<String>) { val f_ent = InputStreamReader(FileInputStream(\"f5.txt\"), \"UTF-8\") val f_eix = OutputStreamWriter(FileOutputStream(\"f5_ISO.txt\"), \"ISO-8859-1\") var car = f_ent.read() while (car != -1) { f_eix.write(car) car = f_ent.read() } f_eix.close() f_ent.close() } Hem posat l'entrada expl\u00edcitament que siga de UTF-8. En realitat no faria falta, ja que si treballem en Linux, aquesta ser\u00e0 la codificaci\u00f3 per defecte, i per tant seria la que utilitzaria un FileReader. FileReader f_ent = new FileReader(\"f5.txt\") Anem a fer una altra versi\u00f3 del mateix programa. A banda de no especificar la codificaci\u00f3 del fitxer d'entrada, utilitzarem els decoradors BufferedReader i PrintWriter per a poder anar c\u00f2modament l\u00ednia a l\u00ednia. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_62.kt : package exemples import java.io.FileReader import java.io.BufferedReader import java.io.FileOutputStream import java.io.OutputStreamWriter import java.io.PrintWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f5.txt\")) val f_eix = PrintWriter(OutputStreamWriter(FileOutputStream (\"f5_ISO.txt\"), \"ISO-8859-1\")) var cad = f_ent.readLine() while (cad != null) { f_eix.println(cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3 - Fluxos decoradors"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/#3-fluxos-decoradors","text":"Anomenem classes \" decoradores \" a aquelles que hereten d'una classe determinada i serveixen per a dotar d'una funcionalitat extra que no tenia la classe original. En els fluxos, en els d'entrada i en els d'eixida, veurem uns quants \"decoradors\" que ens permetran una funcionalitat extra: llegir o escriure una l\u00ednia sencera (en compte de byte a byte, o car\u00e0cter a car\u00e0cter), o guardar amb determinat format de dades, ... En el cas de car\u00e0cters tamb\u00e9 ens permetran triar la codificaci\u00f3 (ISO-8859-1, UTF-8, UTF-16, ...). Anirem veient-los poc a poc, classificats per la classe arrel, \u00e9s a dir, per una banda els decoradors del InputStream i OutputStream (orientats a byte), i per una altra banda els de Reader i Writer (orientats a car\u00e0cter)","title":"3 - Fluxos decoradors"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/#31-decoradors-de-inputstream-i-otputstream","text":"Com hem comentat ens serviran per a donar una funcionalitat extra. S\u00f3n els que estan de verd en la seg\u00fcent imatge: Fixem-nos primers en els decoradors de InputStream : Classe Explicaci\u00f3 FilterInputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) LineNumberInputStream Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del InputStream (no la veurem) DataInputStream Permet llegir dades de qualsevol tipus de dades: enter, real, boole\u00e0, ... BufferedInputStream Munta un buffer d'entrada (no la veurem) PushBackInputStream Permet retrocedir un byte en la lectura, i per tant permet anar cap arrere (no la veurem) ObjectInputStream Permet llegir tot un objecte I de forma quasi paral\u00b7lela tenim els decoradors de OutputStream : Classe Explicaci\u00f3 FilterOutputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Data Out putStream Permet guardar al flux de dades d'eixida dades de qualsevol tipus: enter, real, boole\u00e0, ... Buffered Out putStream Munta un buffer d'eixida (no la veurem) PrintStream Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println Object Out putStream Permet escriure (serialitzar) tot un objecte Comentem-los un poquet m\u00e9s. BufferedInputStream i BufferedOutputStream ens ofereixen un buffer d'entrada i d'eixida respectivament, per a fer la transfer\u00e8ncia m\u00e9s efectiva. En la pr\u00e0ctica ens oferir\u00e0 poques funcionalitats \u00fatils (a banda de l'efici\u00e8ncia en la transfer\u00e8ncia, clar). Quan anem als decoradors de fluxos orientats a car\u00e0cters, s\u00ed que trobarem utilitats als decoradors semblants a aquestos, com per exemple llegir o escriure una l\u00ednia sencera de car\u00e0cters. Per\u00f2 aquestos orientats a bytes, no els veurem. DataInputStream i DataOutputStream ens oferiran la possibilitat de llegir o escriure c\u00f2modament dades de diferents tipus: enter, real, boole\u00e0, strings, ... Els veurem en detall en el proper Tema 3 ObjectInputStream i ObjectOutputStream (que curiosament s\u00f3n els \u00fanics que no depenen de FilterInputStream i FilterOutputStream ) ens permetran guardar o recuperar de cop tot un objecte, \u00e9s a dir totes les seues propietats (les dades de l'objecte). No ens haurem de preocupar ni de l'ordre ni del tipus de les propietats de l'objecte: quan escrivim l'objecte, es guardaran totes les dades de forma compacta; i quan llegim es recuperaran de forma correcta. \u00c9s per tant una parella de classes d'extrema utilitat per a guardar objectes, que en definitiva s\u00f3n l'ess\u00e8ncia de la programaci\u00f3 en Java. Els veurem en detall en el proper Tema 3 . PrintStream L'\u00fanic que ens queda \u00e9s el que veurem ara amb un poquet m\u00e9s de detall, el PrintStream . Ens permetr\u00e0 b\u00e0sicament 3 coses: Escriure dades de m\u00e9s d'un tipus de dades. Per exemple print(5.25) escriu un n\u00famero real, i print(\"Hola\") escriu tot un string. Donar un determinat format a l'eixida, amb tota la funcionalitat a qu\u00e8 estem acostumats amb printf Escriure tota una l\u00ednia amb println , \u00e9s a dir, acabar una dada amb el retorn de carro, per a baixar de l\u00ednia. Mirem un exemple que ens pot donar idea de la seua funcionalitat. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_41.kt : package exemples import java.io.PrintStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_out = PrintStream(FileOutputStream (\"f6.txt\")) val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Es crear\u00e0 el fitxer f6.txt (si ja existia esborrar\u00e0 el contingut anterior) amb el seg\u00fcent contingut: Hola.Qu\u00e8 tal? 8.25 El n\u00famero 27 en hexadecimal \u00e9s 1b En realitat el PrintStream , a banda del constructor que accepta un OutputStream , tamb\u00e9 t\u00e9 un altre que accepta un File i fins i tot un altre que accepta un String amb el nom del fitxer. Per tant, la seg\u00fcent sent\u00e8ncia tamb\u00e9 ens funcionaria: val f_out = PrintStream(\"f6.txt\")","title":"3.1 - Decoradors de InputStream i OtputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/#32-decoradors-de-reader-i-writer","text":"Mirem ara els decoradors de la jerarquia Reader i Writer . Tornen a ser els de color verd. Els de color gris InputStreamReader i OutputStreamWriter s\u00f3n conversors que permeten passar un InputStream a un Reader i un OutputStream a Writer . Els veurem en la seg\u00fcent pregunta. Fixem-nos primers en els decoradors de Reader : Classe Explicaci\u00f3 FilterReader No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) PushBackInputStream Permet retrocedir un car\u00e0cter en la lectura, i per tant permet anar cap arrere (no la veurem) Buffered Reader**** Munta un buffer d'entrada, i permet entre altres coses llegir una l\u00ednia sencera LineNumber Reader**** Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del fitxer (no la veurem) I de forma quasi paral\u00b7lela tenim els decoradors de Writer : Classe Explicaci\u00f3 FilterWriter No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Buffered Writer**** Munta un buffer d'eixida, i permet entre altres coses escriure una l\u00ednia sencera Print Writer**** Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println El PrintWriter funciona quasi exactament igual que el PrintStream , i per a car\u00e0cters \u00e9s m\u00e9s \u00fatil que l'altre (per ser Writer ), per tant \u00e9s el candidat a recordar. El BufferedReader s\u00ed que ens oferir\u00e0 facilitats interessants, com llegir una l\u00ednia sencera. En canvi el BufferedWriter no ens ofereix tantes facilitats com el PrintWriter , \u00e9s un poc m\u00e9s inc\u00f2mode. BufferedReader i BufferedWriter. PrintWriter BufferedReader i BufferedWriter munten un buffer (d'entrada i d'eixida respectivament) de car\u00e0cters per a fer m\u00e9s eficient la transfer\u00e8ncia. A banda d'aix\u00f2 tindran uns m\u00e8todes que ens seran molt \u00fatils. BufferedReader m\u00e8tode readLine() que ens permet llegir una l\u00ednia sencera del fitxer (fins al final de l\u00ednia). A\u00e7\u00f2 \u00e9s de molta utilitat en els fitxers de text. BufferedWriter m\u00e8tode newLine() que permet introduir el car\u00e0cter de baixada de l\u00ednia m\u00e8tode write( cad : String, com : Int, llarg : Int) que permet escriure tot un string, o una part d'ell, especificant on comen\u00e7a el que volem escriure i la llarg\u00e0ria Com veieu el BufferedReader s\u00ed que ens ofereix la possibilitat de llegir una l\u00ednia sencera, per\u00f2 en canvi el BufferedWriter es queda un poc curt. Per aix\u00f2 preferirem el PrintWriter . PrintWriter m\u00e8todes print( qualsevol_tipu s ) , que permeten imprimir una dada de qualsevol tipus: boole\u00e0, char, tots els num\u00e8rics, string, ... Ser\u00e0 segurament el que m\u00e9s utilitzarem. m\u00e8todes println ( qualsevol_tipu s ) * , a banda de tot el de *print , baixen de l\u00ednia m\u00e8tode printf() , que permet donar un format Veiem un senzill exemple per a copiar el contingut d'un fitxer de text i modificar-lo lleugerament. El m\u00e9s c\u00f2mode ser\u00e0 anar l\u00ednia a l\u00ednia. Per tant utilitzarem el BufferedReader per a llegir l\u00ednies, i el PrintWriter per a escriure l\u00ednies. La lleugera modificaci\u00f3 consistir\u00e0 en posar el n\u00famero de l\u00ednia davant. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_51.kt : package exemples import java.io.BufferedReader import java.io.FileReader import java.io.PrintWriter import java.io.FileWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f7_ent.txt\")) val f_eix = PrintWriter(FileWriter (\"f7_eix.txt\")) var cad = f_ent.readLine(); var i = 0 while (cad != null) { i++ f_eix.println(\"\" + i + \".- \" + cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Si en el fitxer d'entrada ( f7_ent.txt ) tenim guardada la seg\u00fcent informaci\u00f3 (introdu\u00efda amb el notepad o gedit): Primera Segona Tercera En el fitxer d'eixida ( f7_eix.txt ) tindrem: 1.- Primera 2.- Segona 3.- Tercera","title":"3.2 - Decoradors de Reader i Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/#33-conversors-inputstreamreader-i-outputstreamwriter","text":"Una vegada vistes les jerarquies de les classes InputStream-OutputStream per una banda, i Reader-Writer per una altra, veurem ara unes classes que serviran per a passar d'una jeraquia a una altra. \u00c9s a dir, poder passar un InputStream a Reader , o el que \u00e9s el mateix, un flux orientat a bytes en un flux orientat a car\u00e0cters. I el mateix amb el OutputStream i el Writer. InputStreamReader : passa un InputStream a Reader . Accepta com a par\u00e0metre el InputStream i d\u00f3na com a resultat un Reader . OutputStreamWriter : passa un OutputStream a Writer . Accepta com a par\u00e0metre el OutputStream i d\u00f3na com a resultat un Writer . A m\u00e9s en el constructor dels dos, InputStreamReader i OutputStreamWriter , tenim la possibilitat d'especificar el tipus de codificaci\u00f3, a m\u00e9s del InputStream o OutputStream. A\u00e7\u00f2 ens ser\u00e0 molt \u00fatil, perqu\u00e8 fins el moment no pod\u00edem triar el tipus de codificaci\u00f3 d'un FileReader o FileWriter que era UTF-8 en el cas de Linux, i ASCII (millor dit la seua extensi\u00f3 ISO-8859-1) en el cas de Windows. Mirem aquest exemple, en el qual transformem el mateix fitxer d'una configuraci\u00f3 a una altra. Aprofitem algun dels fitxers que ja disposem (per exemple f5.txt, que tenia car\u00e0cters especials com vocals accentuades). En l'exemple el tindrem en codificaci\u00f3 UTF-8, ja que est\u00e0 provat en Linux. El transformarem a ISO-8859-1. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_61.kt : package exemples import java.io.InputStreamReader import java.io.FileInputStream import java.io.OutputStreamWriter import java.io.FileOutputStream fun main(args: Array<String>) { val f_ent = InputStreamReader(FileInputStream(\"f5.txt\"), \"UTF-8\") val f_eix = OutputStreamWriter(FileOutputStream(\"f5_ISO.txt\"), \"ISO-8859-1\") var car = f_ent.read() while (car != -1) { f_eix.write(car) car = f_ent.read() } f_eix.close() f_ent.close() } Hem posat l'entrada expl\u00edcitament que siga de UTF-8. En realitat no faria falta, ja que si treballem en Linux, aquesta ser\u00e0 la codificaci\u00f3 per defecte, i per tant seria la que utilitzaria un FileReader. FileReader f_ent = new FileReader(\"f5.txt\") Anem a fer una altra versi\u00f3 del mateix programa. A banda de no especificar la codificaci\u00f3 del fitxer d'entrada, utilitzarem els decoradors BufferedReader i PrintWriter per a poder anar c\u00f2modament l\u00ednia a l\u00ednia. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_62.kt : package exemples import java.io.FileReader import java.io.BufferedReader import java.io.FileOutputStream import java.io.OutputStreamWriter import java.io.PrintWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f5.txt\")) val f_eix = PrintWriter(OutputStreamWriter(FileOutputStream (\"f5_ISO.txt\"), \"ISO-8859-1\")) var cad = f_ent.readLine() while (cad != null) { f_eix.println(cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.3 - Conversors: InputStreamReader i OutputStreamWriter"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/4__simplificaci_en_kotlin/","text":"4 - Simplificaci\u00f3 en Kotlin Tots els programes anteriors funcionen en Kotlin perfectament, perqu\u00e8 estem utilitzant les classes de Java, i aquestes sense problemes funcionen en Kotlin, \u00e9s una de les seues caracter\u00edstiques. Tanmateix, Kotlin proporcionar\u00e0 funcionalitat extra en les classes, que ens permetr\u00e0 simplificar prou els programes. S\u00f3n molts els m\u00e8todes nous que ens proporcionar\u00e0. Ac\u00ed tenim uns quants agrupats per tem\u00e0tica. M\u00e8todes sobre bytes readBytes() : torna un ByteArray amb tots els bytes del fitxer, \u00e9s a dir, tot el seu contingut en forma de bytes writeBytes( array : ByteArray) : escriu en el fitxer el contingut del ByteArray. Si el fitxer ja existia, el sobreescriura. appendBytes ( array : ByteArray) : afegeix al final del fitxer els bytes del ByteArray. Tornem a fer el primer exemple, Exemple_2_01.kt, utilitzant aquesta funcionalitat extra. Copieu el seg\u00fcent com Exemple_2_01_bis.kt : package exemples import java.io.File fun main(){ val f = File(\"f1.txt\") val tot = f.readBytes() for (c in tot){ println(c.toChar()) } } I com a exemple d'escriptura, podem fer Exemple_2_11.kt,on ho podem fer tot en una l\u00ednia. Copieu el seg\u00fcent com Exemple_2_11_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer.\" File(\"f3.txt\").writeBytes(text.toByteArray()) } Recordeu que en els dos exemples anteriors per comoditat estem utilitzant car\u00e0cters com a dades, i no seria el m\u00e9s correcte utilitzar bytes ni de lectura ni d'escriptura. Ho hem fet \u00fanicament per comoditat. M\u00e8todes sobre car\u00e0cters readText( charset : CharSet) : torna un String amb la tots els car\u00e0cters del fitxer. Opcionalment li podem dir el joc de car\u00e0cters (si no li ho diem utilitzar\u00e0 UTF-8) readLines( charset : CharSet) : torna un List de Strings amb totes les l\u00ednies del fitxer writeText( text : String, charset : CharSet) : escriu el string en el fitxer. Si el fitxer ja existia el sobreescriur\u00e0. Opcionalment podem posar el joc de car\u00e0cters que volem utilitzar. Si no el posem utilitzar\u00e0 UTF-8. Observeu que ja dispos\u00e0vem d'un m\u00e8tode que escrivia tot un String anteriorment, per tant no \u00e9s una gran millora, excepte pel fet de poder especificar el joc de car\u00e0cters. A\u00e7\u00f2 s\u00ed que \u00e9s de gran comoditat. appendText( text : String, charset : CharSet) : el mateix que l'anterior, per\u00f2 afegint al final. Com a exemple anem a veure Exemple_2_21.kt. Copieu el seg\u00fcent com Exemple_2_21_bis.kt : package exemples import java.io.File fun main(){ val tot = File(\"f1.txt\").readText() for(c in tot){ println(c) } } I com a exemple d'escriptura, l'adaptaci\u00f3 de Exemple_2_31.kt. Copieu el seg\u00fcent com Exemple_2_31_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" File(\"f5.txt\").writeText(text) } I com a exemple de copiar un fitxer en un altre, fins i tot canviant el joc de car\u00e0cters, farem una altra versi\u00f3 del Exemple_2_61.kt. Copieu el seg\u00fcent com Exemple_2_61_bis.kt : package exemples import java.io.File fun main() { File(\"f5_2.txt\").writeText(File(\"f5.txt\").readText(), Charsets.ISO_8859_1) } M\u00e8todes de conversi\u00f3 En ocasions \u00e9s possible que no tinguem un m\u00e8tode directament en File que ens vinga b\u00e9. Un exemple s\u00f3n els m\u00e8todes print (print, println, printf). Aleshores, senzillament obtenim a partir del File la classe que ens convinga de la jerarquia de InputStream/OutputStream o Reader/Writer. S\u00f3n m\u00e8todes que ens tornen la classe desitjada: inputStream() : construeix un InputStream que apunta al File, i el torna outputStream() : el mateix amb un OutputStream reader( charset : Charset) : el mateix amb un Reader, tenint la possibilitat d'especificar el joc de car\u00e0cters (si no s'especifica ser\u00e0 UTF-8) writer( charset : Charset) : el mateix amb un Writer bufferedReader( charset : Charset) : el mateix amb un BufferedReader printWriter( charset : Charset) : el mateix amb un Writer Per exemple, el que hem comentat m\u00e9s amunt: si volem els m\u00e8todes print, senzillament obtenim un PrintWriter a partir del File. D'aquesta manera, el Exemple_2_41.kt ens quedaria d'una altra manera per a obtenir el PrintWriter que vol\u00edem. Copieu el seg\u00fcent com Exemple_2_41_bis.kt : package exemples import java.io.File fun main() { val f_out = File(\"f6.txt\").printWriter() val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Altres m\u00e8todes Hi ha altres m\u00e8todes que poden ser molt \u00fatils. Per exemple aquell que copia directament un fitxer, o tot un directori recursivament, o que esborra recursivament, ... copyTo( dest\u00ed : File, sobre_escriure : Boolean, buffer : Int) : copia en el fitxer de dest\u00ed. Per defecte no sobreescriur\u00e0, a no ser que posem true en el segon par\u00e0mentre. El tercer par\u00e0metre \u00e9s per a marcar la grand\u00e0ria del buffer de dades per a fer la c\u00f2pia. copyRecursively( dest\u00ed : File, sobre_escriure : Boolean) : copia recursivament el File i tots els seus descendents en el File de dest\u00ed. Per defecte no sobreescriur\u00e0, a menys que posem true en el segon par\u00e0mentre. Opcionalment es pot posar un tercer par\u00e0metre per al tractament dels possibles errors deleteRecursively(): esborra el file i tots els seus possibles descendents Tamb\u00e9 hi ha altres m\u00e8todes, com per exemple per a comprovar si el nom del File t\u00e9 extensi\u00f3, o si comen\u00e7a o finalitza igual que un altre, o per a normalitzar la ruta (llevar possibles redund\u00e0ncies), i altre m\u00e9s. Es poden consultar totes les extensions que proporciona Kotline a la classe File en: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/ Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Simplificaci\u00f3 en Kotlin"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/4__simplificaci_en_kotlin/#4-simplificacio-en-kotlin","text":"Tots els programes anteriors funcionen en Kotlin perfectament, perqu\u00e8 estem utilitzant les classes de Java, i aquestes sense problemes funcionen en Kotlin, \u00e9s una de les seues caracter\u00edstiques. Tanmateix, Kotlin proporcionar\u00e0 funcionalitat extra en les classes, que ens permetr\u00e0 simplificar prou els programes. S\u00f3n molts els m\u00e8todes nous que ens proporcionar\u00e0. Ac\u00ed tenim uns quants agrupats per tem\u00e0tica. M\u00e8todes sobre bytes readBytes() : torna un ByteArray amb tots els bytes del fitxer, \u00e9s a dir, tot el seu contingut en forma de bytes writeBytes( array : ByteArray) : escriu en el fitxer el contingut del ByteArray. Si el fitxer ja existia, el sobreescriura. appendBytes ( array : ByteArray) : afegeix al final del fitxer els bytes del ByteArray. Tornem a fer el primer exemple, Exemple_2_01.kt, utilitzant aquesta funcionalitat extra. Copieu el seg\u00fcent com Exemple_2_01_bis.kt : package exemples import java.io.File fun main(){ val f = File(\"f1.txt\") val tot = f.readBytes() for (c in tot){ println(c.toChar()) } } I com a exemple d'escriptura, podem fer Exemple_2_11.kt,on ho podem fer tot en una l\u00ednia. Copieu el seg\u00fcent com Exemple_2_11_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer.\" File(\"f3.txt\").writeBytes(text.toByteArray()) } Recordeu que en els dos exemples anteriors per comoditat estem utilitzant car\u00e0cters com a dades, i no seria el m\u00e9s correcte utilitzar bytes ni de lectura ni d'escriptura. Ho hem fet \u00fanicament per comoditat. M\u00e8todes sobre car\u00e0cters readText( charset : CharSet) : torna un String amb la tots els car\u00e0cters del fitxer. Opcionalment li podem dir el joc de car\u00e0cters (si no li ho diem utilitzar\u00e0 UTF-8) readLines( charset : CharSet) : torna un List de Strings amb totes les l\u00ednies del fitxer writeText( text : String, charset : CharSet) : escriu el string en el fitxer. Si el fitxer ja existia el sobreescriur\u00e0. Opcionalment podem posar el joc de car\u00e0cters que volem utilitzar. Si no el posem utilitzar\u00e0 UTF-8. Observeu que ja dispos\u00e0vem d'un m\u00e8tode que escrivia tot un String anteriorment, per tant no \u00e9s una gran millora, excepte pel fet de poder especificar el joc de car\u00e0cters. A\u00e7\u00f2 s\u00ed que \u00e9s de gran comoditat. appendText( text : String, charset : CharSet) : el mateix que l'anterior, per\u00f2 afegint al final. Com a exemple anem a veure Exemple_2_21.kt. Copieu el seg\u00fcent com Exemple_2_21_bis.kt : package exemples import java.io.File fun main(){ val tot = File(\"f1.txt\").readText() for(c in tot){ println(c) } } I com a exemple d'escriptura, l'adaptaci\u00f3 de Exemple_2_31.kt. Copieu el seg\u00fcent com Exemple_2_31_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" File(\"f5.txt\").writeText(text) } I com a exemple de copiar un fitxer en un altre, fins i tot canviant el joc de car\u00e0cters, farem una altra versi\u00f3 del Exemple_2_61.kt. Copieu el seg\u00fcent com Exemple_2_61_bis.kt : package exemples import java.io.File fun main() { File(\"f5_2.txt\").writeText(File(\"f5.txt\").readText(), Charsets.ISO_8859_1) } M\u00e8todes de conversi\u00f3 En ocasions \u00e9s possible que no tinguem un m\u00e8tode directament en File que ens vinga b\u00e9. Un exemple s\u00f3n els m\u00e8todes print (print, println, printf). Aleshores, senzillament obtenim a partir del File la classe que ens convinga de la jerarquia de InputStream/OutputStream o Reader/Writer. S\u00f3n m\u00e8todes que ens tornen la classe desitjada: inputStream() : construeix un InputStream que apunta al File, i el torna outputStream() : el mateix amb un OutputStream reader( charset : Charset) : el mateix amb un Reader, tenint la possibilitat d'especificar el joc de car\u00e0cters (si no s'especifica ser\u00e0 UTF-8) writer( charset : Charset) : el mateix amb un Writer bufferedReader( charset : Charset) : el mateix amb un BufferedReader printWriter( charset : Charset) : el mateix amb un Writer Per exemple, el que hem comentat m\u00e9s amunt: si volem els m\u00e8todes print, senzillament obtenim un PrintWriter a partir del File. D'aquesta manera, el Exemple_2_41.kt ens quedaria d'una altra manera per a obtenir el PrintWriter que vol\u00edem. Copieu el seg\u00fcent com Exemple_2_41_bis.kt : package exemples import java.io.File fun main() { val f_out = File(\"f6.txt\").printWriter() val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Altres m\u00e8todes Hi ha altres m\u00e8todes que poden ser molt \u00fatils. Per exemple aquell que copia directament un fitxer, o tot un directori recursivament, o que esborra recursivament, ... copyTo( dest\u00ed : File, sobre_escriure : Boolean, buffer : Int) : copia en el fitxer de dest\u00ed. Per defecte no sobreescriur\u00e0, a no ser que posem true en el segon par\u00e0mentre. El tercer par\u00e0metre \u00e9s per a marcar la grand\u00e0ria del buffer de dades per a fer la c\u00f2pia. copyRecursively( dest\u00ed : File, sobre_escriure : Boolean) : copia recursivament el File i tots els seus descendents en el File de dest\u00ed. Per defecte no sobreescriur\u00e0, a menys que posem true en el segon par\u00e0mentre. Opcionalment es pot posar un tercer par\u00e0metre per al tractament dels possibles errors deleteRecursively(): esborra el file i tots els seus possibles descendents Tamb\u00e9 hi ha altres m\u00e8todes, com per exemple per a comprovar si el nom del File t\u00e9 extensi\u00f3, o si comen\u00e7a o finalitza igual que un altre, o per a normalitzar la ruta (llevar possibles redund\u00e0ncies), i altre m\u00e9s. Es poden consultar totes les extensions que proporciona Kotline a la classe File en: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/ Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Simplificaci\u00f3 en Kotlin"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/","text":"Exercicis Exercici T2_1 Aquest primer exercicis \u00e9s per a tractament de bytes, ja que es tractar\u00e0 de modificar una imatge. Per a poder provar-lo podeu utilitzar la imatge Penyagolosa.bmp que se us proporciona en l'aula virtual i l'heu de copiar al directori arrel del projecte Tema2 per a un funcionament m\u00e9s c\u00f2mode. No es pret\u00e9n construir un editor d'imatges. Tan sols pretenem agafar la informaci\u00f3 del fitxer byte a byte, realitzar alguna transformaci\u00f3 en els bytes i guardar-la en un altre fitxer. El format d'un fitxer bmp , aproximadament \u00e9s el seg\u00fcent: En els 54 primers bytes es guarda informaci\u00f3 diversa, com la grand\u00e0ria de la imatge, paleta de colors, ... A partir d'ah\u00ed es guarda cada punt de la imatge com 3 bytes , un per al roig (R), un per al verd (G) i i un per al blau (B), anant d'esquerra a dreta i de dalt a baix. Copia't i modifica la classe FitxerImatge en el paquet exercicis , creant els m\u00e8todes oportuns seguint aquestes pautes: El constructor FitxerImatge(File fEnt) ha d'inicialitzar la propietat f ( File ) si i nom\u00e9s si existeix el fitxer i l'extensi\u00f3 del fitxer \u00e9s .bmp (ho controlarem senzillament perqu\u00e8 el nom del fitxer acaba aix\u00ed). En cas contrari, traure els missatges d'error oportuns per l'eixida est\u00e0ndar. Els m\u00e8todes de transformaci\u00f3 ( transformaNegatiu , transformaObscur i el voluntari transformaBlancNegre ) han de crear un nou fitxer que contindr\u00e0 la imatge transformada com veurem m\u00e9s avant. El nom del nou fitxer s'ha de formar a partir del nom del fitxer d'entrada, el que hem guardat en el constructor. Ser\u00e0 sempre posant abans del .bmp un gui\u00f3 baix i un identificatiu de la transformaci\u00f3 realitzada: _n per al negatiu, _o per a l'obscur i _bn per al blanc i negre (part volunt\u00e0ria). \u00c9s a dir, si el fitxer d'entrada f\u00f3ra imatge1.bmp , el d'eixida haur\u00e0 de ser: imatge1_n.bmp per al m\u00e8tode transformaNegatiu imatge1_o.bmp per al m\u00e8tode transformaObscur imatge1_bn.bmp per al m\u00e8tode voluntari transformaBlancNegre **** En cada transformaci\u00f3, els primers 54 bytes s'han de copiar sense modificar: s'han d'escriure en el fitxer de dest\u00ed tal i com s'han llegit del fitxer d'entrada A partir del 54, cada vegada que es llegir\u00e0 un byte, s'haur\u00e0 de transformar abans d'escriure'l en el dest\u00ed. La transformaci\u00f3 \u00e9s d'aquesta manera: Per al negatiu ( transformaNegatiu ), cada byte de color (RGB) de cada punt, s'ha de transformar en el complementari. Com estem parlant de bytes per\u00f2 que en llegir els guardem en enters, senzillament ser\u00e0 calcular 255 - b (si b \u00e9s el byte llegit). Per a l' obscur ( transformaObscur ), cada byte de color (RGB) de cada punt, s'ha de baixar d'intensitat a la meitat. Senzillament ser\u00e0 calcular b / 2 (si b \u00e9s el byte llegit). Per al blanc i negre ( transformaBlancNegre ), que \u00e9s el voluntari, hem de donar el mateix valor per al roig, el blau i el verd (RGB) de cada punt, i aix\u00ed aconseguirem un gris d'intensitat adequada. Una bona manera ser\u00e0 llegir els tres bytes de cada punt ( no s'aconsella utilitzar una lectura amb un array de 3 posicions ; millor fer tres lectures guardades en tres variables diferents), calcular la mitjana d'aquestos 3 valors, i escriure el resultat 3 vegades en el fitxer de dest\u00ed. En cap dels casos anteriors es recomana la lectura dels bytes en un ByteArray, perqu\u00e8 podeu tenir resultats imprevisibles a causa de la interpretaci\u00f3 num\u00e8rica (i per tant amb signe, cosa que en aquest cas no t\u00e9 sentit, ja que han s\u00f3n n\u00fameros del 0 al 255). Es recomana vivament llegir byte a byte . A mode orientatiu del que es vol fer, us adjunte la classe FitxerImatge a la qual heu de modificar el constructor i els tres m\u00e8todes de transformaci\u00f3 (l'\u00faltim \u00e9s voluntari). Recordeu que ha d'anar al paquet exercicis .**** package exercicis import java.io.File class FitxerImatge(fEnt: File) { var f: File = File(\"\") // No modifiqueu aquesta l\u00ednia. El seu valor s'ha de modificar en el constructor init { // Constructor // Control d'exist\u00e8ncia del fitxer i control de l'extensi\u00f3 .bmp (traure missatges d'error) // En cas que tot siga correcte, inicialitzar f amb fEnt } fun transformaNegatiu() { // Transformar a negatiiu i guardar en _n.bmp } fun transformaObscur() { // Transformar a una imatge m\u00e9s fosca i guardar en _o.bmp } /* Partvolunt\u00e0ria fun transformaBlancNegre() { // Transformar a una imatge en blanc i negre i guardar en _bn.bmp } */ } Aquest seria un exemple de programa principal, que podeu utilitzar si voleu. Recordeu que ha d'anar al paquet exercicis i li podeu donar el nom Exercici_2_1.kt . package exercicis import java.io.File fun main(args: Array<String>){ val f = File(\"Penyagolosa.bmp\") val fi = FitxerImatge(f) fi.transformaNegatiu() fi.transformaObscur() //voluntari //fi.transformaBlancNegre() } Per a la imatge que se us proporciona (i que est\u00e0 en la construcci\u00f3 del File del programa principal), que \u00e9s la de l'esquerra, haurien d'eixir les de la dreta: Imatge inicial negatiu obscur blanc i negre (voluntari) Penyagolosa.bmp Penyagolosa_n.bmp Penyagolosa_o.bmp Penyagolosa_bn.bmp Exercici T2_2 Aquest programa ser\u00e0 el primer que utilitzar\u00e0 components gr\u00e0fics. Per a entendre els components gr\u00e0fics de la llibreria Swing i els contenidors de la llibreria Awt , que s\u00f3n els que utilitzarem, us aconselle que us mireu l'annex Gr\u00e0fics en Java: llibreries AWT i SWING ****que teniu en la secci\u00f3 d'annexos, al final del curs de Moodle. De tota manera, us proporcione \"l'esquelet\" del programa, i nom\u00e9s us demane que feu les sent\u00e8ncies de quan s'apreten els botons d'obrir i de guardar. Anem a fer un senzill editor de text amb el seg\u00fcent aspecte: En el JTextField de dalt posarem el nom (i ruta) del fitxer. Quan apretem al bot\u00f3 Obrir ha de bolcar el contingut del fitxer al JTextArea (controlant pr\u00e8viament que existeix el fitxer). Quan apretem a Guardar , ha de bolcar el contingut del JTextArea en el fitxer (el nom del qual tenim en el JTextField ).**** L'esquelet del programa \u00e9s el que trobareu a continuaci\u00f3. He utilitzat la filosofia de l'annex, que consisteix a tenir al final de tot el programa principal (el main) que invoca amb posterioritat ( invokeLater *) una funci\u00f3 que crea l'objecte de la classe que hereta de *JFrame , que \u00e9s realment la finestra, i la fa visible. Una vegada copiat en el paquet exercicis del projecte Tema2 per exemple amb el nom Exercici_2_ 2.kt , nom\u00e9s heu de completar el que teniu al final de tot d'aquesta classe on estan els comentaris, \u00e9s a dir els m\u00e8todes addActionListener dels botons obrir i guardar package exercicis import javax.swing.* import java.awt.* class Exercici_2_2_Pantalla : JFrame() { val et_f = JLabel(\"Fitxer:\") val fitxer = JTextField(25) val obrir = JButton(\"Obrir\") val guardar = JButton(\"Guardar\") val et_a = JLabel(\"Contingut:\") val area = JTextArea(10, 50) val scrollPane = JScrollPane(area) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(GridLayout(2, 1)) setTitle(\"Editor de text\") val panell1 = JPanel(GridLayout(0, 1)) val panell1_1 = JPanel(FlowLayout()) panell1.add(panell1_1) panell1_1.add(et_f) panell1_1.add(fitxer) val panell1_2 = JPanel(FlowLayout()) panell1.add(panell1_2) panell1_2.add(obrir) panell1_2.add(guardar) val panell2 = JPanel(GridLayout(0, 1)) panell2.add(scrollPane) area.setEditable(true) add(panell1) add(panell2) pack() obrir.addActionListener { // Instruccions per a bolcar el contingut del fitxer en el JTextArea } guardar.addActionListener { // Instruccions per a guardar el contingut del JTextArea al fitxer. } } } private fun crearMostrarFinestra() { val frame = Exercici_2_2_Pantalla() frame.isVisible = true } fun main(args: Array<String>) { EventQueue.invokeLater(::crearMostrarFinestra) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercici-t2_1","text":"Aquest primer exercicis \u00e9s per a tractament de bytes, ja que es tractar\u00e0 de modificar una imatge. Per a poder provar-lo podeu utilitzar la imatge Penyagolosa.bmp que se us proporciona en l'aula virtual i l'heu de copiar al directori arrel del projecte Tema2 per a un funcionament m\u00e9s c\u00f2mode. No es pret\u00e9n construir un editor d'imatges. Tan sols pretenem agafar la informaci\u00f3 del fitxer byte a byte, realitzar alguna transformaci\u00f3 en els bytes i guardar-la en un altre fitxer. El format d'un fitxer bmp , aproximadament \u00e9s el seg\u00fcent: En els 54 primers bytes es guarda informaci\u00f3 diversa, com la grand\u00e0ria de la imatge, paleta de colors, ... A partir d'ah\u00ed es guarda cada punt de la imatge com 3 bytes , un per al roig (R), un per al verd (G) i i un per al blau (B), anant d'esquerra a dreta i de dalt a baix. Copia't i modifica la classe FitxerImatge en el paquet exercicis , creant els m\u00e8todes oportuns seguint aquestes pautes: El constructor FitxerImatge(File fEnt) ha d'inicialitzar la propietat f ( File ) si i nom\u00e9s si existeix el fitxer i l'extensi\u00f3 del fitxer \u00e9s .bmp (ho controlarem senzillament perqu\u00e8 el nom del fitxer acaba aix\u00ed). En cas contrari, traure els missatges d'error oportuns per l'eixida est\u00e0ndar. Els m\u00e8todes de transformaci\u00f3 ( transformaNegatiu , transformaObscur i el voluntari transformaBlancNegre ) han de crear un nou fitxer que contindr\u00e0 la imatge transformada com veurem m\u00e9s avant. El nom del nou fitxer s'ha de formar a partir del nom del fitxer d'entrada, el que hem guardat en el constructor. Ser\u00e0 sempre posant abans del .bmp un gui\u00f3 baix i un identificatiu de la transformaci\u00f3 realitzada: _n per al negatiu, _o per a l'obscur i _bn per al blanc i negre (part volunt\u00e0ria). \u00c9s a dir, si el fitxer d'entrada f\u00f3ra imatge1.bmp , el d'eixida haur\u00e0 de ser: imatge1_n.bmp per al m\u00e8tode transformaNegatiu imatge1_o.bmp per al m\u00e8tode transformaObscur imatge1_bn.bmp per al m\u00e8tode voluntari transformaBlancNegre **** En cada transformaci\u00f3, els primers 54 bytes s'han de copiar sense modificar: s'han d'escriure en el fitxer de dest\u00ed tal i com s'han llegit del fitxer d'entrada A partir del 54, cada vegada que es llegir\u00e0 un byte, s'haur\u00e0 de transformar abans d'escriure'l en el dest\u00ed. La transformaci\u00f3 \u00e9s d'aquesta manera: Per al negatiu ( transformaNegatiu ), cada byte de color (RGB) de cada punt, s'ha de transformar en el complementari. Com estem parlant de bytes per\u00f2 que en llegir els guardem en enters, senzillament ser\u00e0 calcular 255 - b (si b \u00e9s el byte llegit). Per a l' obscur ( transformaObscur ), cada byte de color (RGB) de cada punt, s'ha de baixar d'intensitat a la meitat. Senzillament ser\u00e0 calcular b / 2 (si b \u00e9s el byte llegit). Per al blanc i negre ( transformaBlancNegre ), que \u00e9s el voluntari, hem de donar el mateix valor per al roig, el blau i el verd (RGB) de cada punt, i aix\u00ed aconseguirem un gris d'intensitat adequada. Una bona manera ser\u00e0 llegir els tres bytes de cada punt ( no s'aconsella utilitzar una lectura amb un array de 3 posicions ; millor fer tres lectures guardades en tres variables diferents), calcular la mitjana d'aquestos 3 valors, i escriure el resultat 3 vegades en el fitxer de dest\u00ed. En cap dels casos anteriors es recomana la lectura dels bytes en un ByteArray, perqu\u00e8 podeu tenir resultats imprevisibles a causa de la interpretaci\u00f3 num\u00e8rica (i per tant amb signe, cosa que en aquest cas no t\u00e9 sentit, ja que han s\u00f3n n\u00fameros del 0 al 255). Es recomana vivament llegir byte a byte . A mode orientatiu del que es vol fer, us adjunte la classe FitxerImatge a la qual heu de modificar el constructor i els tres m\u00e8todes de transformaci\u00f3 (l'\u00faltim \u00e9s voluntari). Recordeu que ha d'anar al paquet exercicis .**** package exercicis import java.io.File class FitxerImatge(fEnt: File) { var f: File = File(\"\") // No modifiqueu aquesta l\u00ednia. El seu valor s'ha de modificar en el constructor init { // Constructor // Control d'exist\u00e8ncia del fitxer i control de l'extensi\u00f3 .bmp (traure missatges d'error) // En cas que tot siga correcte, inicialitzar f amb fEnt } fun transformaNegatiu() { // Transformar a negatiiu i guardar en _n.bmp } fun transformaObscur() { // Transformar a una imatge m\u00e9s fosca i guardar en _o.bmp } /* Partvolunt\u00e0ria fun transformaBlancNegre() { // Transformar a una imatge en blanc i negre i guardar en _bn.bmp } */ } Aquest seria un exemple de programa principal, que podeu utilitzar si voleu. Recordeu que ha d'anar al paquet exercicis i li podeu donar el nom Exercici_2_1.kt . package exercicis import java.io.File fun main(args: Array<String>){ val f = File(\"Penyagolosa.bmp\") val fi = FitxerImatge(f) fi.transformaNegatiu() fi.transformaObscur() //voluntari //fi.transformaBlancNegre() } Per a la imatge que se us proporciona (i que est\u00e0 en la construcci\u00f3 del File del programa principal), que \u00e9s la de l'esquerra, haurien d'eixir les de la dreta: Imatge inicial negatiu obscur blanc i negre (voluntari) Penyagolosa.bmp Penyagolosa_n.bmp Penyagolosa_o.bmp Penyagolosa_bn.bmp","title":"Exercici T2_1"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercici-t2_2","text":"Aquest programa ser\u00e0 el primer que utilitzar\u00e0 components gr\u00e0fics. Per a entendre els components gr\u00e0fics de la llibreria Swing i els contenidors de la llibreria Awt , que s\u00f3n els que utilitzarem, us aconselle que us mireu l'annex Gr\u00e0fics en Java: llibreries AWT i SWING ****que teniu en la secci\u00f3 d'annexos, al final del curs de Moodle. De tota manera, us proporcione \"l'esquelet\" del programa, i nom\u00e9s us demane que feu les sent\u00e8ncies de quan s'apreten els botons d'obrir i de guardar. Anem a fer un senzill editor de text amb el seg\u00fcent aspecte: En el JTextField de dalt posarem el nom (i ruta) del fitxer. Quan apretem al bot\u00f3 Obrir ha de bolcar el contingut del fitxer al JTextArea (controlant pr\u00e8viament que existeix el fitxer). Quan apretem a Guardar , ha de bolcar el contingut del JTextArea en el fitxer (el nom del qual tenim en el JTextField ).**** L'esquelet del programa \u00e9s el que trobareu a continuaci\u00f3. He utilitzat la filosofia de l'annex, que consisteix a tenir al final de tot el programa principal (el main) que invoca amb posterioritat ( invokeLater *) una funci\u00f3 que crea l'objecte de la classe que hereta de *JFrame , que \u00e9s realment la finestra, i la fa visible. Una vegada copiat en el paquet exercicis del projecte Tema2 per exemple amb el nom Exercici_2_ 2.kt , nom\u00e9s heu de completar el que teniu al final de tot d'aquesta classe on estan els comentaris, \u00e9s a dir els m\u00e8todes addActionListener dels botons obrir i guardar package exercicis import javax.swing.* import java.awt.* class Exercici_2_2_Pantalla : JFrame() { val et_f = JLabel(\"Fitxer:\") val fitxer = JTextField(25) val obrir = JButton(\"Obrir\") val guardar = JButton(\"Guardar\") val et_a = JLabel(\"Contingut:\") val area = JTextArea(10, 50) val scrollPane = JScrollPane(area) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(GridLayout(2, 1)) setTitle(\"Editor de text\") val panell1 = JPanel(GridLayout(0, 1)) val panell1_1 = JPanel(FlowLayout()) panell1.add(panell1_1) panell1_1.add(et_f) panell1_1.add(fitxer) val panell1_2 = JPanel(FlowLayout()) panell1.add(panell1_2) panell1_2.add(obrir) panell1_2.add(guardar) val panell2 = JPanel(GridLayout(0, 1)) panell2.add(scrollPane) area.setEditable(true) add(panell1) add(panell2) pack() obrir.addActionListener { // Instruccions per a bolcar el contingut del fitxer en el JTextArea } guardar.addActionListener { // Instruccions per a guardar el contingut del JTextArea al fitxer. } } } private fun crearMostrarFinestra() { val frame = Exercici_2_2_Pantalla() frame.isVisible = true } fun main(args: Array<String>) { EventQueue.invokeLater(::crearMostrarFinestra) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici T2_2"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/objectius/","text":"Objectius L'objectiu d'aquest apartat ser\u00e0 accedir al contingut dels fitxers, b\u00e9 per a llegir \u00fanicament o b\u00e9 per a guardar informaci\u00f3 de forma permanent. Per a a\u00e7\u00f2 en Java disposem de les classes de flux de dades ( streams ). Lamentablement Java disposa d'una quantitat de streams extraordin\u00e0riament gran, cosa que suposa una gran complexitat per al programador (ja que ha de recordar moltes classes). Per contra ofereix una potencialitat molt gran. Donada aquesta varietat de classes i la complexitat inherent, aquest tema comen\u00e7ar\u00e0 el tractament del contingut dels fitxers separant les classes en 2 categories: considerant la informaci\u00f3 com un conjunt de bytes, i considerant- la com un conjunt de car\u00e0cters. Afortunadament Kotlin simplifica molt el tractament, i no caldr\u00e0 utilitzar tantes classes. No obstant aix\u00f2, \u00e9s recomanable saber tota la jerarquia de classes e Java per a poder dominar l'acc\u00e9s a fitxers tamb\u00e9 en Kotlin. El seg\u00fcent tema ser\u00e0 una continuaci\u00f3 d'aquest, veient formats especials de fitxers i tamb\u00e9 diferents maneres d'accedir. Nota Per als exemples i exercicis d'aquest tema, heu de crear un projecte nou, Tema2 . Haureu de crear 2 paquets, exemples i exercicis , de forma similar a com hav\u00edem fet en el Tema 1. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/objectius/#objectius","text":"L'objectiu d'aquest apartat ser\u00e0 accedir al contingut dels fitxers, b\u00e9 per a llegir \u00fanicament o b\u00e9 per a guardar informaci\u00f3 de forma permanent. Per a a\u00e7\u00f2 en Java disposem de les classes de flux de dades ( streams ). Lamentablement Java disposa d'una quantitat de streams extraordin\u00e0riament gran, cosa que suposa una gran complexitat per al programador (ja que ha de recordar moltes classes). Per contra ofereix una potencialitat molt gran. Donada aquesta varietat de classes i la complexitat inherent, aquest tema comen\u00e7ar\u00e0 el tractament del contingut dels fitxers separant les classes en 2 categories: considerant la informaci\u00f3 com un conjunt de bytes, i considerant- la com un conjunt de car\u00e0cters. Afortunadament Kotlin simplifica molt el tractament, i no caldr\u00e0 utilitzar tantes classes. No obstant aix\u00f2, \u00e9s recomanable saber tota la jerarquia de classes e Java per a poder dominar l'acc\u00e9s a fitxers tamb\u00e9 en Kotlin. El seg\u00fcent tema ser\u00e0 una continuaci\u00f3 d'aquest, veient formats especials de fitxers i tamb\u00e9 diferents maneres d'accedir. Nota Per als exemples i exercicis d'aquest tema, heu de crear un projecte nou, Tema2 . Haureu de crear 2 paquets, exemples i exercicis , de forma similar a com hav\u00edem fet en el Tema 1. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T3_Fitxers_de_diferents_formats/1_fitxers_binaris_amb_formats_especfics/","text":"Acc\u00e9s a Dades 1.- Fitxers binaris amb formats espec\u00edfics DataInputStream i DataOutputStream Ja hem vist com utilitzar els fitxers de car\u00e0cters i tamb\u00e9 de bytes. Per\u00f2 en aquest \u00faltim cas sempre ha estat per a llegir o escriure byte a byte, fins al final de fitxer. Ens plantegem ara com utilitzar els fitxer per a guardar dades estructurades de tipus b\u00e0sics diferents . De moment no seran complicades per\u00f2 enseguida veurem que ens fa falta alguna cosa per a poder treballar c\u00f2modament. Suposem un exemple d'una empresa que vol guardar dades dels seus empleats. Concretament vol guardar el n\u00famero d'empleat, el nom, el departament al qual pertany, l'edat i el sou. N\u00famero Nom Depart Edat Sou 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 Ja es veu que les dades s\u00f3n de difrents tipus. Si tot f\u00f3ra de text no hi hauria problema. Per\u00f2 si considerem les dades com a num\u00e8riques enteres o reals no ens serveixen els Stream de car\u00e0cters (Reader i Writer). Per tant hem d'anar a InputStream i OutputStream, per\u00f2 seria molt dur treballar directament amb bytes. Haur\u00edem de saber exactament quants bytes ocupa cada dada: int utilitza 4 bytes; short utilitza 2 bytes, byte utilitza 1 byte, i long utilitza 8 bytes; en el cas dels reals, float utilitza 4 bytes i double utilitza 8 bytes. Massa varietat i massa fiena recordar-los tots. Ens falta doncs una ajuda per a poder guardar i recuperar dades d'aquestos diferents tipus. Aquesta funcionalitat ens la proporciona la parella DataInputStream i DataOutputStream , que s\u00f3n decoradors dels Stream i que disposen de m\u00e8todes per a guardar o recuperar dades de diferents tipus, sense haver de saber el format intern de cadascun ni quants bytes ocupen. En la seg\u00fcent taula tenim uns quants m\u00e8todes d'aquestos: DataInputStream Explicaci\u00f3 DataOutputStream byte readByte () Un byte void writeByte (int) short readShort () Un enter xicotet (2 bytes) void writeShort (short) int readInt () Un enter (4 bytes) void writeInt (int) long readLong () Un enter llarg (8 bytes) void writeLong (long) float readFloat () Un real en simple precisi\u00f3 void writeFloat (flaot) double readDouble () Un real en doble precisi\u00f3 void writeDouble (double) char readChar () Un car\u00e0cter Unicode (16 bits) void writeChar (int) String readUTF () Una cadena de car\u00e0cters UTF-8 i la converteix en String (16 bits) void writeUTF (String) Anem a veure l'exemple, en el qual guardarem en un fitxer anomenat Empleats.dat les dades dels 4 empleats. Per comoditat ens els definirem en arrays de 4 elements: un array per als noms, un altre per als departaments, etc. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_1_CrearEmpleats.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats.dat\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } I aquesta seria la recuperaci\u00f3 de les dades. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_2_ConsultarEmpleats.kt package exemples import java.io.FileInputStream import java.io.DataInputStream fun main(args: Array<String>) { val f = DataInputStream(FileInputStream(\"Empleats.dat\")) while (f.available() > 0) { System.out.println(\"N\u00famero: \" + f.readInt()) System.out.println(\"Nom: \" + f.readUTF()) System.out.println(\"Depart: \" + f.readInt()) System.out.println(\"Edat: \" + f.readInt()) System.out.println(\"Sou: \" + f.readDouble()) System.out.println() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Fitxers binaris amb formats espec\u00edfics"},{"location":"AD_T3_Fitxers_de_diferents_formats/1_fitxers_binaris_amb_formats_especfics/#1-fitxers-binaris-amb-formats-especifics","text":"DataInputStream i DataOutputStream Ja hem vist com utilitzar els fitxers de car\u00e0cters i tamb\u00e9 de bytes. Per\u00f2 en aquest \u00faltim cas sempre ha estat per a llegir o escriure byte a byte, fins al final de fitxer. Ens plantegem ara com utilitzar els fitxer per a guardar dades estructurades de tipus b\u00e0sics diferents . De moment no seran complicades per\u00f2 enseguida veurem que ens fa falta alguna cosa per a poder treballar c\u00f2modament. Suposem un exemple d'una empresa que vol guardar dades dels seus empleats. Concretament vol guardar el n\u00famero d'empleat, el nom, el departament al qual pertany, l'edat i el sou. N\u00famero Nom Depart Edat Sou 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 Ja es veu que les dades s\u00f3n de difrents tipus. Si tot f\u00f3ra de text no hi hauria problema. Per\u00f2 si considerem les dades com a num\u00e8riques enteres o reals no ens serveixen els Stream de car\u00e0cters (Reader i Writer). Per tant hem d'anar a InputStream i OutputStream, per\u00f2 seria molt dur treballar directament amb bytes. Haur\u00edem de saber exactament quants bytes ocupa cada dada: int utilitza 4 bytes; short utilitza 2 bytes, byte utilitza 1 byte, i long utilitza 8 bytes; en el cas dels reals, float utilitza 4 bytes i double utilitza 8 bytes. Massa varietat i massa fiena recordar-los tots. Ens falta doncs una ajuda per a poder guardar i recuperar dades d'aquestos diferents tipus. Aquesta funcionalitat ens la proporciona la parella DataInputStream i DataOutputStream , que s\u00f3n decoradors dels Stream i que disposen de m\u00e8todes per a guardar o recuperar dades de diferents tipus, sense haver de saber el format intern de cadascun ni quants bytes ocupen. En la seg\u00fcent taula tenim uns quants m\u00e8todes d'aquestos: DataInputStream Explicaci\u00f3 DataOutputStream byte readByte () Un byte void writeByte (int) short readShort () Un enter xicotet (2 bytes) void writeShort (short) int readInt () Un enter (4 bytes) void writeInt (int) long readLong () Un enter llarg (8 bytes) void writeLong (long) float readFloat () Un real en simple precisi\u00f3 void writeFloat (flaot) double readDouble () Un real en doble precisi\u00f3 void writeDouble (double) char readChar () Un car\u00e0cter Unicode (16 bits) void writeChar (int) String readUTF () Una cadena de car\u00e0cters UTF-8 i la converteix en String (16 bits) void writeUTF (String) Anem a veure l'exemple, en el qual guardarem en un fitxer anomenat Empleats.dat les dades dels 4 empleats. Per comoditat ens els definirem en arrays de 4 elements: un array per als noms, un altre per als departaments, etc. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_1_CrearEmpleats.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats.dat\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } I aquesta seria la recuperaci\u00f3 de les dades. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_2_ConsultarEmpleats.kt package exemples import java.io.FileInputStream import java.io.DataInputStream fun main(args: Array<String>) { val f = DataInputStream(FileInputStream(\"Empleats.dat\")) while (f.available() > 0) { System.out.println(\"N\u00famero: \" + f.readInt()) System.out.println(\"Nom: \" + f.readUTF()) System.out.println(\"Depart: \" + f.readInt()) System.out.println(\"Edat: \" + f.readInt()) System.out.println(\"Sou: \" + f.readDouble()) System.out.println() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Fitxers binaris amb formats espec\u00edfics"},{"location":"AD_T3_Fitxers_de_diferents_formats/2_accs_directe_a_fitxers/","text":"2.- Acc\u00e9s directe a fitxers Els exemples de l'apartat anterior ens poden fer reflexionar sobre un altre tipus d'acc\u00e9s als fitxers. De moment tots els accessos que hem fet als fitxers, tant binaris com de car\u00e0cter, ha estat seq\u00fcencials . Aix\u00f2 vol dir que sempre comencem pel principi del fitxer fins que arribem a la informaci\u00f3 que volem, o en la major part dels casos fins el final de fitxer. Per\u00f2, i si volem \u00fanicament una determinada informaci\u00f3? En l'exemple de l'apartat anterior, qu\u00e8 haur\u00edem de fer si volgu\u00e9rem nom\u00e9s la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia)? Doncs haur\u00edem de passar primer per tots els anteriors. Com nom\u00e9s hi ha 2 davant, no sembla molta feina, per\u00f2 \u00e9s f\u00e0cil de veure la dificultat (o millor dit el cost) si el fitxer constara de centenars o milers d'empleats. Suposem un fitxer de 10.000 empleats. Si volem accedir a l'empleat 9.500 haur\u00edem de passar pels 9.499 empleats anteriors, ja que l'acc\u00e9s seq\u00fcencial obliga a comen\u00e7ar pel principi i anar passant fins que trobem la informaci\u00f3. I encara pitjor: i si despr\u00e9s de consultar l'empleat 9.500 ara volem consultar el 9.000? Doncs haur\u00edem de comen\u00e7ar des del principi, perqu\u00e8 ja ens l'hav\u00edem passat. Afortunadament i ha una altra manera d'accedir, un altre tipus d'acc\u00e9s. S'anomena acc\u00e9s directe perqu\u00e8 permetr\u00e0 anar directament a una posici\u00f3 determinada del fitxer. Moltes vegades tamb\u00e9 es diu acc\u00e9s relatiu o acc\u00e9s aleatori , per\u00f2 el funcionament sempre \u00e9s el mateix. I mireu que estem parlant d'acc\u00e9s. Per tant el que canviar\u00e0 no \u00e9s la classe File sin\u00f3 qui permet accedir al contingut, \u00e9s a dir les classes de flux d'informaci\u00f3 (els Streams). Les classes InputStream-OutputStream i Reader-Writer nom\u00e9s permeten l'acc\u00e9s seq\u00fcencial. Per tant per a l'acc\u00e9s directe disposarem d'una altra classe que ens permetr\u00e0 fer totes les operacions, tant de lectura com d'escriptura. T\u00e9 l'avantatge que disposa de molts m\u00e8todes per a poder accedir a la informaci\u00f3. No ens fara falta, per tant, les classes \"decoradores\" que afegeixen funcionalitats. Amb aquesta classe tindrem suficient. RandomAccessFile La classe RandomAccessFile ens permetr\u00e0 accedir de forma directa a un fitxer. No ens far\u00e0 falta, en principi, cap altra classe m\u00e9s. Ens proporcionar\u00e0 tota la funcionalitat necess\u00e0ria. En els constructors aniran 2 par\u00e0metres. El primer far\u00e0 refer\u00e8ncia al fitxer. El segon al mode d'acc\u00e9s: nom\u00e9s lectura ( r ) o lectura-escriptura ( rw ). RandomAccessFile(fitxer: File, mode: String) RandomAccessFile(fitxer: String, mode: String) En el primer cas li especifiquem un File en el primer par\u00e0metre. En el segon un String que correspondr\u00e0 amb el nom del fitxer En ambd\u00f3s casos, el segon par\u00e0metre indicar\u00e0 el mode: \"r\" indica nom\u00e9s lectura \"rw\" indica lectura escriptura A pesar de ser una classe completament diferent de la jerarquia de InputStream-OutpuStream (o Readre-Writer ) implementa m\u00e8todes que es diuen exactament igual que els d'aquelles classes, cosa que fa molt m\u00e9s c\u00f2moda la utilitzaci\u00f3. Els m\u00e8todes m\u00e9s importants s\u00f3n: M\u00e8tode Explicaci\u00f3 M\u00e8tode int read() llig (escriu) un byte (encara aix\u00ed torna o se li passa un enter) void write(int) int read(byte[]) llig (escriu) un s\u00e8rie de bytes, tants com la grand\u00e0ria de l'array (si pot) int write(byte[]) byte readByte() llig (escriu) un byte interpretat com n\u00famero de 8 bits amb signe void writeByte(int) char readChar() llig (escriu) un car\u00e0cter void write(char) int readInt() llig (escriu) un enter (4 bytes) void write(int) short readShort() llig (escriu) un enter xicotet (2 bytes) void write(short) long readLong() llig (escriu) un enter llarg (8 bytes) void write(long) float readFloat() llig (escriu) un n\u00famero real en simple precisi\u00f3 (4 bytes) void write(float) double readDouble() llig (escriu) un n\u00famero real en doble precisi\u00f3 (8 bytes) void write(double) String readUTF() llig (escriu) un cadena de car\u00e0cters (interpretat com UTF-8) void writeUTF() void seek(long) situa el punter en la posici\u00f3, mesurat des del principi del fitxer long length() torna la grand\u00e0ria del fitxer void close() Tanca el flux de l'acc\u00e9s directe En cada lectura, despr\u00e9s de llegir el punter que apunta al fitxer estar\u00e0 situat despr\u00e9s de la dada llegida, siga quina siga la grand\u00e0ria. Anem a veure un exemple utilitzant el fitxer Empleats.dat creat en l'apartat anterior. Obrim l'acc\u00e9s directe \u00fanicament en mode lectura, i ens situem directament a la posici\u00f3 56, que \u00e9s on comen\u00e7a la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia). Posteriorment utilitzem el m\u00e8tode de lectura apropiat per a cada tipus de dada. Copieu el codi seg\u00fcent en un fitxer de kotlin anomenat Exemple_3_2_1_EmpleatsDirecte.kt package exemples import java.io.RandomAccessFile fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats.dat\", \"r\") f.seek(56) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) f.close() } R\u00e0pidament observem una cosa: com sab\u00edem que ens hav\u00edem de situar en la posici\u00f3 56? I si els noms del dos primers hagueren sigut m\u00e9s llargs o m\u00e9s curts? Per a poder solucionar els problemes anteriors, podr\u00edem fer que els noms siguen de llarg\u00e0ria fixa. Les altres dades no donen problemes. Intentarem ara donar sempre una grand\u00e0ria de 10 car\u00e0cters a cada nom (si sospit\u00e0rem que no en tenim prou, haur\u00edem de fer-los m\u00e9s grans). Anem a crear el fitxer Empleats2.dat , i ser\u00e0 exactament igual al de l'anterior apartat, excepte que en el moment de posar els noms (en un array de strings) posem exactament 10 car\u00e0cters, omplint amb blancs si \u00e9s necessari. Evidentment, aquesta no \u00e9s l'\u00fanica manera, per\u00f2 per a les poques dades que tenim, s\u00ed la m\u00e9s r\u00e0pida. val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") La sent\u00e8ncia anterior \u00e9s l'\u00fanica difer\u00e8ncia respecte al programa de creaci\u00f3 d'Empleats.dat de la pregunta anterior, a banda del nom del fitxer, que ara ser\u00e0 Empleat2.dat :. Copieu el seg\u00fcent codi en el fitxer Kotlin: Exemple_3_2_2_Crear_Empleats2.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats2.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Ara que sabem la grand\u00e0ria exacta del nom, podem saber que la informaci\u00f3 de cada empleat \u00e9s: N\u00famero d'empleat (enter) 4 bytes Nom (10 car\u00e0cters + 2 bytes) 10 + 2 bytes Departament (enter) 4 bytes Edat (enter) 4 bytes Sou (doble precisi\u00f3) 8 bytes Total: 32 bytes Sabent que cada registre (la informaci\u00f3 de cada empleat) ocupa 32 bytes, sembla f\u00e0cil anar a un determinat empleat. Per a poder provar-lo b\u00e9, introduirem el n\u00famero d'empleat per teclat, fins introduir 0. Observeu que si s'introdueix 1, hem d'anar a pel primer registre, que est\u00e0 a principi de fitxer. Si introdu\u00efm 2, anem a pel segon, que nom\u00e9s en t\u00e9 un davant, per tant 32 bytes. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_3_Empleats2Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats2.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt () while (num != -1) { f.seek(32 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } El problema ara tamb\u00e9 sembla obvi. Hem assumit que cada car\u00e0cter ocupa un byte. Com es codificar\u00e0 en UTF-8, mentre siguen car\u00e0cters normals aix\u00ed ser\u00e0. Per\u00f2 qu\u00e8 passar\u00e0 quan hi haja un car\u00e0cter accentuat? Que ocupar\u00e0 2 car\u00e0cters. Aix\u00ed, com Cl\u00e0udia t\u00e9 un d'aquestos car\u00e0cters, la cadena no ocupar\u00e0 10+2 = 12 bytes, sin\u00f3 13. Aleshores, si intentem anar al quart empleat, ens donar\u00e0 problemes. La manera de solucionar-lo ser\u00e0 escriure de manera que tots els car\u00e0cters ocupen sempre el mateix. Hi ha un m\u00e8tode que ens ho permet: writeChars . Guardar\u00e0 cada car\u00e0cter amb dos bytes, i no es guardar\u00e0 la llarg\u00e0ria de la cadena. Podem intentar utilitzar-lo per construir el fitxer Empleats3.dat . Nom\u00e9s haurem de substituir la seg\u00fcent sent\u00e8ncia: f.writeChars(noms[i]) a banda del nom del fitxer, clar. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_4_CrearEmpleat3.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats3.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeChars(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Lamentablement la lectura no \u00e9s tan f\u00e0cil. Haurem de llegir exactament 10 car\u00e0cters (podr\u00edem utilitzar algun altre m\u00e8tode, per\u00f2 el que es mostra permet identificar clarament que es llegiran 10 car\u00e0cters). Els anirem acumulant en un String poder mostrar-lo. Recordeu tamb\u00e9 que ara el nom ocupa 20 bytes, que sumats als altres 20 de les altres dades fan un total de 40 bytes per registre. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_2_5_Empleats3Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats3.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt() while (num != -1) { f.seek(40 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) var nom = \"\" for (i in 1..10) nom += f.readChar() println(\"Nom: \" + nom) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- Acc\u00e9s directe a fitxers"},{"location":"AD_T3_Fitxers_de_diferents_formats/2_accs_directe_a_fitxers/#2-acces-directe-a-fitxers","text":"Els exemples de l'apartat anterior ens poden fer reflexionar sobre un altre tipus d'acc\u00e9s als fitxers. De moment tots els accessos que hem fet als fitxers, tant binaris com de car\u00e0cter, ha estat seq\u00fcencials . Aix\u00f2 vol dir que sempre comencem pel principi del fitxer fins que arribem a la informaci\u00f3 que volem, o en la major part dels casos fins el final de fitxer. Per\u00f2, i si volem \u00fanicament una determinada informaci\u00f3? En l'exemple de l'apartat anterior, qu\u00e8 haur\u00edem de fer si volgu\u00e9rem nom\u00e9s la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia)? Doncs haur\u00edem de passar primer per tots els anteriors. Com nom\u00e9s hi ha 2 davant, no sembla molta feina, per\u00f2 \u00e9s f\u00e0cil de veure la dificultat (o millor dit el cost) si el fitxer constara de centenars o milers d'empleats. Suposem un fitxer de 10.000 empleats. Si volem accedir a l'empleat 9.500 haur\u00edem de passar pels 9.499 empleats anteriors, ja que l'acc\u00e9s seq\u00fcencial obliga a comen\u00e7ar pel principi i anar passant fins que trobem la informaci\u00f3. I encara pitjor: i si despr\u00e9s de consultar l'empleat 9.500 ara volem consultar el 9.000? Doncs haur\u00edem de comen\u00e7ar des del principi, perqu\u00e8 ja ens l'hav\u00edem passat. Afortunadament i ha una altra manera d'accedir, un altre tipus d'acc\u00e9s. S'anomena acc\u00e9s directe perqu\u00e8 permetr\u00e0 anar directament a una posici\u00f3 determinada del fitxer. Moltes vegades tamb\u00e9 es diu acc\u00e9s relatiu o acc\u00e9s aleatori , per\u00f2 el funcionament sempre \u00e9s el mateix. I mireu que estem parlant d'acc\u00e9s. Per tant el que canviar\u00e0 no \u00e9s la classe File sin\u00f3 qui permet accedir al contingut, \u00e9s a dir les classes de flux d'informaci\u00f3 (els Streams). Les classes InputStream-OutputStream i Reader-Writer nom\u00e9s permeten l'acc\u00e9s seq\u00fcencial. Per tant per a l'acc\u00e9s directe disposarem d'una altra classe que ens permetr\u00e0 fer totes les operacions, tant de lectura com d'escriptura. T\u00e9 l'avantatge que disposa de molts m\u00e8todes per a poder accedir a la informaci\u00f3. No ens fara falta, per tant, les classes \"decoradores\" que afegeixen funcionalitats. Amb aquesta classe tindrem suficient. RandomAccessFile La classe RandomAccessFile ens permetr\u00e0 accedir de forma directa a un fitxer. No ens far\u00e0 falta, en principi, cap altra classe m\u00e9s. Ens proporcionar\u00e0 tota la funcionalitat necess\u00e0ria. En els constructors aniran 2 par\u00e0metres. El primer far\u00e0 refer\u00e8ncia al fitxer. El segon al mode d'acc\u00e9s: nom\u00e9s lectura ( r ) o lectura-escriptura ( rw ). RandomAccessFile(fitxer: File, mode: String) RandomAccessFile(fitxer: String, mode: String) En el primer cas li especifiquem un File en el primer par\u00e0metre. En el segon un String que correspondr\u00e0 amb el nom del fitxer En ambd\u00f3s casos, el segon par\u00e0metre indicar\u00e0 el mode: \"r\" indica nom\u00e9s lectura \"rw\" indica lectura escriptura A pesar de ser una classe completament diferent de la jerarquia de InputStream-OutpuStream (o Readre-Writer ) implementa m\u00e8todes que es diuen exactament igual que els d'aquelles classes, cosa que fa molt m\u00e9s c\u00f2moda la utilitzaci\u00f3. Els m\u00e8todes m\u00e9s importants s\u00f3n: M\u00e8tode Explicaci\u00f3 M\u00e8tode int read() llig (escriu) un byte (encara aix\u00ed torna o se li passa un enter) void write(int) int read(byte[]) llig (escriu) un s\u00e8rie de bytes, tants com la grand\u00e0ria de l'array (si pot) int write(byte[]) byte readByte() llig (escriu) un byte interpretat com n\u00famero de 8 bits amb signe void writeByte(int) char readChar() llig (escriu) un car\u00e0cter void write(char) int readInt() llig (escriu) un enter (4 bytes) void write(int) short readShort() llig (escriu) un enter xicotet (2 bytes) void write(short) long readLong() llig (escriu) un enter llarg (8 bytes) void write(long) float readFloat() llig (escriu) un n\u00famero real en simple precisi\u00f3 (4 bytes) void write(float) double readDouble() llig (escriu) un n\u00famero real en doble precisi\u00f3 (8 bytes) void write(double) String readUTF() llig (escriu) un cadena de car\u00e0cters (interpretat com UTF-8) void writeUTF() void seek(long) situa el punter en la posici\u00f3, mesurat des del principi del fitxer long length() torna la grand\u00e0ria del fitxer void close() Tanca el flux de l'acc\u00e9s directe En cada lectura, despr\u00e9s de llegir el punter que apunta al fitxer estar\u00e0 situat despr\u00e9s de la dada llegida, siga quina siga la grand\u00e0ria. Anem a veure un exemple utilitzant el fitxer Empleats.dat creat en l'apartat anterior. Obrim l'acc\u00e9s directe \u00fanicament en mode lectura, i ens situem directament a la posici\u00f3 56, que \u00e9s on comen\u00e7a la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia). Posteriorment utilitzem el m\u00e8tode de lectura apropiat per a cada tipus de dada. Copieu el codi seg\u00fcent en un fitxer de kotlin anomenat Exemple_3_2_1_EmpleatsDirecte.kt package exemples import java.io.RandomAccessFile fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats.dat\", \"r\") f.seek(56) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) f.close() } R\u00e0pidament observem una cosa: com sab\u00edem que ens hav\u00edem de situar en la posici\u00f3 56? I si els noms del dos primers hagueren sigut m\u00e9s llargs o m\u00e9s curts? Per a poder solucionar els problemes anteriors, podr\u00edem fer que els noms siguen de llarg\u00e0ria fixa. Les altres dades no donen problemes. Intentarem ara donar sempre una grand\u00e0ria de 10 car\u00e0cters a cada nom (si sospit\u00e0rem que no en tenim prou, haur\u00edem de fer-los m\u00e9s grans). Anem a crear el fitxer Empleats2.dat , i ser\u00e0 exactament igual al de l'anterior apartat, excepte que en el moment de posar els noms (en un array de strings) posem exactament 10 car\u00e0cters, omplint amb blancs si \u00e9s necessari. Evidentment, aquesta no \u00e9s l'\u00fanica manera, per\u00f2 per a les poques dades que tenim, s\u00ed la m\u00e9s r\u00e0pida. val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") La sent\u00e8ncia anterior \u00e9s l'\u00fanica difer\u00e8ncia respecte al programa de creaci\u00f3 d'Empleats.dat de la pregunta anterior, a banda del nom del fitxer, que ara ser\u00e0 Empleat2.dat :. Copieu el seg\u00fcent codi en el fitxer Kotlin: Exemple_3_2_2_Crear_Empleats2.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats2.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Ara que sabem la grand\u00e0ria exacta del nom, podem saber que la informaci\u00f3 de cada empleat \u00e9s: N\u00famero d'empleat (enter) 4 bytes Nom (10 car\u00e0cters + 2 bytes) 10 + 2 bytes Departament (enter) 4 bytes Edat (enter) 4 bytes Sou (doble precisi\u00f3) 8 bytes Total: 32 bytes Sabent que cada registre (la informaci\u00f3 de cada empleat) ocupa 32 bytes, sembla f\u00e0cil anar a un determinat empleat. Per a poder provar-lo b\u00e9, introduirem el n\u00famero d'empleat per teclat, fins introduir 0. Observeu que si s'introdueix 1, hem d'anar a pel primer registre, que est\u00e0 a principi de fitxer. Si introdu\u00efm 2, anem a pel segon, que nom\u00e9s en t\u00e9 un davant, per tant 32 bytes. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_3_Empleats2Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats2.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt () while (num != -1) { f.seek(32 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } El problema ara tamb\u00e9 sembla obvi. Hem assumit que cada car\u00e0cter ocupa un byte. Com es codificar\u00e0 en UTF-8, mentre siguen car\u00e0cters normals aix\u00ed ser\u00e0. Per\u00f2 qu\u00e8 passar\u00e0 quan hi haja un car\u00e0cter accentuat? Que ocupar\u00e0 2 car\u00e0cters. Aix\u00ed, com Cl\u00e0udia t\u00e9 un d'aquestos car\u00e0cters, la cadena no ocupar\u00e0 10+2 = 12 bytes, sin\u00f3 13. Aleshores, si intentem anar al quart empleat, ens donar\u00e0 problemes. La manera de solucionar-lo ser\u00e0 escriure de manera que tots els car\u00e0cters ocupen sempre el mateix. Hi ha un m\u00e8tode que ens ho permet: writeChars . Guardar\u00e0 cada car\u00e0cter amb dos bytes, i no es guardar\u00e0 la llarg\u00e0ria de la cadena. Podem intentar utilitzar-lo per construir el fitxer Empleats3.dat . Nom\u00e9s haurem de substituir la seg\u00fcent sent\u00e8ncia: f.writeChars(noms[i]) a banda del nom del fitxer, clar. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_4_CrearEmpleat3.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats3.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeChars(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Lamentablement la lectura no \u00e9s tan f\u00e0cil. Haurem de llegir exactament 10 car\u00e0cters (podr\u00edem utilitzar algun altre m\u00e8tode, per\u00f2 el que es mostra permet identificar clarament que es llegiran 10 car\u00e0cters). Els anirem acumulant en un String poder mostrar-lo. Recordeu tamb\u00e9 que ara el nom ocupa 20 bytes, que sumats als altres 20 de les altres dades fan un total de 40 bytes per registre. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_2_5_Empleats3Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats3.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt() while (num != -1) { f.seek(40 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) var nom = \"\" for (i in 1..10) nom += f.readChar() println(\"Nom: \" + nom) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- Acc\u00e9s directe a fitxers"},{"location":"AD_T3_Fitxers_de_diferents_formats/3_seriaci_dobjectes/","text":"3.- Seriaci\u00f3 d'objectes La t\u00e8cnica de la seriaci\u00f3 \u00e9s segurament la m\u00e9s senzilla de totes, per\u00f2 tamb\u00e9 a la vegada la m\u00e9s problem\u00e0tica. Java, i per tant tamb\u00e9 Kotlin, disposa d\u2019un sistema gen\u00e8ric de seriaci\u00f3 de qualsevol objecte, un sistema recursiu que es repeteix per cada objecte contingut a la inst\u00e0ncia que s\u2019est\u00e0 seriant. Aquest proc\u00e9s para en arribar als tipus primitius, els quals es guarden com una s\u00e8rie de bytes. A banda dels tipus primitius, Java serialitza tamb\u00e9 molta informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe (el nom de les classe, els noms dels atributs i molta m\u00e9s informaci\u00f3 addicional). Gr\u00e0cies a les metadades es fa possible automatitzar la seriaci\u00f3 de forma gen\u00e8rica amb garanties de recuperar un objecte tal com es va guardar . Lamentablement, aquest \u00e9s un procediment espec\u00edfic de Java . \u00c9s a dir, no \u00e9s possible recuperar els objectes seriats des de Java utilitzant un altre llenguatge. D\u2019altra banda, el fet de guardar metadades pot arribar a comportar tamb\u00e9 problemes, encara que utilitzem sempre el llenguatge Java. La modificaci\u00f3 d\u2019una classe pot fer variar les seues metadades. Aquestes variacions poden donar problemes de recuperaci\u00f3 d\u2019inst\u00e0ncies que hagen estat guardades amb algunes versions anteriors a la modificaci\u00f3, impedint que l\u2019objecte puga ser recuperat. Aquestes consideracions fa que no siga pr\u00e0ctica aquesta t\u00e8cnica per guardar objectes de forma m\u00e9s o menys permanent. En canvi, la seua senzillesa la fa una perfecta candidata per a l\u2019emmagatzematge temporal, per exemple dins de la mateixa sessi\u00f3. Per a que un objecte puga ser seriat cal que la seua classe i tot el seu contingut implementen la interf\u00edcie Serializable . Es tracta d\u2019una interf\u00edcie sense m\u00e8todes, perqu\u00e8 l\u2019\u00fanic objectiu de la interf\u00edcie \u00e9s actuar de marcador per indicar a la m\u00e0quina virtual quines classes es poden seriar i quines no. Totes les classes equivalents als tipus b\u00e0sics ja implementen Serializable. Tamb\u00e9 implementen aquesta interf\u00edcie la classe String i tots els contenidors i els objectes Array. La seriaci\u00f3 de col\u00b7leccions dep\u00e8n en \u00faltim terme dels elements continguts. Si aquestos s\u00f3n seriables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. En cas que la classe de l\u2019objecte que s\u2019intente seriar, o les d\u2019algun dels objectes que continga, no implementaren la interf\u00edcie Serializable, es llan\u00e7aria una excepci\u00f3 de tipus NotSerializableException , impedint l\u2019emmagatzematge. Els Streams ObjectInputStream i ObjectOutputStream s\u00f3n decoradors que afegeixen a qualsevol altre Stream la capacitat de seriar qualsevol objecte Serializable. El stream d'eixida disposar\u00e0 del m\u00e8tode writeObject . i el stream d\u2019entrada, el m\u00e8tode de lectura readObject . El m\u00e8tode readObject nom\u00e9s permet recuperar inst\u00e0ncies que siguen de la mateixa classe que la que es va guardar. En cas contrari, es llan\u00e7aria una excepci\u00f3 de tipus ClassCastExeception . A m\u00e9s, cal que l\u2019aplicaci\u00f3 dispose del codi compilat de la classe; si no f\u00f3ra aix\u00ed, l\u2019excepci\u00f3 llan\u00e7ada seria ClassNotFoundException . Exemple Ens recolzarem en un exemple utilitzat en els anteriors punts, en els empleats. Ara anem a suposar que els empleats s\u00f3n objectes, i intentarem guardar aquestos objectes en un fitxer amb una seriaci\u00f3. El primer pas ser\u00e0 construir la classe Empleat , que contindr\u00e0 la mateixa informaci\u00f3 que en els altres apartats: n\u00famero d'empleat, nom, departament, edat i sou. package exemples import java.io.Serializable class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double): Serializable Anem a intentar construir el fitxer de dades amb els objectes guardats. El flux de dades ser\u00e0 un ObjectOutputStream per a poder escriure ( writeObject ). I observeu com s'ha de recolzar en un OutputStream, que en aquest cas ser\u00e0 d'un fitxer, \u00e9s a dir un FileOutputStream . A cada iteraci\u00f3 del bucle senzillament construirem un objecte de la classe Empleat i l'escriurem al fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_3_1_GuardarObjectes.kt import java.io.ObjectOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = ObjectOutputStream(FileOutputStream(\"Empleats.obj\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) for (i in 0..3){ val e = Empleat (i + 1, noms[i], departaments[i], edats[i], sous[i]) f.writeObject(e) } f.close(); } Nota El fitxer creat, Empleats.obj , evidentment no \u00e9s de text. Tanmateix si l'obrim amb un editor de text podrem veure alguna cosa. - La primera q\u00fcesti\u00f3 \u00e9s que es guarda el nom de la classe amb el nom del paquet davant. exemples.Empleat \u00e9s realment el nom de la classe creada. - Es guarden tamb\u00e9 els noms dels camps. Tot aix\u00f2 s\u00f3n les metadades que hav\u00edem comentat, i que permeten la recuperaci\u00f3 posterior dels objectes guardats - I despr\u00e9s ja podem veure la informaci\u00f3 guardada, on identifiquem els noms dels empleats Per a llegir el fitxer creat, Empleats.obj , utilitzarem el ObjectInputStream per a poder fer readObject . S'ha de basar en un InputStream, que en aquest cas ser\u00e0 un FileInputStream . Lamentablement el m\u00e8tode available() no funcionar\u00e0 correctament, i no ens dir\u00e0 realment els bytes que queden per llegir. El tractament de final de fitxer el farem capturant l'excepci\u00f3 (l'error) d'haver arribat al final i intentat llegir encara: EOFException . La ra\u00f3 \u00e9s que readObject no torna null, a no ser que s'haja introdu\u00eft aquest valor. Per tant muntem un bucle infinit, per\u00f2 capturant amb try ... catch l'error, que \u00e9s quan tancarem el Stream. Copieu el seg\u00fcent codi a un fitxer Kotlin anomenat Exemple_3_3_2_LlegirObjectes.kt package exemples import java.io.ObjectInputStream import java.io.FileInputStream import java.io.EOFException fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream(\"Empleats.obj\")) try { while (true) { val e = f.readObject() as Empleat println(\"N\u00famero: \" + e.num) println(\"Nom: \" + e.nom) println(\"Departament: \" + e.departament) println(\"Edat: \" + e.edat) println(\"Sou: \" + e.sou) println(); } } catch (eof: EOFException) { f.close() } } Nota En realitat, en el fitxer es guarda, a m\u00e9s del nom del paquet i el nom de la classe, l'identificador de la classe: el serialVersionUID , per a poder identificar un\u00edvocament la classe. Aix\u00f2 ens pot donar problemes si intentem compartir la informaci\u00f3 entre nosaltres, ja que perfectament ens pot generar UID diferents. Per a evitar-lo podr\u00edem definir nosaltres aquest serialVersionUID , i aleshores no hi haur\u00e0 problemes per a compartir. Fins i tot serviria per a poder compartir el fitxer d'objectes entre Kotlin i Java package exemples import java.io.Serializable class Empleat (var num: Int,var nom: String,var departament: Int,var edat: Int,var sou: Double): Serializable { companion object { private const val serialVersionUID: Long = 1 } } Si fem aquest canvi en la classe Empleat haurem de tornar a generar el fitxer ( Exemple_3_3_1_GuardarObjectes.kt ) abans de poder consultar-lo ( Exemple_3_3_2_LlegirObjectes.kt ), perqu\u00e8 a tots els efectes seria una classe nova. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Seriaci\u00f3 d'objectes"},{"location":"AD_T3_Fitxers_de_diferents_formats/3_seriaci_dobjectes/#3-seriacio-dobjectes","text":"La t\u00e8cnica de la seriaci\u00f3 \u00e9s segurament la m\u00e9s senzilla de totes, per\u00f2 tamb\u00e9 a la vegada la m\u00e9s problem\u00e0tica. Java, i per tant tamb\u00e9 Kotlin, disposa d\u2019un sistema gen\u00e8ric de seriaci\u00f3 de qualsevol objecte, un sistema recursiu que es repeteix per cada objecte contingut a la inst\u00e0ncia que s\u2019est\u00e0 seriant. Aquest proc\u00e9s para en arribar als tipus primitius, els quals es guarden com una s\u00e8rie de bytes. A banda dels tipus primitius, Java serialitza tamb\u00e9 molta informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe (el nom de les classe, els noms dels atributs i molta m\u00e9s informaci\u00f3 addicional). Gr\u00e0cies a les metadades es fa possible automatitzar la seriaci\u00f3 de forma gen\u00e8rica amb garanties de recuperar un objecte tal com es va guardar . Lamentablement, aquest \u00e9s un procediment espec\u00edfic de Java . \u00c9s a dir, no \u00e9s possible recuperar els objectes seriats des de Java utilitzant un altre llenguatge. D\u2019altra banda, el fet de guardar metadades pot arribar a comportar tamb\u00e9 problemes, encara que utilitzem sempre el llenguatge Java. La modificaci\u00f3 d\u2019una classe pot fer variar les seues metadades. Aquestes variacions poden donar problemes de recuperaci\u00f3 d\u2019inst\u00e0ncies que hagen estat guardades amb algunes versions anteriors a la modificaci\u00f3, impedint que l\u2019objecte puga ser recuperat. Aquestes consideracions fa que no siga pr\u00e0ctica aquesta t\u00e8cnica per guardar objectes de forma m\u00e9s o menys permanent. En canvi, la seua senzillesa la fa una perfecta candidata per a l\u2019emmagatzematge temporal, per exemple dins de la mateixa sessi\u00f3. Per a que un objecte puga ser seriat cal que la seua classe i tot el seu contingut implementen la interf\u00edcie Serializable . Es tracta d\u2019una interf\u00edcie sense m\u00e8todes, perqu\u00e8 l\u2019\u00fanic objectiu de la interf\u00edcie \u00e9s actuar de marcador per indicar a la m\u00e0quina virtual quines classes es poden seriar i quines no. Totes les classes equivalents als tipus b\u00e0sics ja implementen Serializable. Tamb\u00e9 implementen aquesta interf\u00edcie la classe String i tots els contenidors i els objectes Array. La seriaci\u00f3 de col\u00b7leccions dep\u00e8n en \u00faltim terme dels elements continguts. Si aquestos s\u00f3n seriables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. En cas que la classe de l\u2019objecte que s\u2019intente seriar, o les d\u2019algun dels objectes que continga, no implementaren la interf\u00edcie Serializable, es llan\u00e7aria una excepci\u00f3 de tipus NotSerializableException , impedint l\u2019emmagatzematge. Els Streams ObjectInputStream i ObjectOutputStream s\u00f3n decoradors que afegeixen a qualsevol altre Stream la capacitat de seriar qualsevol objecte Serializable. El stream d'eixida disposar\u00e0 del m\u00e8tode writeObject . i el stream d\u2019entrada, el m\u00e8tode de lectura readObject . El m\u00e8tode readObject nom\u00e9s permet recuperar inst\u00e0ncies que siguen de la mateixa classe que la que es va guardar. En cas contrari, es llan\u00e7aria una excepci\u00f3 de tipus ClassCastExeception . A m\u00e9s, cal que l\u2019aplicaci\u00f3 dispose del codi compilat de la classe; si no f\u00f3ra aix\u00ed, l\u2019excepci\u00f3 llan\u00e7ada seria ClassNotFoundException . Exemple Ens recolzarem en un exemple utilitzat en els anteriors punts, en els empleats. Ara anem a suposar que els empleats s\u00f3n objectes, i intentarem guardar aquestos objectes en un fitxer amb una seriaci\u00f3. El primer pas ser\u00e0 construir la classe Empleat , que contindr\u00e0 la mateixa informaci\u00f3 que en els altres apartats: n\u00famero d'empleat, nom, departament, edat i sou. package exemples import java.io.Serializable class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double): Serializable Anem a intentar construir el fitxer de dades amb els objectes guardats. El flux de dades ser\u00e0 un ObjectOutputStream per a poder escriure ( writeObject ). I observeu com s'ha de recolzar en un OutputStream, que en aquest cas ser\u00e0 d'un fitxer, \u00e9s a dir un FileOutputStream . A cada iteraci\u00f3 del bucle senzillament construirem un objecte de la classe Empleat i l'escriurem al fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_3_1_GuardarObjectes.kt import java.io.ObjectOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = ObjectOutputStream(FileOutputStream(\"Empleats.obj\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) for (i in 0..3){ val e = Empleat (i + 1, noms[i], departaments[i], edats[i], sous[i]) f.writeObject(e) } f.close(); } Nota El fitxer creat, Empleats.obj , evidentment no \u00e9s de text. Tanmateix si l'obrim amb un editor de text podrem veure alguna cosa. - La primera q\u00fcesti\u00f3 \u00e9s que es guarda el nom de la classe amb el nom del paquet davant. exemples.Empleat \u00e9s realment el nom de la classe creada. - Es guarden tamb\u00e9 els noms dels camps. Tot aix\u00f2 s\u00f3n les metadades que hav\u00edem comentat, i que permeten la recuperaci\u00f3 posterior dels objectes guardats - I despr\u00e9s ja podem veure la informaci\u00f3 guardada, on identifiquem els noms dels empleats Per a llegir el fitxer creat, Empleats.obj , utilitzarem el ObjectInputStream per a poder fer readObject . S'ha de basar en un InputStream, que en aquest cas ser\u00e0 un FileInputStream . Lamentablement el m\u00e8tode available() no funcionar\u00e0 correctament, i no ens dir\u00e0 realment els bytes que queden per llegir. El tractament de final de fitxer el farem capturant l'excepci\u00f3 (l'error) d'haver arribat al final i intentat llegir encara: EOFException . La ra\u00f3 \u00e9s que readObject no torna null, a no ser que s'haja introdu\u00eft aquest valor. Per tant muntem un bucle infinit, per\u00f2 capturant amb try ... catch l'error, que \u00e9s quan tancarem el Stream. Copieu el seg\u00fcent codi a un fitxer Kotlin anomenat Exemple_3_3_2_LlegirObjectes.kt package exemples import java.io.ObjectInputStream import java.io.FileInputStream import java.io.EOFException fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream(\"Empleats.obj\")) try { while (true) { val e = f.readObject() as Empleat println(\"N\u00famero: \" + e.num) println(\"Nom: \" + e.nom) println(\"Departament: \" + e.departament) println(\"Edat: \" + e.edat) println(\"Sou: \" + e.sou) println(); } } catch (eof: EOFException) { f.close() } } Nota En realitat, en el fitxer es guarda, a m\u00e9s del nom del paquet i el nom de la classe, l'identificador de la classe: el serialVersionUID , per a poder identificar un\u00edvocament la classe. Aix\u00f2 ens pot donar problemes si intentem compartir la informaci\u00f3 entre nosaltres, ja que perfectament ens pot generar UID diferents. Per a evitar-lo podr\u00edem definir nosaltres aquest serialVersionUID , i aleshores no hi haur\u00e0 problemes per a compartir. Fins i tot serviria per a poder compartir el fitxer d'objectes entre Kotlin i Java package exemples import java.io.Serializable class Empleat (var num: Int,var nom: String,var departament: Int,var edat: Int,var sou: Double): Serializable { companion object { private const val serialVersionUID: Long = 1 } } Si fem aquest canvi en la classe Empleat haurem de tornar a generar el fitxer ( Exemple_3_3_1_GuardarObjectes.kt ) abans de poder consultar-lo ( Exemple_3_3_2_LlegirObjectes.kt ), perqu\u00e8 a tots els efectes seria una classe nova. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Seriaci\u00f3 d'objectes"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/","text":"4.3 - Binding VOLUNTARI El Binding \u00e9s una t\u00e8cnica que consisteix en generar (i vincular) autom\u00e0ticament classes de Java amb formats espec\u00edfics d\u2019emmagatzematge, que en el cas que ens interessa seran documents XML. D'aquesta manera, cada etiqueta o atribut de XML es correspondr\u00e0 amb una propietat d'una determinada classe. Aix\u00f2 s'anomena mapar , perqu\u00e8 \u00e9s fer una esp\u00e8cie de mapa per a indicar que una etiqueta (o atribut) es correspon a una propietat de la classe. Per a poder fer la aquesta correspond\u00e8ncia o mapatge de forma correcta entre les classes de Java i el document XML, far\u00e0 falta una miqueta d'ajuda o aclaracions, perqu\u00e8 com ja hem vist la mateixa informaci\u00f3 es pot guardar de m\u00e9s d'una manera en XML (utilitzant o no atributs, ...). En Java existeixen diverses biblioteques per gestionar el binding , com per exemple JAXB , JiBX , XMLBinding , etc. Des de la versi\u00f3 6.0 s\u2019ha incorporat en el JDK est\u00e0ndard JAXB ( Java Architecture for XML Binding ), una potent biblioteca. JAXB utilitza Anotacions per aconseguir la informaci\u00f3 extra necess\u00e0ria per mapar el binding . Les Anotacions s\u00f3n unes classes de Java molt especials. Serveixen per associar informaci\u00f3 i funcionalitat als objectes sense interferir en l\u2019estructura del model de dades. Abans d'apar\u00e9ixer les Anotacions era necessari fer servir l\u2019her\u00e8ncia per poder afegir funcionalitat a una classe sense haver de codificar-la, per\u00f2 ho complicava molt. Si, per contra, fem servir Anotacions , els objectes disposaran d\u2019informaci\u00f3 o de funcionalitat extra sense que el model de dades quede modificat, ja que les Anotacions no s\u00f3n visibles des dels objectes. Les Anotacions poden associar-se a un paquet, a una classe, a un atribut o fins i tot a un par\u00e0metre. Aquestes classes especials es declaren en el codi de l\u2019aplicaci\u00f3 posant el s\u00edmbol @ davant del nom de l\u2019 Anotaci\u00f3 . Quan el compilador de Java detecta una Anotaci\u00f3 crea una inst\u00e0ncia i la injecta dins l\u2019element afectat (paquet, classe, m\u00e8tode, atribut, etc.). Aix\u00f2 fa que aquestes no apareguen com a atributs o m\u00e8todes propis de l\u2019objecte, i per aix\u00f2 diem que no interacciona amb el model de dades, per\u00f2 les aplicacions que ho necessiten poden obtenir la inst\u00e0ncia injectada i fer-la servir. Nosaltres en aquest curs, \u00fanicament aspirarem a veure com realment a partir d'un esquema XML que valida una s\u00e8rie de documents XML, podem generar c\u00f2modament les classes en Java, que permetrien guardar objectes d'aquestes classes. Una vegada constru\u00efdes les classes es podria utilitzar JAXB per a transferir informaci\u00f3 dels fitxers XML (v\u00e0lids per a l'esquema) cap als objectes o a l'inrev\u00e8s. La generaci\u00f3 de les classes \u00e9s extremadament senzilla a partir d'una determinada versi\u00f3 d'Eclipse. Com hem comentat la llibreria JAXB est\u00e0 present des de la versi\u00f3 6.0 del JDK SE (Standard Edition). Per\u00f2 per a la generaci\u00f3 c\u00f2moda ens fan falta eines (tools) proporcionades en la JDK EE 7.0 (Enterprise Edition). Si tenim aquesta plataforma podrem utilitzar la versi\u00f3 2.2 de JAXB. Nota Lamentablement, a partir de la versi\u00f3 de Java JDK EE 8.0 comen\u00e7a a estar en des\u00fas el JAXB ( deprecated ), i a la versi\u00f3 11 ja no est\u00e0 implementat. Per tant, per a poder provar el que va a continuaci\u00f3 \u00e9s preferible que utilitzeu una versi\u00f3 antiga de Java (Java 7 o Java 8). Si no la teniu instal\u00b7lada, no valdr\u00e0 la pena que feu aquest exemple. Per aix\u00f2 aquesta pregunta \u00e9s volunt\u00e0ria . Evidentment, es pot aconseguir que funcione en Java 11, a pesar que no est\u00e0 implementat JAXB, per\u00f2 \u00e9s a costa d'assenyalar que agafe configuracions anteriors, o important tots els jar necessaris, baixant-los pr\u00e8viament. No valdr\u00e0 la pena, perqu\u00e8 no l'utilitzarem Ens recolzarem en un exemple utilitzat l'any passat. El seg\u00fcent esquema (.xsd) valida documents com el de l'oferta de vehicles, vist en apartats anteriors. Podeu guardar-lo amb el nom cotxes.xsd <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:simpleType name=\"Combust\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"gasolina\"/> <xs:enumeration value=\"diesel\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"Matr\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[0-9]{4}[A-Z]{3}\"/> </xs:restriction> </xs:simpleType> <xs:element name=\"oferta\"> <xs:complexType> <xs:sequence> <xs:element name=\"vehiculo\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name=\"marca\" type=\"xs:string\"/> <xs:element name=\"modelo\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"color\" type=\"xs:string\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"motor\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"combustible\" type=\"Combust\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"matricula\" type=\"Matr\"/> <xs:element name=\"kilometros\" type=\"xs:integer\"/> <xs:element name=\"precio_inicial\" type=\"xs:integer\"/> <xs:element name=\"precio_oferta\" type=\"xs:integer\"/> <xs:element name=\"extra\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"valor\" type=\"xs:integer\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"foto\" maxOccurs=\"unbounded\" type=\"xs:string\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Per exemple, el seg\u00fcent document XML cotxes.xml (el vist en els apartats anteriors) \u00e9s v\u00e0lid segons l'anterior esquema. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Per\u00f2 per a generar les classes el que ens fa falta \u00e9s el de l'esquema, cotxes.xsd . En el seg\u00fcent v\u00eddeo es veu com generar les classes a partir de l'esquema. No cal que ho feu si no voleu, perqu\u00e8 es mostra a nivell \u00fanicament il\u00b7lustratiu de com es generen les classes, per\u00f2 no ho utilitzarem despr\u00e9s I aquest \u00e9s el programa per provar que es pot accedir que es comenta en el v\u00eddeo: package classesJAXB import java.io.File import javax.xml.bind.JAXBContext import javax.xml.bind.JAXBException fun main() { try { val file = File(\"cotxes.xml\") val jaxbContext = JAXBContext.newInstance(Oferta::class.java) val jaxbUnmarshaller = jaxbContext.createUnmarshaller() val oferta = jaxbUnmarshaller.unmarshal(file) as Oferta for (v in oferta.getVehiculo()) println(v.getMatricula() + \" (\" + v.getMarca() + \")\") } catch (e: JAXBException) { e.printStackTrace() } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.3 - Binding"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/#43-binding","text":"","title":"4.3 - Binding"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/#voluntari","text":"El Binding \u00e9s una t\u00e8cnica que consisteix en generar (i vincular) autom\u00e0ticament classes de Java amb formats espec\u00edfics d\u2019emmagatzematge, que en el cas que ens interessa seran documents XML. D'aquesta manera, cada etiqueta o atribut de XML es correspondr\u00e0 amb una propietat d'una determinada classe. Aix\u00f2 s'anomena mapar , perqu\u00e8 \u00e9s fer una esp\u00e8cie de mapa per a indicar que una etiqueta (o atribut) es correspon a una propietat de la classe. Per a poder fer la aquesta correspond\u00e8ncia o mapatge de forma correcta entre les classes de Java i el document XML, far\u00e0 falta una miqueta d'ajuda o aclaracions, perqu\u00e8 com ja hem vist la mateixa informaci\u00f3 es pot guardar de m\u00e9s d'una manera en XML (utilitzant o no atributs, ...). En Java existeixen diverses biblioteques per gestionar el binding , com per exemple JAXB , JiBX , XMLBinding , etc. Des de la versi\u00f3 6.0 s\u2019ha incorporat en el JDK est\u00e0ndard JAXB ( Java Architecture for XML Binding ), una potent biblioteca. JAXB utilitza Anotacions per aconseguir la informaci\u00f3 extra necess\u00e0ria per mapar el binding . Les Anotacions s\u00f3n unes classes de Java molt especials. Serveixen per associar informaci\u00f3 i funcionalitat als objectes sense interferir en l\u2019estructura del model de dades. Abans d'apar\u00e9ixer les Anotacions era necessari fer servir l\u2019her\u00e8ncia per poder afegir funcionalitat a una classe sense haver de codificar-la, per\u00f2 ho complicava molt. Si, per contra, fem servir Anotacions , els objectes disposaran d\u2019informaci\u00f3 o de funcionalitat extra sense que el model de dades quede modificat, ja que les Anotacions no s\u00f3n visibles des dels objectes. Les Anotacions poden associar-se a un paquet, a una classe, a un atribut o fins i tot a un par\u00e0metre. Aquestes classes especials es declaren en el codi de l\u2019aplicaci\u00f3 posant el s\u00edmbol @ davant del nom de l\u2019 Anotaci\u00f3 . Quan el compilador de Java detecta una Anotaci\u00f3 crea una inst\u00e0ncia i la injecta dins l\u2019element afectat (paquet, classe, m\u00e8tode, atribut, etc.). Aix\u00f2 fa que aquestes no apareguen com a atributs o m\u00e8todes propis de l\u2019objecte, i per aix\u00f2 diem que no interacciona amb el model de dades, per\u00f2 les aplicacions que ho necessiten poden obtenir la inst\u00e0ncia injectada i fer-la servir. Nosaltres en aquest curs, \u00fanicament aspirarem a veure com realment a partir d'un esquema XML que valida una s\u00e8rie de documents XML, podem generar c\u00f2modament les classes en Java, que permetrien guardar objectes d'aquestes classes. Una vegada constru\u00efdes les classes es podria utilitzar JAXB per a transferir informaci\u00f3 dels fitxers XML (v\u00e0lids per a l'esquema) cap als objectes o a l'inrev\u00e8s. La generaci\u00f3 de les classes \u00e9s extremadament senzilla a partir d'una determinada versi\u00f3 d'Eclipse. Com hem comentat la llibreria JAXB est\u00e0 present des de la versi\u00f3 6.0 del JDK SE (Standard Edition). Per\u00f2 per a la generaci\u00f3 c\u00f2moda ens fan falta eines (tools) proporcionades en la JDK EE 7.0 (Enterprise Edition). Si tenim aquesta plataforma podrem utilitzar la versi\u00f3 2.2 de JAXB. Nota Lamentablement, a partir de la versi\u00f3 de Java JDK EE 8.0 comen\u00e7a a estar en des\u00fas el JAXB ( deprecated ), i a la versi\u00f3 11 ja no est\u00e0 implementat. Per tant, per a poder provar el que va a continuaci\u00f3 \u00e9s preferible que utilitzeu una versi\u00f3 antiga de Java (Java 7 o Java 8). Si no la teniu instal\u00b7lada, no valdr\u00e0 la pena que feu aquest exemple. Per aix\u00f2 aquesta pregunta \u00e9s volunt\u00e0ria . Evidentment, es pot aconseguir que funcione en Java 11, a pesar que no est\u00e0 implementat JAXB, per\u00f2 \u00e9s a costa d'assenyalar que agafe configuracions anteriors, o important tots els jar necessaris, baixant-los pr\u00e8viament. No valdr\u00e0 la pena, perqu\u00e8 no l'utilitzarem Ens recolzarem en un exemple utilitzat l'any passat. El seg\u00fcent esquema (.xsd) valida documents com el de l'oferta de vehicles, vist en apartats anteriors. Podeu guardar-lo amb el nom cotxes.xsd <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:simpleType name=\"Combust\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"gasolina\"/> <xs:enumeration value=\"diesel\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"Matr\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[0-9]{4}[A-Z]{3}\"/> </xs:restriction> </xs:simpleType> <xs:element name=\"oferta\"> <xs:complexType> <xs:sequence> <xs:element name=\"vehiculo\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name=\"marca\" type=\"xs:string\"/> <xs:element name=\"modelo\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"color\" type=\"xs:string\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"motor\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"combustible\" type=\"Combust\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"matricula\" type=\"Matr\"/> <xs:element name=\"kilometros\" type=\"xs:integer\"/> <xs:element name=\"precio_inicial\" type=\"xs:integer\"/> <xs:element name=\"precio_oferta\" type=\"xs:integer\"/> <xs:element name=\"extra\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"valor\" type=\"xs:integer\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"foto\" maxOccurs=\"unbounded\" type=\"xs:string\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Per exemple, el seg\u00fcent document XML cotxes.xml (el vist en els apartats anteriors) \u00e9s v\u00e0lid segons l'anterior esquema. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Per\u00f2 per a generar les classes el que ens fa falta \u00e9s el de l'esquema, cotxes.xsd . En el seg\u00fcent v\u00eddeo es veu com generar les classes a partir de l'esquema. No cal que ho feu si no voleu, perqu\u00e8 es mostra a nivell \u00fanicament il\u00b7lustratiu de com es generen les classes, per\u00f2 no ho utilitzarem despr\u00e9s I aquest \u00e9s el programa per provar que es pot accedir que es comenta en el v\u00eddeo: package classesJAXB import java.io.File import javax.xml.bind.JAXBContext import javax.xml.bind.JAXBException fun main() { try { val file = File(\"cotxes.xml\") val jaxbContext = JAXBContext.newInstance(Oferta::class.java) val jaxbUnmarshaller = jaxbContext.createUnmarshaller() val oferta = jaxbUnmarshaller.unmarshal(file) as Oferta for (v in oferta.getVehiculo()) println(v.getMatricula() + \" (\" + v.getMarca() + \")\") } catch (e: JAXBException) { e.printStackTrace() } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"VOLUNTARI"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/","text":"4.- Documents XML Hem vist que la manera m\u00e9s c\u00f2moda de guardar objectes \u00e9s amb la seriaci\u00f3, per mig del ObjectInputStream i ObjectOutputStream , per\u00f2 que fora de Java o de Kotlin no \u00e9s possible l'acc\u00e9s a aquestes dades. I com hav\u00edem comentat en l'\u00faltima nota de la pregunta anterior, tamb\u00e9 dins de Kotlin podem tenir problemes, perqu\u00e8 el nom de la classe amb el nom del paquet es guarda en el fitxer com a metades, i en un altre programa haurem de tenir la classe creada en un paquet amb el mateix nom, sin\u00f3 no es podran recuperar les dades. I fins i tot dient-se exactament igual, poden haver problemes si el serialVersionUID de la classe no \u00e9s el mateix. Tamb\u00e9 hem vist que per a guardar dades individuals de diferents tipus ens van molt b\u00e9 les classes DataInputStream i DataOutputStream , per\u00f2 haurem de saber molt b\u00e9 l'ordre i tipus de dades que estan guardades, sin\u00f3, no les podrem recuperar. I no entrem ja en la possibilitat que diferents Sistemes Operatius representen la informaci\u00f3 de forma diferent (per exemple, hi ha Sistemes Operatius que representen els n\u00fameros amb BCD i altres que utilitzen complement a 2). Per tant, quan vulguem guardar dades que puguen ser llegides per aplicacions fetes en diferents llenguatges i/o executades en diferents plataformes, ens far\u00e0 falta un format est\u00e0ndar que tots el puguen entendre i recon\u00e9ixer, i millor si \u00e9s autoexplicatiu com \u00e9s el cas dels llenguatges de marques . El llenguatge de marques m\u00e9s conegut i m\u00e9s utilitzat \u00e9s el XML ( eXtensible Markup Language ) Els documents XML aconsegueixen estructurar la informaci\u00f3 intercalant unes marques anomenades etiquetes, cada etiqueta amb un principi i un final, i que poden anar unes dins d'unes altres, i tamb\u00e9 contenir informaci\u00f3 de text. D\u2019aquesta manera, es podr\u00e0 subdividir la informaci\u00f3 estructurant-la de forma que puga ser f\u00e0cilment interpretada. Tota la informaci\u00f3 ser\u00e0 de text, i per tant no hi haur\u00e0 el problema mencionat abans de representar les dades de diferent manera. Qualsevol dada, ja siga num\u00e8rica, booleana o com siga, es posar\u00e0 en mode text, i per tant sempre es podr\u00e0 llegir i interpretar correctament tota la informaci\u00f3 continguda en un fitxer XML. \u00c9s cert que els car\u00e0cters es poden escriure utilitzant diferents sistemes de codificaci\u00f3, per\u00f2 XML ofereix diverses t\u00e8cniques per evitar que aix\u00f2 siga un problema, com per exemple, incloent a la cap\u00e7alera del fitxer quina codificaci\u00f3 s\u2019ha fet servir en el moment de guardar-lo. Amb les etiquetes, XML aconsegueix estructurar qualsevol tipus d\u2019informaci\u00f3 jer\u00e0rquica. Es pot establir certa similitud entre la forma com la informaci\u00f3 es guarda en els objectes d\u2019una aplicaci\u00f3 i la forma com es guardaria en un document XML. La informaci\u00f3, en les aplicacions orientades a objectes, s\u2019estructura, agrupa i jerarquitza en classes, i en els documents XML s\u2019estructura, organitza i jerarquitza en etiquetes contingudes unes dins les altres i atributs de les etiquetes. Imaginem que volem representar les dades dels empleats com els de l\u2019aparat anterior utilitzant un format XML. No existeix una \u00fanica soluci\u00f3, per\u00f2 \u00e9s obligatori que totes respecten la jerarquia del model. Un possible format podria ser el seg\u00fcent: <empresa> <empleat> <num>1</num> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat> <num>2</num> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat> <num>3</num> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat> <num>4</num> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empresa> Per\u00f2 aquesta tamb\u00e9 podria ser una manera de representar-lo: <empresa> <empleat num='1' nom='Andreu' departament='10' edat='32' sou='1000.0'/> <empleat num='2' nom='Bernat' departament='20' edat='28' sou='1200.0'/> <empleat num='3' nom='Cl\u00e0udia' departament='10' edat='26' sou='1100.0'/> <empleat num='4' nom='Dami\u00e0' departament='10' edat='40' sou='1500.0'/> </empresa> I podem imaginar moltes altres solucions, combinant considerant com atributs o subetiquetes les diferents caracter\u00edstiques dels empleats que volem guardar. Aquest seria el problema principal del XML, les m\u00faltiples solucions. Per\u00f2 tamb\u00e9 \u00e9s veritat que totes elles s\u00f3n f\u00e0cils d'entendre. 4.1 - Parser o analitzador XML Un Parser XML \u00e9s una classe que ens permet analitzar i classificar el contingut d\u2019un arxiu XML extraient la informaci\u00f3 continguda en cada una de les etiquetes, i relacionar-la d\u2019acord amb la seua posici\u00f3 dins la jerarquia. Hi ha dos tipus d'analitzadors depenent de la manera de funcionar. Analitzadors seq\u00fcencials Els analitzadors seq\u00fcencials permeten extreure el contingut a mida que es van descobrint les etiquetes d\u2019obertura i tancament. Tamb\u00e9 s\u2019anomenen analitzadors sint\u00e0ctics . S\u00f3n analitzadors molt r\u00e0pids, per\u00f2 presenten el problema que cada vegada que es necessita accedir a una part del contingut, s'ha de rellegir tot el document de dalt a baix. En Java, l\u2019analitzador sint\u00e0ctic m\u00e9s popular s\u2019anomena SAX , que vol dir Simple API for XML . \u00c9s una analitzador molt utilitzat en diverses biblioteques de tractament de dades XML, per\u00f2 no sol utilitzar-se en aplicacions finals, pel problema abans comentat d'haver de llegir-se tot el document XML a cada consulta. Per aquesta ra\u00f3 no els veurem en aquest curs. Analitzadors jer\u00e0rquics Generalment, les aplicacions finals que han de treballar amb dades XML solen utilitzar analitzadors jer\u00e0rquics. Els analitzadors jer\u00e0rquics guarden totes les dades del document XML en mem\u00f2ria dins una estructura jer\u00e0rquica, a mida que van analitzant el seu contingut. I per aix\u00f2 s\u00f3n ideals per a aplicacions que requereixen una consulta cont\u00ednua de les dades. El format de l\u2019estructura on es guarda la informaci\u00f3 en mem\u00f2ria ha estat especificat per l\u2019organisme internacional W3C (World Wide Web Consortium) i es coneix com a DOM ( Document Object Model ). \u00c9s una estructura que HTML i javascript han popularitzat molt i es tracta d\u2019una especificaci\u00f3 que Java materialitza en forma d\u2019interf\u00edcies. La principal s\u2019anomena Document i representa tot un document XML. En tractar-se d\u2019una interf\u00edcie, pot ser implementada per diverses classes. L\u2019est\u00e0ndard W3C defineix la classe DocumentBuilder (constructor de documents) per a poder crear estructures DOM a partir d\u2019un XML. Aquesta classe DocumentBuilder \u00e9s una classe abstracta, i per tal que es puga adaptar a les diferents plataformes, pot necessitar fonts de dades o requeriments diversos. Recordeu que les classes abstractes no es poden instanciar de forma directa. Per aquest motiu, el consorci W3 especifica tamb\u00e9 la classe DocumentBuilderFactory , \u00e9s a dir, el fabricador de DocumentBuilder . Les llibreries des d'on importarem les classes comentades s\u00f3n: DocumentBuilderFactory i DocumentBuilder les importarem de la llibreria javax.xml.parsers. * Document l'importarem de org.w3c.dom. * Hem de cuidar sobretot aquesta \u00faltima importaci\u00f3, perqu\u00e8 per defecte Java ens ofereix moltes llibreries des d'on importar Document . I si no la importem de la llibreria correcta, evidentment despr\u00e9s tindrem errors. Les instruccions necess\u00e0ries per llegir un fitxer XML i crear un objecte Document serien les seg\u00fcents: import java.io.FileInputStream import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val dbFactory = DocumentBuilderFactory.newInstance() val dBuilder = dbFactory.newDocumentBuilder() val doc = dBuilder.parse(File(\u201cfitxer.xml\u201d)) Tornem a insistir en la necessitat d'importar Document de la llibreria org.w3c.dom. * Anem a basar-nos en un exemple per poder veure a poc a poc la manera d'utilitzar el parser. \u00c9s un exemple que possiblement es va veure en primer, en el m\u00f2dul de Llenguatge de Marques. Suposarem que est\u00e0 en el fitxer cotxes.xml , i que est\u00e0 en el directori del projecte on farem les proves. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> El primer que farem ser\u00e0 intentar connectar amb aquest fitxer, per\u00f2 d'una forma un poc m\u00e9s redu\u00efda que abans, sense definir objectes del DocumentBuilderFactory ni DocumentBuilder . Tampoc ens caldr\u00e0 definir- nos el File ( FileInputStream ) ja que el m\u00e8tode parse tamb\u00e9 agafa un String com a par\u00e0metre: import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") Per\u00f2, i si el proc\u00e9s que necessitem \u00e9s l'invers? \u00c9s a dir, i si el que volem \u00e9s guardar una estructura DOM en un fitxer XML? En aquest cas el que haurem de fer ser\u00e0 construir un document buit , anar posant els elements i atributs (amb els seus valors) d'alguna manera, i posteriorment guardar-lo en un fitxer. Deixem per a un poc m\u00e9s avant com anar construint els nodes del document i centrem-nos en el fet de crear el document buit i guardar-lo en un fitxer. Podem construir un document nou a partir del DocumentBuilder , utilitzant el m\u00e8tode newDocument() : import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc1 = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument() Per a escriure la informaci\u00f3 continguda al DOM a un fitxer, es pot fer utilitzant una altra utilitat de Java anomenada Transformer . Es tracta d\u2019una utilitat que permet realitzar f\u00e0cilment conversions entre diferents representacions d\u2019informaci\u00f3 jer\u00e0rquica. \u00c9s capa\u00e7, per exemple, de passar la informaci\u00f3 continguda en un objecte Document a un fitxer de text en format XML . Tamb\u00e9 seria capa\u00e7 de fer l\u2019operaci\u00f3 inversa, per\u00f2 no val la pena perqu\u00e8 el mateix DocumentBuilder ja s\u2019encarrega d\u2019aix\u00f2. Transformer \u00e9s tamb\u00e9 una classe abstracta i requereix d\u2019una factory per poder ser instanciada. La classe Transformer pot treballar amb multitud de contenidors d\u2019informaci\u00f3 perqu\u00e8 en realitat treballa amb un parell de tipus adaptadors (classes que fan compatibles jerarquies diferents) que s\u2019anomenen Source i Result . Les classes que implementen aquestes interf\u00edcies s\u2019encarregaran de fer compatible un tipus de contenidor espec\u00edfic al requeriment de la classe Transformer . Aix\u00ed, disposem de les classes DOMSource , SAXSource o StreamSource com a adaptadors del contenidor de la font d\u2019informaci\u00f3 (DOM, SAX o Stream respectivament). DOMResult , SAXResult o StreamResult s\u00f3n els adaptadors equivalents del contenidor dest\u00ed. A nosaltres ara, com que volem passar un document DOM a un fitxer, ens convindr\u00e0 un DOMSource i un StreamResult El codi b\u00e0sic per realitzar una transformaci\u00f3 de DOM a fitxer de text XML seria el seg\u00fcent: val trans = TransformerFactory.newInstance().newTransformer() val source = DOMSource(doc) val result = StreamResult(file) trans.transform(source, result) De tota manera, veurem m\u00e9s avant un exemple on ens guardarem una estructura DOM en un fitxer XML. 4.2 - L'estructura DOM L\u2019estructura DOM pren la forma d\u2019un arbre, on cada part del XML es trobar\u00e0 representada en forma de node . En funci\u00f3 de la posici\u00f3 en el document XML, parlarem de diferents tipus de nodes: El node principal que representa tot el XML sencer s\u2019anomena Document. Les diverses etiquetes, inclosa l\u2019etiqueta arrel, es coneixen com a nodes Element . El contingut d\u2019una etiqueta de tipus text, ser\u00e0 un node de tipus TextElement Els atributs seran nodes de tipus Attribute . En l'exemple de la p\u00e0gina anterior, el fitxer cotxes.xml , que t\u00e9 aquesta estructura: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Veient-lo com una estructura jer\u00e0rquica ens quedaria aix\u00ed: On: El node Document \u00e9s el rombe Els nodes Element s\u00f3n els cercles Els nodes TextElement s\u00f3n els rect\u00e0ngles de fons taronja. Els nodes Attribute s\u00f3n els rect\u00e0ngles arrodonits de color groc Cada node espec\u00edfic disposa de m\u00e8todes per accedir a les seues dades concretes (nom, valor, nodes fills, node pare, etc.). \u00c9s a dir, que el node serveix per a situar-se en una determinada posici\u00f3 (element, atribut, element de text, ...). Tindr\u00e0 uns m\u00e8todes, sobretot per a navegar, encara que tamb\u00e9 alguns per a traure el contingut. Element \u00e9s un classe derivada de Node (per tant hereta tots els seus m\u00e8todes), i proporciona algunes coses m\u00e9s, sobretot per a accedir c\u00f2modament a les seues parts. Mirem els m\u00e8todes m\u00e9s importants, tant de Node com de Element i Document M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 String getNodeName() torna el nom d'aquest node short getNodeType() torna el tipus d'aquest node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, ... String getNodeValue() torna el valor del node, si en t\u00e9 NodeList getChildNodes() torna una llista amb els nodes fills Node getFirstChild() torna el primer fill Node getLastChild() torna l'\u00faltim fill NamedNodeMap getAttributes() torna una llista amb els atributs del node (null si no en t\u00e9 cap) Node getParentNode() torna el pare String getTextContent() torna el text contingut en l'element i el de tots els seus descendents, si en t\u00e9 boolean hasChildNodes() torna cert si el node t\u00e9 algun fill boolean hasAttributes() torna cert si el node t\u00e9 algun atribut M\u00e8todes d' ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 String getAttribute( String nom ) torna el valor de l'atribut que t\u00e9 aquest nom NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom boolean hasAttribute( String nom ) torna cert si l'element t\u00e9 aquest atribut M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element getDocumentElement() torna l'element arrel del document NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom Nota Kotlin ens \"suggerir\u00e0\" canviar molts dels m\u00e8todes anteriors per propietats. Per exemple per al m\u00e8tode getNodeName() ens suggerir\u00e0 de canviar-lo per la propietat nodeName . Podeu substituir per la propietat o deixar el m\u00e8tode, el que vulgueu. Sempre que tinguem una llista de nodes , podrem accedir a cadascun dels membres de la llista amb el m\u00e8tode item especificant el n\u00famero d'ordre. Aix\u00ed, si volem accedir al primer posarem item(0) Posterioment posarem els m\u00e8todes que serveixen per anar posant contingut a un document: crear fills, crear atributs, posar contingut, ... El DOM resultant obtingut des d\u2019un XML acaba sent un c\u00f2pia exacta del fitxer, per\u00f2 disposat de diferent manera. Tant al XML com al DOM hi haur\u00e0 informaci\u00f3 no visible, com ara els retorns de carro , que cal tenir en compte per tal de saber processar correctament el contingut i evitar sorpreses poc comprensibles. Per a il\u00b7lustrar el problema que poden suposar els retorn de carro , imaginem que disposem d\u2019un document XML amb el seg\u00fcent contingut: <table> <tr> <td> </td> <td> </td> </tr> </table> Veurem m\u00e9s clar si representem els retorn de carro en el mateix document: <table>\u00b6 <tr>\u00b6 <td> </td>\u00b6 <td> </td>\u00b6 </tr>\u00b6 </table> A la seg\u00fcent figura es mostra la representaci\u00f3 que tindria l\u2019objecte DOM, un vegada estiga ja copiat en mem\u00f2ria. Observeu com l\u2019element table tindr\u00e0 tres fills. En un es guardar\u00e0 el retorn de carro que situa l\u2019etiqueta < tr > a la seg\u00fcent l\u00ednia, en el segon trobarem l\u2019etiqueta < tr > , i en el tercer el retorn de carro que fa que </ table > estiga en la l\u00ednia de baix. El mateix passa amb els fills de < tr > , abans i despr\u00e9s de cada node < td > trobarem un retorn de carro . En canvi, si hagu\u00e9rem partit d'un XML equivalent per\u00f2 sense retorns de carro, el resultat hauria estat diferent: <table><tr><td></td><td></td></tr></table> L\u2019abs\u00e8ncia de retorns de carro en el fitxer implica tamb\u00e9 l\u2019abs\u00e8ncia de nodes contenint els retorns de carro en l\u2019estructura DOM. Un altre aspecte a tenir en compte \u00e9s que el contingut de les etiquetes es plasma en el DOM com un node fill de l\u2019etiqueta contenidora. \u00c9s a dir, per obtenir el text d\u2019una etiqueta cal obtenir el primer fill d\u2019aquesta. <aaa> <bbb> text de l'etiqueta bbb </bbb> </aaa> 4.2.1 Lectura Anem a fer proves per poder comprovar el funcionament. Ens basem en el document cotxes.xml esmentat en la pregunta 4.1 Nota Aneu amb compte, perqu\u00e8 en el document cotxes.xml davant de la primera etiqueta no pot haver ni retorn de carro ni un espai en blanc ni res. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_1_XMLMirar.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>){ val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") println(doc.getNodeName()) // torna el nom del document. No \u00e9s l'element arrel. Ens dir\u00e0 #document val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel println(arrel.getNodeName()) // torna el nom de l'element. Ens dir\u00e0 oferta println(arrel.getNodeValue()) // torna el valor de l'element. Com \u00e9s un element que cont\u00e9 altres elements, el valor \u00e9s null } Tal i com est\u00e0 documentat, aquesta ser\u00e0 l'eixida: #document oferta null Anem a comprovar ara que el primer fill de oferta no \u00e9s vehiculo sin\u00f3 el retorn de carro. Els element vehiculo s\u00f3n el segon i el quart (\u00edndex 1 i 3). Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_2_XMLMirar2.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val fills = arrel.getChildNodes() println(fills.item(0).getNodeName()) // el primer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(1).getNodeName()) // el segon fill s\u00ed que \u00e9s vehiculo println(fills.item(2).getNodeName()) // el tercer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(3).getNodeName()) // el quart fill s\u00ed que \u00e9s vehiculo println(fills.item(4).getNodeName()) // el cinqu\u00e8 fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(5).getNodeName()) // no existeix el sis\u00e8 fill. Donar\u00e0 error } Observeu que en l'\u00faltima sent\u00e8ncia estem provocant un error: #text vehiculo #text vehiculo #text Exception in thread \"main\" java.lang.NullPointerException at exemples.Exemple_4_2_MirarXML2.main(Exemple_4_2_MirarXML2.kt:15) Per tant, hem d'anar molt en compte amb els retorns de carro . Per a poder esquivar els retorn de carro podr\u00edem mirar el tipus de cada node ( getNodeType() ), menysprear els els de tipus TEXT_NODE i considerar nom\u00e9s els de tipus ELEMENT_NODE . Per\u00f2 normalment l'acc\u00e9s que farem ser\u00e0 un poc m\u00e9s directe i m\u00e9s f\u00e0cil. Agafarem la llista de tots els element que tinguen un determinat nom amb getElementsByTagName( nom ) . Evidentment en la llista no estaran els retorns de carro i aix\u00ed no tindrem problemes amb ells. En el seg\u00fcent exemple recorrerem tots els element vehiculo . De cadascun agafarem el contingut dels elements marca i matricula . Tamb\u00e9 agafem el contingut de l'atribut combustible de l'element motor . Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_3_XMLMirarCotxes.kt : package exemples import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Element fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val llista = arrel.getElementsByTagName(\"vehiculo\") for (i in 0 until llista.getLength()) { val el = llista.item(i) as Element println(el.getNodeName() + \" \" + (i + 1)) println(\"Marca: \" + el.getElementsByTagName(\"marca\").item(0).getChildNodes().item(0).getNodeValue()) println(\"Matr\u00edcula: \" + el.getElementsByTagName(\"matricula\").item(0).getFirstChild().getNodeValue()) println(\"Motor: \" + el.getElementsByTagName(\"motor\").item(0).getTextContent()) println(\"Combustible: \" + el.getElementsByTagName(\"motor\").item(0).getAttributes().item(0).getNodeValue()) val m = el . getElementsByTagName (\"motor\").item(0) as Element println(\"Combustible: \" + m.getAttribute(\"combustible\")) println() } println(arrel.getTextContent()) } \u00c9s molt important observar que quan tenim un element que ja t\u00e9 contingut, la informaci\u00f3 no \u00e9s accessible, sin\u00f3 que hem d'anar al primer fill, que aquest ja \u00e9s de tips TEXT_NODE , per agafar el seu valor. En l'exemple: Per a marca hem agafat de tota la llista de fills el primer, per traure el seu valor. En matricula en compte d'agafar tota la llista de fills, nom\u00e9s hem agafat el primer, i per tant \u00e9s m\u00e9s r\u00e0pid. I per a motor utilitzem el m\u00e8tode getTextContent , que agafa el congingut de text de l'element i de tots els seus descendents. Com \u00e9s un node de text ja sabem a priori que ens anir\u00e0 b\u00e9, i per tant \u00e9s la forma m\u00e9s r\u00e0pida . L'atribut combustible de l'element motor l'hem tret de 2 maneres: La primera agafant la llista d'atributs, i despr\u00e9s el primer d'aquesta llista. En la segona manera s'ha fet m\u00e9s elegant, anat a buscar la propietat en q\u00fcesti\u00f3. Per aix\u00f2 hem convertit el node en l' element m , per a poder utilitzar getAttribute . Al final fem el getTextContent() sobre l'arrel per a comprovar que trau el seu contingut i el de tots els seus fills, per aix\u00f2 apareix la informaci\u00f3 duplicada Aquest ser\u00e0 el resultat de l'exemple anterior: vehiculo 1 Marca: ford Matr\u00edcula: 1234AAA Motor: duratorc 1.4 Combustible: gasolina Combustible: gasolina vehiculo 2 Marca: ford Matr\u00edcula: 1235AAA Motor: duratorc 2.0 Combustible: diesel Combustible: diesel ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg 4.2.2 Escriptura Anem ara a crear un nou document XML i a guardar-lo en un fitxer. Utilitzarem com a exemple Empleats . Al final de tot convertirem el fitxer Empleats.obj , generat en la pregunta 3, en el fitxer Empleats.xml . La primera consideraci\u00f3 a fer \u00e9s que partirem d'un document buit. Anirem construint els elements i posant els atributs, i quan tinguem un element creat del tot, l'afegirem a l'estructura, \u00e9s a dir farem que siga el fill d'un que ja est\u00e0 en l'estructura. Podr\u00edem fer-ho tamb\u00e9 al rev\u00e9s, \u00e9s a dir, primer penjar-lo de l'estructura i despr\u00e9s anar omplint-lo. Els principals m\u00e8todes per anar construint l'estructura s\u00f3n: M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element createElement( String nom ) crea un nou element amb el nom indicat (s'haur\u00e0 de penjar en l'estructura) Text createTextNode( String dades ) crea un nou element de text (amb contingut) Node appendChild( Node nou ) afegeix el node nou, que ser\u00e0 l'arrel M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 Node appendChild( Node nou ) afegeix el node nou com a l'\u00faltim fill fins el moment void removeChild( Node vell ) lleva el node vell com a fill M\u00e8todes de ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 void setAttribute( String nom,String valor ) afegeix un nou atribut a l'element, amb el nom i valor indicats void removeAttribute( String nom ) lleva l'atribut de l'element void setTextContent( String dades ) afegeix un fill que ser\u00e0 de text, amb el contingut passat com a par\u00e0metre Anem a fer directament ja l'exemple dels empleats. Totes les dades seran elements, excepte el n\u00famero d'empleat, que farem que siga un atribut d'empleat per a practicar. A l'element arrel li direm empleats. El resultat ha de ser el fitxer Empleats.xml . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_4_4_XMLCrearEmpleats.kt : import java.io.ObjectInputStream import java.io.FileInputStream import javax.xml.parsers.DocumentBuilderFactory import java.io.EOFException import javax.xml.transform.TransformerFactory import javax.xml.transform.dom.DOMSource import javax.xml.transform.stream.StreamResult import javax.xml.transform.OutputKeys fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream (\"Empleats.obj\")) val doc = DocumentBuilderFactory.newInstance ().newDocumentBuilder().newDocument() val arrel = doc.createElement (\"empleats\") doc.appendChild(arrel) try { while (true) { val e = f.readObject () as Empleat val emp = doc.createElement (\"empleat\") emp.setAttribute(\"numero\", Integer.toString(e.num)) val nom = doc.createElement (\"nom\") nom.appendChild(doc.createTextNode(e.nom)) // forma llarga: afegim un fill que \u00e9s un node de text emp.appendChild(nom) val dep = doc.createElement(\"departament\") dep.setTextContent(e.departament.toString()) // forma curta: amb setTextContent() li posem contingut emp.appendChild(dep) val edat = doc.createElement(\"edat\") edat.setTextContent(e.edat.toString()) emp.appendChild(edat) val sou = doc.createElement(\"sou\"); sou.setTextContent(e.sou.toString()) emp.appendChild(sou) arrel.appendChild(emp) } } catch (eof: EOFException) { f.close(); } val trans = TransformerFactory.newInstance().newTransformer() trans.transform(DOMSource(doc), StreamResult(\"Empleats.xml\")) } En el fitxer XML generat, observareu que no hi ha retorns de carro, tot est\u00e0 en una mateixa l\u00ednia. Si voleu veure'l b\u00e9, el podeu obrir per exemple amb un navegador web, que interpreta b\u00e9 el format XML. Per\u00f2 tamb\u00e9 podem crear el fitxer donant-li un aspecte agradable incorporant aquestes dues l\u00ednies immediatament abans de crear el fitxer, \u00e9s a dir, immediatament abans de la l\u00ednia 49: trans.setOutputProperty(OutputKeys.INDENT, \"yes\") trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\") I el fitxer quedar\u00e0 aix\u00ed: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <empleats> <empleat numero=\"1\"> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat numero=\"2\"> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat numero=\"3\"> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat numero=\"4\"> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empleats> Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.- Documents XML"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/#4-documents-xml","text":"Hem vist que la manera m\u00e9s c\u00f2moda de guardar objectes \u00e9s amb la seriaci\u00f3, per mig del ObjectInputStream i ObjectOutputStream , per\u00f2 que fora de Java o de Kotlin no \u00e9s possible l'acc\u00e9s a aquestes dades. I com hav\u00edem comentat en l'\u00faltima nota de la pregunta anterior, tamb\u00e9 dins de Kotlin podem tenir problemes, perqu\u00e8 el nom de la classe amb el nom del paquet es guarda en el fitxer com a metades, i en un altre programa haurem de tenir la classe creada en un paquet amb el mateix nom, sin\u00f3 no es podran recuperar les dades. I fins i tot dient-se exactament igual, poden haver problemes si el serialVersionUID de la classe no \u00e9s el mateix. Tamb\u00e9 hem vist que per a guardar dades individuals de diferents tipus ens van molt b\u00e9 les classes DataInputStream i DataOutputStream , per\u00f2 haurem de saber molt b\u00e9 l'ordre i tipus de dades que estan guardades, sin\u00f3, no les podrem recuperar. I no entrem ja en la possibilitat que diferents Sistemes Operatius representen la informaci\u00f3 de forma diferent (per exemple, hi ha Sistemes Operatius que representen els n\u00fameros amb BCD i altres que utilitzen complement a 2). Per tant, quan vulguem guardar dades que puguen ser llegides per aplicacions fetes en diferents llenguatges i/o executades en diferents plataformes, ens far\u00e0 falta un format est\u00e0ndar que tots el puguen entendre i recon\u00e9ixer, i millor si \u00e9s autoexplicatiu com \u00e9s el cas dels llenguatges de marques . El llenguatge de marques m\u00e9s conegut i m\u00e9s utilitzat \u00e9s el XML ( eXtensible Markup Language ) Els documents XML aconsegueixen estructurar la informaci\u00f3 intercalant unes marques anomenades etiquetes, cada etiqueta amb un principi i un final, i que poden anar unes dins d'unes altres, i tamb\u00e9 contenir informaci\u00f3 de text. D\u2019aquesta manera, es podr\u00e0 subdividir la informaci\u00f3 estructurant-la de forma que puga ser f\u00e0cilment interpretada. Tota la informaci\u00f3 ser\u00e0 de text, i per tant no hi haur\u00e0 el problema mencionat abans de representar les dades de diferent manera. Qualsevol dada, ja siga num\u00e8rica, booleana o com siga, es posar\u00e0 en mode text, i per tant sempre es podr\u00e0 llegir i interpretar correctament tota la informaci\u00f3 continguda en un fitxer XML. \u00c9s cert que els car\u00e0cters es poden escriure utilitzant diferents sistemes de codificaci\u00f3, per\u00f2 XML ofereix diverses t\u00e8cniques per evitar que aix\u00f2 siga un problema, com per exemple, incloent a la cap\u00e7alera del fitxer quina codificaci\u00f3 s\u2019ha fet servir en el moment de guardar-lo. Amb les etiquetes, XML aconsegueix estructurar qualsevol tipus d\u2019informaci\u00f3 jer\u00e0rquica. Es pot establir certa similitud entre la forma com la informaci\u00f3 es guarda en els objectes d\u2019una aplicaci\u00f3 i la forma com es guardaria en un document XML. La informaci\u00f3, en les aplicacions orientades a objectes, s\u2019estructura, agrupa i jerarquitza en classes, i en els documents XML s\u2019estructura, organitza i jerarquitza en etiquetes contingudes unes dins les altres i atributs de les etiquetes. Imaginem que volem representar les dades dels empleats com els de l\u2019aparat anterior utilitzant un format XML. No existeix una \u00fanica soluci\u00f3, per\u00f2 \u00e9s obligatori que totes respecten la jerarquia del model. Un possible format podria ser el seg\u00fcent: <empresa> <empleat> <num>1</num> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat> <num>2</num> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat> <num>3</num> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat> <num>4</num> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empresa> Per\u00f2 aquesta tamb\u00e9 podria ser una manera de representar-lo: <empresa> <empleat num='1' nom='Andreu' departament='10' edat='32' sou='1000.0'/> <empleat num='2' nom='Bernat' departament='20' edat='28' sou='1200.0'/> <empleat num='3' nom='Cl\u00e0udia' departament='10' edat='26' sou='1100.0'/> <empleat num='4' nom='Dami\u00e0' departament='10' edat='40' sou='1500.0'/> </empresa> I podem imaginar moltes altres solucions, combinant considerant com atributs o subetiquetes les diferents caracter\u00edstiques dels empleats que volem guardar. Aquest seria el problema principal del XML, les m\u00faltiples solucions. Per\u00f2 tamb\u00e9 \u00e9s veritat que totes elles s\u00f3n f\u00e0cils d'entendre.","title":"4.- Documents XML"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/#41-parser-o-analitzador-xml","text":"Un Parser XML \u00e9s una classe que ens permet analitzar i classificar el contingut d\u2019un arxiu XML extraient la informaci\u00f3 continguda en cada una de les etiquetes, i relacionar-la d\u2019acord amb la seua posici\u00f3 dins la jerarquia. Hi ha dos tipus d'analitzadors depenent de la manera de funcionar. Analitzadors seq\u00fcencials Els analitzadors seq\u00fcencials permeten extreure el contingut a mida que es van descobrint les etiquetes d\u2019obertura i tancament. Tamb\u00e9 s\u2019anomenen analitzadors sint\u00e0ctics . S\u00f3n analitzadors molt r\u00e0pids, per\u00f2 presenten el problema que cada vegada que es necessita accedir a una part del contingut, s'ha de rellegir tot el document de dalt a baix. En Java, l\u2019analitzador sint\u00e0ctic m\u00e9s popular s\u2019anomena SAX , que vol dir Simple API for XML . \u00c9s una analitzador molt utilitzat en diverses biblioteques de tractament de dades XML, per\u00f2 no sol utilitzar-se en aplicacions finals, pel problema abans comentat d'haver de llegir-se tot el document XML a cada consulta. Per aquesta ra\u00f3 no els veurem en aquest curs. Analitzadors jer\u00e0rquics Generalment, les aplicacions finals que han de treballar amb dades XML solen utilitzar analitzadors jer\u00e0rquics. Els analitzadors jer\u00e0rquics guarden totes les dades del document XML en mem\u00f2ria dins una estructura jer\u00e0rquica, a mida que van analitzant el seu contingut. I per aix\u00f2 s\u00f3n ideals per a aplicacions que requereixen una consulta cont\u00ednua de les dades. El format de l\u2019estructura on es guarda la informaci\u00f3 en mem\u00f2ria ha estat especificat per l\u2019organisme internacional W3C (World Wide Web Consortium) i es coneix com a DOM ( Document Object Model ). \u00c9s una estructura que HTML i javascript han popularitzat molt i es tracta d\u2019una especificaci\u00f3 que Java materialitza en forma d\u2019interf\u00edcies. La principal s\u2019anomena Document i representa tot un document XML. En tractar-se d\u2019una interf\u00edcie, pot ser implementada per diverses classes. L\u2019est\u00e0ndard W3C defineix la classe DocumentBuilder (constructor de documents) per a poder crear estructures DOM a partir d\u2019un XML. Aquesta classe DocumentBuilder \u00e9s una classe abstracta, i per tal que es puga adaptar a les diferents plataformes, pot necessitar fonts de dades o requeriments diversos. Recordeu que les classes abstractes no es poden instanciar de forma directa. Per aquest motiu, el consorci W3 especifica tamb\u00e9 la classe DocumentBuilderFactory , \u00e9s a dir, el fabricador de DocumentBuilder . Les llibreries des d'on importarem les classes comentades s\u00f3n: DocumentBuilderFactory i DocumentBuilder les importarem de la llibreria javax.xml.parsers. * Document l'importarem de org.w3c.dom. * Hem de cuidar sobretot aquesta \u00faltima importaci\u00f3, perqu\u00e8 per defecte Java ens ofereix moltes llibreries des d'on importar Document . I si no la importem de la llibreria correcta, evidentment despr\u00e9s tindrem errors. Les instruccions necess\u00e0ries per llegir un fitxer XML i crear un objecte Document serien les seg\u00fcents: import java.io.FileInputStream import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val dbFactory = DocumentBuilderFactory.newInstance() val dBuilder = dbFactory.newDocumentBuilder() val doc = dBuilder.parse(File(\u201cfitxer.xml\u201d)) Tornem a insistir en la necessitat d'importar Document de la llibreria org.w3c.dom. * Anem a basar-nos en un exemple per poder veure a poc a poc la manera d'utilitzar el parser. \u00c9s un exemple que possiblement es va veure en primer, en el m\u00f2dul de Llenguatge de Marques. Suposarem que est\u00e0 en el fitxer cotxes.xml , i que est\u00e0 en el directori del projecte on farem les proves. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> El primer que farem ser\u00e0 intentar connectar amb aquest fitxer, per\u00f2 d'una forma un poc m\u00e9s redu\u00efda que abans, sense definir objectes del DocumentBuilderFactory ni DocumentBuilder . Tampoc ens caldr\u00e0 definir- nos el File ( FileInputStream ) ja que el m\u00e8tode parse tamb\u00e9 agafa un String com a par\u00e0metre: import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") Per\u00f2, i si el proc\u00e9s que necessitem \u00e9s l'invers? \u00c9s a dir, i si el que volem \u00e9s guardar una estructura DOM en un fitxer XML? En aquest cas el que haurem de fer ser\u00e0 construir un document buit , anar posant els elements i atributs (amb els seus valors) d'alguna manera, i posteriorment guardar-lo en un fitxer. Deixem per a un poc m\u00e9s avant com anar construint els nodes del document i centrem-nos en el fet de crear el document buit i guardar-lo en un fitxer. Podem construir un document nou a partir del DocumentBuilder , utilitzant el m\u00e8tode newDocument() : import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc1 = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument() Per a escriure la informaci\u00f3 continguda al DOM a un fitxer, es pot fer utilitzant una altra utilitat de Java anomenada Transformer . Es tracta d\u2019una utilitat que permet realitzar f\u00e0cilment conversions entre diferents representacions d\u2019informaci\u00f3 jer\u00e0rquica. \u00c9s capa\u00e7, per exemple, de passar la informaci\u00f3 continguda en un objecte Document a un fitxer de text en format XML . Tamb\u00e9 seria capa\u00e7 de fer l\u2019operaci\u00f3 inversa, per\u00f2 no val la pena perqu\u00e8 el mateix DocumentBuilder ja s\u2019encarrega d\u2019aix\u00f2. Transformer \u00e9s tamb\u00e9 una classe abstracta i requereix d\u2019una factory per poder ser instanciada. La classe Transformer pot treballar amb multitud de contenidors d\u2019informaci\u00f3 perqu\u00e8 en realitat treballa amb un parell de tipus adaptadors (classes que fan compatibles jerarquies diferents) que s\u2019anomenen Source i Result . Les classes que implementen aquestes interf\u00edcies s\u2019encarregaran de fer compatible un tipus de contenidor espec\u00edfic al requeriment de la classe Transformer . Aix\u00ed, disposem de les classes DOMSource , SAXSource o StreamSource com a adaptadors del contenidor de la font d\u2019informaci\u00f3 (DOM, SAX o Stream respectivament). DOMResult , SAXResult o StreamResult s\u00f3n els adaptadors equivalents del contenidor dest\u00ed. A nosaltres ara, com que volem passar un document DOM a un fitxer, ens convindr\u00e0 un DOMSource i un StreamResult El codi b\u00e0sic per realitzar una transformaci\u00f3 de DOM a fitxer de text XML seria el seg\u00fcent: val trans = TransformerFactory.newInstance().newTransformer() val source = DOMSource(doc) val result = StreamResult(file) trans.transform(source, result) De tota manera, veurem m\u00e9s avant un exemple on ens guardarem una estructura DOM en un fitxer XML.","title":"4.1 - Parser o analitzador XML"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/#42-lestructura-dom","text":"L\u2019estructura DOM pren la forma d\u2019un arbre, on cada part del XML es trobar\u00e0 representada en forma de node . En funci\u00f3 de la posici\u00f3 en el document XML, parlarem de diferents tipus de nodes: El node principal que representa tot el XML sencer s\u2019anomena Document. Les diverses etiquetes, inclosa l\u2019etiqueta arrel, es coneixen com a nodes Element . El contingut d\u2019una etiqueta de tipus text, ser\u00e0 un node de tipus TextElement Els atributs seran nodes de tipus Attribute . En l'exemple de la p\u00e0gina anterior, el fitxer cotxes.xml , que t\u00e9 aquesta estructura: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Veient-lo com una estructura jer\u00e0rquica ens quedaria aix\u00ed: On: El node Document \u00e9s el rombe Els nodes Element s\u00f3n els cercles Els nodes TextElement s\u00f3n els rect\u00e0ngles de fons taronja. Els nodes Attribute s\u00f3n els rect\u00e0ngles arrodonits de color groc Cada node espec\u00edfic disposa de m\u00e8todes per accedir a les seues dades concretes (nom, valor, nodes fills, node pare, etc.). \u00c9s a dir, que el node serveix per a situar-se en una determinada posici\u00f3 (element, atribut, element de text, ...). Tindr\u00e0 uns m\u00e8todes, sobretot per a navegar, encara que tamb\u00e9 alguns per a traure el contingut. Element \u00e9s un classe derivada de Node (per tant hereta tots els seus m\u00e8todes), i proporciona algunes coses m\u00e9s, sobretot per a accedir c\u00f2modament a les seues parts. Mirem els m\u00e8todes m\u00e9s importants, tant de Node com de Element i Document M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 String getNodeName() torna el nom d'aquest node short getNodeType() torna el tipus d'aquest node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, ... String getNodeValue() torna el valor del node, si en t\u00e9 NodeList getChildNodes() torna una llista amb els nodes fills Node getFirstChild() torna el primer fill Node getLastChild() torna l'\u00faltim fill NamedNodeMap getAttributes() torna una llista amb els atributs del node (null si no en t\u00e9 cap) Node getParentNode() torna el pare String getTextContent() torna el text contingut en l'element i el de tots els seus descendents, si en t\u00e9 boolean hasChildNodes() torna cert si el node t\u00e9 algun fill boolean hasAttributes() torna cert si el node t\u00e9 algun atribut M\u00e8todes d' ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 String getAttribute( String nom ) torna el valor de l'atribut que t\u00e9 aquest nom NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom boolean hasAttribute( String nom ) torna cert si l'element t\u00e9 aquest atribut M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element getDocumentElement() torna l'element arrel del document NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom Nota Kotlin ens \"suggerir\u00e0\" canviar molts dels m\u00e8todes anteriors per propietats. Per exemple per al m\u00e8tode getNodeName() ens suggerir\u00e0 de canviar-lo per la propietat nodeName . Podeu substituir per la propietat o deixar el m\u00e8tode, el que vulgueu. Sempre que tinguem una llista de nodes , podrem accedir a cadascun dels membres de la llista amb el m\u00e8tode item especificant el n\u00famero d'ordre. Aix\u00ed, si volem accedir al primer posarem item(0) Posterioment posarem els m\u00e8todes que serveixen per anar posant contingut a un document: crear fills, crear atributs, posar contingut, ... El DOM resultant obtingut des d\u2019un XML acaba sent un c\u00f2pia exacta del fitxer, per\u00f2 disposat de diferent manera. Tant al XML com al DOM hi haur\u00e0 informaci\u00f3 no visible, com ara els retorns de carro , que cal tenir en compte per tal de saber processar correctament el contingut i evitar sorpreses poc comprensibles. Per a il\u00b7lustrar el problema que poden suposar els retorn de carro , imaginem que disposem d\u2019un document XML amb el seg\u00fcent contingut: <table> <tr> <td> </td> <td> </td> </tr> </table> Veurem m\u00e9s clar si representem els retorn de carro en el mateix document: <table>\u00b6 <tr>\u00b6 <td> </td>\u00b6 <td> </td>\u00b6 </tr>\u00b6 </table> A la seg\u00fcent figura es mostra la representaci\u00f3 que tindria l\u2019objecte DOM, un vegada estiga ja copiat en mem\u00f2ria. Observeu com l\u2019element table tindr\u00e0 tres fills. En un es guardar\u00e0 el retorn de carro que situa l\u2019etiqueta < tr > a la seg\u00fcent l\u00ednia, en el segon trobarem l\u2019etiqueta < tr > , i en el tercer el retorn de carro que fa que </ table > estiga en la l\u00ednia de baix. El mateix passa amb els fills de < tr > , abans i despr\u00e9s de cada node < td > trobarem un retorn de carro . En canvi, si hagu\u00e9rem partit d'un XML equivalent per\u00f2 sense retorns de carro, el resultat hauria estat diferent: <table><tr><td></td><td></td></tr></table> L\u2019abs\u00e8ncia de retorns de carro en el fitxer implica tamb\u00e9 l\u2019abs\u00e8ncia de nodes contenint els retorns de carro en l\u2019estructura DOM. Un altre aspecte a tenir en compte \u00e9s que el contingut de les etiquetes es plasma en el DOM com un node fill de l\u2019etiqueta contenidora. \u00c9s a dir, per obtenir el text d\u2019una etiqueta cal obtenir el primer fill d\u2019aquesta. <aaa> <bbb> text de l'etiqueta bbb </bbb> </aaa>","title":"4.2 - L'estructura DOM"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/#421-lectura","text":"Anem a fer proves per poder comprovar el funcionament. Ens basem en el document cotxes.xml esmentat en la pregunta 4.1 Nota Aneu amb compte, perqu\u00e8 en el document cotxes.xml davant de la primera etiqueta no pot haver ni retorn de carro ni un espai en blanc ni res. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_1_XMLMirar.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>){ val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") println(doc.getNodeName()) // torna el nom del document. No \u00e9s l'element arrel. Ens dir\u00e0 #document val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel println(arrel.getNodeName()) // torna el nom de l'element. Ens dir\u00e0 oferta println(arrel.getNodeValue()) // torna el valor de l'element. Com \u00e9s un element que cont\u00e9 altres elements, el valor \u00e9s null } Tal i com est\u00e0 documentat, aquesta ser\u00e0 l'eixida: #document oferta null Anem a comprovar ara que el primer fill de oferta no \u00e9s vehiculo sin\u00f3 el retorn de carro. Els element vehiculo s\u00f3n el segon i el quart (\u00edndex 1 i 3). Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_2_XMLMirar2.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val fills = arrel.getChildNodes() println(fills.item(0).getNodeName()) // el primer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(1).getNodeName()) // el segon fill s\u00ed que \u00e9s vehiculo println(fills.item(2).getNodeName()) // el tercer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(3).getNodeName()) // el quart fill s\u00ed que \u00e9s vehiculo println(fills.item(4).getNodeName()) // el cinqu\u00e8 fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(5).getNodeName()) // no existeix el sis\u00e8 fill. Donar\u00e0 error } Observeu que en l'\u00faltima sent\u00e8ncia estem provocant un error: #text vehiculo #text vehiculo #text Exception in thread \"main\" java.lang.NullPointerException at exemples.Exemple_4_2_MirarXML2.main(Exemple_4_2_MirarXML2.kt:15) Per tant, hem d'anar molt en compte amb els retorns de carro . Per a poder esquivar els retorn de carro podr\u00edem mirar el tipus de cada node ( getNodeType() ), menysprear els els de tipus TEXT_NODE i considerar nom\u00e9s els de tipus ELEMENT_NODE . Per\u00f2 normalment l'acc\u00e9s que farem ser\u00e0 un poc m\u00e9s directe i m\u00e9s f\u00e0cil. Agafarem la llista de tots els element que tinguen un determinat nom amb getElementsByTagName( nom ) . Evidentment en la llista no estaran els retorns de carro i aix\u00ed no tindrem problemes amb ells. En el seg\u00fcent exemple recorrerem tots els element vehiculo . De cadascun agafarem el contingut dels elements marca i matricula . Tamb\u00e9 agafem el contingut de l'atribut combustible de l'element motor . Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_3_XMLMirarCotxes.kt : package exemples import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Element fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val llista = arrel.getElementsByTagName(\"vehiculo\") for (i in 0 until llista.getLength()) { val el = llista.item(i) as Element println(el.getNodeName() + \" \" + (i + 1)) println(\"Marca: \" + el.getElementsByTagName(\"marca\").item(0).getChildNodes().item(0).getNodeValue()) println(\"Matr\u00edcula: \" + el.getElementsByTagName(\"matricula\").item(0).getFirstChild().getNodeValue()) println(\"Motor: \" + el.getElementsByTagName(\"motor\").item(0).getTextContent()) println(\"Combustible: \" + el.getElementsByTagName(\"motor\").item(0).getAttributes().item(0).getNodeValue()) val m = el . getElementsByTagName (\"motor\").item(0) as Element println(\"Combustible: \" + m.getAttribute(\"combustible\")) println() } println(arrel.getTextContent()) } \u00c9s molt important observar que quan tenim un element que ja t\u00e9 contingut, la informaci\u00f3 no \u00e9s accessible, sin\u00f3 que hem d'anar al primer fill, que aquest ja \u00e9s de tips TEXT_NODE , per agafar el seu valor. En l'exemple: Per a marca hem agafat de tota la llista de fills el primer, per traure el seu valor. En matricula en compte d'agafar tota la llista de fills, nom\u00e9s hem agafat el primer, i per tant \u00e9s m\u00e9s r\u00e0pid. I per a motor utilitzem el m\u00e8tode getTextContent , que agafa el congingut de text de l'element i de tots els seus descendents. Com \u00e9s un node de text ja sabem a priori que ens anir\u00e0 b\u00e9, i per tant \u00e9s la forma m\u00e9s r\u00e0pida . L'atribut combustible de l'element motor l'hem tret de 2 maneres: La primera agafant la llista d'atributs, i despr\u00e9s el primer d'aquesta llista. En la segona manera s'ha fet m\u00e9s elegant, anat a buscar la propietat en q\u00fcesti\u00f3. Per aix\u00f2 hem convertit el node en l' element m , per a poder utilitzar getAttribute . Al final fem el getTextContent() sobre l'arrel per a comprovar que trau el seu contingut i el de tots els seus fills, per aix\u00f2 apareix la informaci\u00f3 duplicada Aquest ser\u00e0 el resultat de l'exemple anterior: vehiculo 1 Marca: ford Matr\u00edcula: 1234AAA Motor: duratorc 1.4 Combustible: gasolina Combustible: gasolina vehiculo 2 Marca: ford Matr\u00edcula: 1235AAA Motor: duratorc 2.0 Combustible: diesel Combustible: diesel ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg","title":"4.2.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/#422-escriptura","text":"Anem ara a crear un nou document XML i a guardar-lo en un fitxer. Utilitzarem com a exemple Empleats . Al final de tot convertirem el fitxer Empleats.obj , generat en la pregunta 3, en el fitxer Empleats.xml . La primera consideraci\u00f3 a fer \u00e9s que partirem d'un document buit. Anirem construint els elements i posant els atributs, i quan tinguem un element creat del tot, l'afegirem a l'estructura, \u00e9s a dir farem que siga el fill d'un que ja est\u00e0 en l'estructura. Podr\u00edem fer-ho tamb\u00e9 al rev\u00e9s, \u00e9s a dir, primer penjar-lo de l'estructura i despr\u00e9s anar omplint-lo. Els principals m\u00e8todes per anar construint l'estructura s\u00f3n: M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element createElement( String nom ) crea un nou element amb el nom indicat (s'haur\u00e0 de penjar en l'estructura) Text createTextNode( String dades ) crea un nou element de text (amb contingut) Node appendChild( Node nou ) afegeix el node nou, que ser\u00e0 l'arrel M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 Node appendChild( Node nou ) afegeix el node nou com a l'\u00faltim fill fins el moment void removeChild( Node vell ) lleva el node vell com a fill M\u00e8todes de ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 void setAttribute( String nom,String valor ) afegeix un nou atribut a l'element, amb el nom i valor indicats void removeAttribute( String nom ) lleva l'atribut de l'element void setTextContent( String dades ) afegeix un fill que ser\u00e0 de text, amb el contingut passat com a par\u00e0metre Anem a fer directament ja l'exemple dels empleats. Totes les dades seran elements, excepte el n\u00famero d'empleat, que farem que siga un atribut d'empleat per a practicar. A l'element arrel li direm empleats. El resultat ha de ser el fitxer Empleats.xml . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_4_4_XMLCrearEmpleats.kt : import java.io.ObjectInputStream import java.io.FileInputStream import javax.xml.parsers.DocumentBuilderFactory import java.io.EOFException import javax.xml.transform.TransformerFactory import javax.xml.transform.dom.DOMSource import javax.xml.transform.stream.StreamResult import javax.xml.transform.OutputKeys fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream (\"Empleats.obj\")) val doc = DocumentBuilderFactory.newInstance ().newDocumentBuilder().newDocument() val arrel = doc.createElement (\"empleats\") doc.appendChild(arrel) try { while (true) { val e = f.readObject () as Empleat val emp = doc.createElement (\"empleat\") emp.setAttribute(\"numero\", Integer.toString(e.num)) val nom = doc.createElement (\"nom\") nom.appendChild(doc.createTextNode(e.nom)) // forma llarga: afegim un fill que \u00e9s un node de text emp.appendChild(nom) val dep = doc.createElement(\"departament\") dep.setTextContent(e.departament.toString()) // forma curta: amb setTextContent() li posem contingut emp.appendChild(dep) val edat = doc.createElement(\"edat\") edat.setTextContent(e.edat.toString()) emp.appendChild(edat) val sou = doc.createElement(\"sou\"); sou.setTextContent(e.sou.toString()) emp.appendChild(sou) arrel.appendChild(emp) } } catch (eof: EOFException) { f.close(); } val trans = TransformerFactory.newInstance().newTransformer() trans.transform(DOMSource(doc), StreamResult(\"Empleats.xml\")) } En el fitxer XML generat, observareu que no hi ha retorns de carro, tot est\u00e0 en una mateixa l\u00ednia. Si voleu veure'l b\u00e9, el podeu obrir per exemple amb un navegador web, que interpreta b\u00e9 el format XML. Per\u00f2 tamb\u00e9 podem crear el fitxer donant-li un aspecte agradable incorporant aquestes dues l\u00ednies immediatament abans de crear el fitxer, \u00e9s a dir, immediatament abans de la l\u00ednia 49: trans.setOutputProperty(OutputKeys.INDENT, \"yes\") trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\") I el fitxer quedar\u00e0 aix\u00ed: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <empleats> <empleat numero=\"1\"> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat numero=\"2\"> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat numero=\"3\"> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat numero=\"4\"> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empleats> Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.2.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/","text":"5.- Documents JSON JSON vol dir J ava S cript O bject N otation , \u00e9s a dir Notaci\u00f3 d'Objectes de JavaScript. \u00c9s una manera de representar objectes inicialment per a JavaScript, per\u00f2 per la seua senzillesa, i com \u00e9s en text pla, serveix per a qualsevol entorn. Permet representar estructures de dades d'una determinada complexitat, com el XML, per\u00f2 pesa molt menys que aquest, i per aix\u00f2 est\u00e0 convertint-se en un est\u00e0ndar d'intercanvi de dades, sobretot entre un servidor i una aplicaci\u00f3 web. L'extensi\u00f3 d'un fitxer JSON \u00e9s .json 5.1 - Estructura JSON Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu 5.2 Driver org.json Hi ha m\u00e9s d'una llibreria per a poder accedir i analitzar els documents json. Per exemple, es comenten prou per Internet s\u00f3n GSON (de Google) i Jackson . Per\u00f2 nosaltres anem a utilitzar dues altres llibreries Una, la del grup org.json que en principi ser\u00e0 la mateixa que s'utilitzar\u00e0 en Android Una altra, la de Moshi , que ens permetr\u00e0 elaborar m\u00e9s el resultat ja que podrem fer una conversi\u00f3 entre Json i objectes de Java o de Kotlin Pel que fa a la primera, en el moment de fer aquestos apunts l'\u00faltima versi\u00f3 estable \u00e9s la 20240303 , \u00e9s a dir, de mar\u00e7 de 2024. En aquest enlla\u00e7 teniu d'on us la podeu baixar: https://jar-download.com/artifacts/org.json/json . Una vegada baixada l'haurem d'incorporar al nostre projecte (sobre el projecte F4 -- > Modules --> pestanya dependencies --> + ) En ella trobem el m\u00e9s b\u00e0sic: JSONObject : equivaldr\u00e0 a un objecte JSONArray : equivaldr\u00e0 a un array JSONTokener :ens permetr\u00e0 analitzar el document Json, i tornar\u00e0 l'objecte arrel. El m\u00e8tode que utilitzarem ser\u00e0 sempre nextValue() . 5.2.1 - Lectura JSONTokener El primer que haurem de fer ser\u00e0 analitzar el document per a obtenir l'element arrel (que com hem vist normalment ser\u00e0 un objecte, per\u00f2 de vegades pot ser un array). El constructor de JSONTokener admet un String , amb la qual cosa analitzarem una cadena que posem directament, o tamb\u00e9 un InputStream o un Reader , amb la qual cosa podrem analitzar directament el contingut d'un fitxer El m\u00e8tode nextValue() de JSONTokener tornar\u00e0 l'arrel del document Json, i nom\u00e9s haurem de fer un cast a l'ojecte que \u00e9s l'arrel: un JSONObject o un JSONArray En el seg\u00fcent exemple agafem el json directament d'un string , on ten\u00edem els n\u00fameros parells. { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } Observeu com per a la definici\u00f3 del String ens ha tocat escapar les dobles cometes. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_11_JSONAnalitzarCadena.kt package exemples import org.json.JSONTokener import org.json.JSONObject fun main(args: Array<String>) { val cadena = \"{ \\\"p1\\\" : 2 , \\\"p2\\\" : 4 , \\\"p3\\\" : 6 , \\\"p4\\\" : 8 , \\\"p5\\\" : 10 }\" val arrel = JSONTokener(cadena).nextValue() as JSONObject println(arrel.get(\"p1\")) } Mentre que en aquest exemple accedim al fitxer parelles.json (que assumirem que t\u00e9 el mateix contingut). Podr\u00edem passar el contingut del fitxer a una cadena, per\u00f2 \u00e9s molt m\u00e9s c\u00f2mode passar el Reader com par\u00e0metre en el constructor, i ell s'encarrega de llegir-lo tot. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_12_JSONAnalitzarFitxer.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"parelles.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject println(arrel.get(\"p3\")); } JSONObject Contindr\u00e0 un objecte json . Recordeu que l' objecte es delimita amb les claus: { } El m\u00e8tode m\u00e9s important ser\u00e0 get( clau ) al qual li passem la clau del membre que volem obtenir. Si el membre \u00e9s una parella clau-valor, obtindrem directament el valor. Si \u00e9s un altre objecte, doncs obtindrem l'objecte o tamb\u00e9 podria ser un array. El cas que siga una parella clau-valor, ja l'hem vist en l'exemple anterior. En el seg\u00fcent exemple, en el fitxer Empleat.json tindrem un empleat { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } Observeu com ara de l'element arrel hem d'agafar empleat , que \u00e9s un objecte amb les parelles clau-valor num , nom , .... Copieu el seg\u00faent codi en el fitxer Kotlin Exemple_3_5_13_JSONAnalitzarEmpleat.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empleat.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empleat = arrel.get(\"empleat\") as JSONObject println(\"\" + empleat.get(\"nom\") + \" (\" + empleat.get(\"sou\") + \")\") } Tamb\u00e9 podem utilitzar els m\u00e8todes getJSONObject() , getJSONArray , getInt() , getString() , ..., que directament ens ho d\u00f3na en el tipus especificat, i no cal fer cast. JSONArray Ser\u00e0 l'array, que recordem que ve limitat per els claud\u00e0tors: [ ] Per a obtenir els elements de l'array utilitzarem el m\u00e8tode get( index ) , on l'\u00edndex \u00e9s el n\u00famero d'ordre de l'element que volem obtenir. Tamb\u00e9 tindrem els m\u00e8todes getJSONObject( index ) , getJSONArray( index ) , getInt( index ) , ..., que tornen directament el tipus especificat Posem el primer exemple sobre un json que nom\u00e9s t\u00e9 un array els elements del qual s\u00f3n valors: [ 5 , 7 , 8 , 7 ] Observeu com ara l'arrel \u00e9s un Array, i ens muntem un bucle per obtenir tots els elements. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_14_JSONAnalitzarArray.kt package exemples import org.json.JSONTokener import org.json.JSONArray fun main(args: Array<String>) { val cadena = \"[ 5 , 7 , 8 , 7 ]\" val arrel = JSONTokener(cadena).nextValue() as JSONArray for (i in arrel) println(i) } Com veieu podem fer servir els bucles foreach, per\u00f2 lamentablement no podem obtenir directament un JsonObject, i per tant l'hem de reconvertir. Ho mostrarem en el seg\u00fcent exemple en el qual agafem tots els empleats de l'empresa, on Empresa.json \u00e9s aix\u00ed: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic membre empleat que \u00e9s un array amb 4 elements, cadascun dels empleats. Copieu el seg\u00fcent exemple en el fitxer kotlin Exemple_3_5_15_JSONAnalitzarEmpresa.kt package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empresa.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empresa = arrel.getJSONObject(\"empresa\") for (e in empresa.getJSONArray(\"empleats\")){ val emp = e as JSONObject println(\"\" + emp.get(\"nom\") + \" (\" + emp.get(\"sou\") + \")\") } } Mireu com ens hem estalviat un pas, i no hem definit la variable empleats , sin\u00f3 que ho especifiquem en el bucle. Tamb\u00e9 podr\u00edem haver estalviat la variable empresa si en el bucle hagu\u00e9rem posat : for (e in arrel.getJSONObject(\"empresa\").getJSONArray(\"empleats\")){ Exemple m\u00e9s complet Mirem algun exemple ja m\u00e9s elaborat, on ens tocar\u00e0 analitzar amb detall l'estructura json. Fem-lo sobre l'exemple de BICICAS . Podeu tornar a fer la consulta de l'estat actual en aquest moment a la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php , seleccionar-ho tot i guardar-lo en el fitxer Bicicas.json . \u00c9s molt possible que tinguem problemes amb els car\u00e0cers especials, com les vocals accentuades, a causa de que el navegador utilitzat no les reconega, i en copiar-les al fitxer no tinguem ja la codificaci\u00f3 correcta. No li donarem import\u00e0ncia en aquest moment. Recordem ac\u00ed l'estructura: [ {\"ocupacion\": [{\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\", \"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\", porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podem observar, comen\u00e7a per un array , no per un objecte, com sol ser habitual. L'\u00fanic que ens interessa \u00e9s el primer element de l'array, ja que en posteriors anirien en tot cas missatges. El primer element \u00e9s un objecte que t\u00e9 un \u00fanic membre ocupacion (o si en t\u00e9 m\u00e9s no ens interessen), que \u00e9s un array amb totes les estacions. Cada estaci\u00f3 \u00e9s un objecte amb la informaci\u00f3 que ens interessa. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_16_JSONAnalitzarBicicas.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") for (e in estacions){ val est = e as JSONObject println(\"\" + e.get(\"id\") + \".- \" + e.get(\"punto\") + \" (\" + e.get(\"ocupados\") + \"/\" + e.get(\"puestos\") + \")\") } } Hem agafat l'array, d'ell hem agafat el primer objecte i d'ell l'array. I hem utilitzat un bucle for , per a tots els valors de l'array 5.2.2 - Escriptura Ens falta veure com escriure un document JSON. \u00c9s molt f\u00e0cil anar creant l'estructura JSON. Nom\u00e9s hem de recordar la manera d'afegir al JSONObject i al JSONArray . put(\"nom\", element) per afegir un nou membre a un JSONObject put(element) per afegir un nou element a un JSONArray Nota La major part de drivers utilitzen add(element) per a afegir un element a un JSONArray, en compte de put Una vegada tinguem l'estructura, podrem passar-la a un string amb el m\u00e8tode toString , i la podrem guardar directament en un fitxer, per exemple. Farem m\u00e9s d'un exemple, per poder practicar. En el primer exemple generarem un JSON a partir de dades definides en el mateix programa, per mig de vectors. Intentarem generar aquest fitxer JSON: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Analitzem l'estructura. Tenim un objecte arrel, que consta d'un \u00fanic membre, empresa, que \u00e9s un objecte. Aquest objecte t\u00e9 un \u00fanic membre que \u00e9s un array. Cada element de l'array \u00e9s un objecte, i els seus membres ja s\u00f3n clau-valor. Copieu el seg\u00fcent codi en el fitxer kotlin Exemple_3_5_17_JSONEscriureEmpleats.kt : import org.json.JSONObject import org.json.JSONArray import java.io.FileWriter fun main(args: Array<String>) { val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0) val arrel = JSONObject() val empresa = JSONObject() arrel.put(\"empresa\", empresa) val empleats = JSONArray() empresa.put(\"empleat\", empleats) for (i in 0..3){ val emp = JSONObject() emp.put(\"num\", i + 1) emp.put(\"nom\", noms[i]) emp.put(\"departament\", departaments[i]) emp.put(\"edat\", edats[i]) emp.put(\"sou\", sous[i]) empleats.put(emp) } val f = FileWriter(\"Empleats.json\") f.write(arrel.toString(4)) f.close() } Hem posat en el moment de passar el JSONObject a String el par\u00e0metre 4, per a que idente en diferents linies a 4 espais. Com veureu el resultat \u00e9s quasi perfecte {\"empresa\": {\"empleat\": [ { \"num\": 1, \"sou\": 1000, \"nom\": \"Andreu\", \"edat\": 32, \"departament\": 10 }, { \"num\": 2, \"sou\": 1200, \"nom\": \"Bernat\", \"edat\": 28, \"departament\": 20 }, { \"num\": 3, \"sou\": 1100, \"nom\": \"Cl\u00e0udia\", \"edat\": 26, \"departament\": 10 }, { \"num\": 4, \"sou\": 1500, \"nom\": \"Dami\u00e0\", \"edat\": 40, \"departament\": 10 } ]}} Tenim el problema aparent que els membres de cada empleat estan desordenats . No \u00e9s que haja eixit malament, perqu\u00e8 hem de recordar que un objecte JSON \u00e9s un conjunt no ordenat de membres. Exemple BICICAS Un altre exemple, el de Bicicas , i el que farem per a practicar tant la lectura com l'escriptura, ser\u00e0 donar-li una altra estructura. Per tant llegirem l'original, i anirem construint la seg\u00fcent estructura en qu\u00e8 est\u00e0 la informaci\u00f3 m\u00e9s resumida: { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda les estacions d'origen, i per una altra les de dest\u00ed . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_18_JSONEscriureBicicas.kt : import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader import java.io.FileWriter fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") val destEstacions = JSONArray() for (e in estacions){ e as JSONObject val destE = JSONObject(); destE.put(\"num\", e.get(\"id\")); destE.put(\"nom\", e.get(\"punto\")); destE.put(\"llocs\", e.get(\"puestos\")); destE.put(\"ocupats\", e.get(\"ocupados\")); val lliures = e.get(\"puestos\") as Int - e.get(\"ocupados\") as Int destE.put(\"lliures\", lliures) destEstacions.put(destE) } val bicicas = JSONObject() bicicas.put(\"bicicas\", destEstacions) val w_json = FileWriter(\"Bicicas2.json\"); w_json.write(bicicas.toString(4)); w_json.close(); } El resultat seria aquest (observeu que hav\u00edem posat una tabulaci\u00f3 de 4): {\"bicicas\": [ { \"num\": \"01\", \"ocupats\": 23, \"llocs\": 28, \"nom\": \"UJI - FCHS\", \"lliures\": 5 }, { \"num\": \"02\", \"ocupats\": 0, \"llocs\": 28, \"nom\": \"ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES\", \"lliures\": 28 }, ... ]} 5.3 Driver Moshi El driver anterior tenia un funcionament molt senzill, per\u00f2 que obliga a seguir en tot moment l'estructura que t\u00e9 el fitxer Json, buscar entre els objectes i arrays cada vegada que es fa un acc\u00e9s. Si s\u00f3n relativament pocs els accessos, \u00e9s molt c\u00f2mode, per\u00f2 si s'ha de fer un acc\u00e9s continuat pot resultar m\u00e9s pesat. Existeix una altra llibreria, que ens permet passar d'un fitxer Json a objectes de Java o Kotlin, la qual cosa ens anir\u00e0 b\u00e9 quan siguen molts els accessos, perqu\u00e8 en definitiva tindrem les dades en l'entorn natural del nostre llenguatge: els objectes. Es tracta de la llibreria MOSHI , i aquest \u00e9s el lloc on poder trobar-la: https://github.com/square/moshi En el moment de fer aquestos apunts, va per la versi\u00f3 1.14.0. Tanmateix en les \u00faltimes versions d\u00f3na un error de compatibilitat. Ens conformarem per tant amb una versi\u00f3 anterior. Podem trobar totes les versions en aquest enlla\u00e7: https://jar-download.com/artifacts/com.squareup.moshi/moshi Podem agafar per exemple versi\u00f3 1.8.0: https://jar-download.com/artifacts/com.squareup.moshi/moshi/1.8.0/source- code Veureu que hi ha dos drivers, el propi de Moshi i un altre driver anomenat okio . Haurem d'incorporar els dos al nostre projecte. Recordeu que la manera d'incorporar els drivers al projecte IntelliJ \u00e9s amb: Sobre el projecte F4 (Project Structure) -- > Modules --> pestanya dependencies --> + 5.3.1 Lectura Com coment\u00e0vem en la pregunta anterior, la llibreria Moshi permet passar d'un document JSON directament a objectes Java o Kotlin. Ho mostrarem en dos exemples: Primer per a poder llegir Empresa.json, en qu\u00e8 l'element arrel \u00e9s un objecte Json. Despr\u00e9s per a llegir Bicicas,json, en qu\u00e8 l'element arrel \u00e9s un array Json, cosa que ens complica un poc la lectura Cas 1: l'arrel \u00e9s un objecte Tant en un com en l'altre primer haurem de crear les classes Java o Kotlin on anir\u00e0 la lectura del fitxer. Aquestes classes hauran de tenir la mateixa estructura que en JSON, per\u00f2 adaptades a Java o Kotlin. Anem per tant a analitzar Empresa.json , que ja el ten\u00edem creat i tenia aquesta estructura: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tamb\u00e9 ten\u00edem creada la classe Empleat, des de la pregunta 3 d'aquest tema, i tenia aquesta estructura. Empleat.kt : class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) L'hav\u00edem fet Serializable , per\u00f2 aix\u00f2 no importa en aquest exemple. El podem deixar tal qual estava. L'estuctura del fitxer JSON, ens marca que l'arrel \u00e9s un objecte que t\u00e9 un \u00fanic membre que es diu empresa , que \u00e9s un objecte que t\u00e9 un \u00fanic membre anomenat empleats , que \u00e9s un array d'objectes (que coincideixen ja amb la classe Empleat ). Per tant ens hem de construir una classe que que tinga una propietat anomenada empleats , que siga un conjunt de Empleat . Ens vindr\u00e0 b\u00e9 un List . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empleats.kt ; class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) I a partir d'aquesta hem de construir una altra classe que tinga una \u00fanica propietat anomenada empresa que siga de tipus Empleats . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empresa.kt class Empresa(val empresa: Empleats) La lectura del fitxer la fem a partir d'un objecte Moshi al qual per mig del m\u00e8tode adapter definim quina classe volem llegir. Una vegada llegit ja podem utilitzar els objectes Java o Kotlin. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_21_MOSHIAnalitzarEmpresa.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val json = File(\"Empresa.json\").readText() val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val empresa = adapter.fromJson(json) val llEmpleats= empresa!!.empresa.empleats println(\"Hi ha \" + llEmpleats.size + \" empleats:\") for (e in llEmpleats) println(e.nom + \" (\" + e.sou +\")\") } Cas 2: l'arrel \u00e9s un array En cas que l'arrel del fitxer JSON siga un array, se'ns complica un poc, perqu\u00e8 en el moment de definir quina classe volem llegir, no \u00e9s en realitat una classe, sin\u00f3 un col\u00b7lecci\u00f3 (un List hav\u00edem vist que \u00e9s el que utilitz\u00e0vem). Moshi utilitza una t\u00e8cnica per a poder fer la lectura de l'array, que consisteix a crear-se un tipus de dades que seria la concatenaci\u00f3 d'un List i de la classe de la qual volem l'array. Ho veurem molt millor en l'exemple. L'exemple ser\u00e0 per a llegir el fitxer Bicicas.json, que recordem que comen\u00e7ava per un array: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39. 99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Era un array d'un \u00fanic element , per\u00f2 en definitiva un array. Nom\u00e9s ens interessa el primer element, que ser\u00e0 un objecte amb un \u00fanic membre anomenat ocupacion , que \u00e9s un array on cada element \u00e9s un objecte corresponent a una estaci\u00f3, amb les seues caracter\u00edstiques com a parelles clau-valor. Definim per tant la classe Estacio.kt : class Estacio( val id: Long, val punto: String, val puestos: Int, val ocupados: Int, val latitud: Double, val longitud: Double, val porcentajeAltaOcupacion: Int, val porcentajeBajaOcupacion: Int ) I la classe Estacions.kt : class Estacions(val ocupacion: List<Estacio> = listOf<Estacio>()) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_22_MOSHIAnalitzarBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val bicicas = adapter.fromJson(json) val estacions = bicicas!!.get(0).ocupacion println(\"Hi ha \" + estacions.size + \" estacions:\") for (e in estacions) println(\"\" + e.id + \": \" + e.punto + \" (\" + e.ocupados + \"/\" + e.puestos + \")\") } 5.3.2 Escriptura Tamb\u00e9 farem 2 exemples d'escriptura, el d'Empleats i el de Bicicas, els mateixos que en la pregunta 5.2.2 Cas 1: Empleats Per a Empleats.json aquest \u00e9s l'estructura que volem aconseguir: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } L'estructura de les classes ser\u00e0 la mateixa que en el cas de la lectura, per\u00f2 ara les dades estaran definides en 4 arrays. A partir dels arrays inicialitzarem els objectes Kotlin, i quan ho tinguem tot ple passarem a JSON. NO HEM DE DEFINIR LES CLASSES, ja que les tenim definides des punt 5.3.1. Les posem ac\u00ed \u00fanicament per a il\u00b7lustrar: class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) class Empresa(val empresa: Empleats) Aleshores, inicialitzem els objectes a partir de les dades que tenim en els 4 arrays, i despr\u00e9s guardem en JSON. Mireu que la definici\u00f3 de les classes de Moshi \u00e9s la mateixa, per\u00f2 ara utilitzem el m\u00e8tode toJson() per a passar d'objectes Kotlin a JSON. Obtenim un String que \u00e9s la cadena JSON, i senzillament l'escrivim en un fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_23_MOSHIEscriureEmpleats.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) val empleats = arrayListOf<Empleat>() for (i in 0..3) empleats.add(Empleat((i+1),noms[i],departaments[i],edats[i],sous[i])) val empresa = Empresa(Empleats(empleats)) val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val json = adapter.toJson(empresa) File(\"Empleats2.json\").writeText(json) } Cas 2: Bicicas Farem el mateix exercici que en l'apartat 5.2.2, per\u00f2 ara utilitzant la llibreria Moshi . Voldrem aconseguir aquesta estructura i guardar-la en el fitxer { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda l'estructura d'origen, per a la qual utilitzem les classes ja definides en l'apartat 5.3.1, \u00e9s a dir, per a llegir el fitxer Bicicas.json original fem el mateix que l'altra vegada, per tant ser\u00e0 copiar les primeres sent\u00e8ncies del programa Exemple_3_5_22_MOSHIAnalitzarBicicas.kt . A partir dels objectes inicialitzats amb la lectura de Bicicas.json, construirem els objectes que ens serviran per a l'escriptura. L'estructura d'aquestes classes que ens serviran per a l'escriptura seran: class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) Per comoditat, com que nom\u00e9s anem a utilitzar-les en aquesta ocasi\u00f3, les definirem en el mateix fitxer del programa. Observeu com senzillament llegim passant a les classes d'entrada, convertim a les classes d'eixida, i utilitzem aquestes \u00faltimes per escriure el fitxer. Copieu el seg\u00fcent codi en el fitxer Kotlin anomenat Exemple_3_5_24_MOSHIEscriureBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() val bicicas2 = Bicicas2(llistaEstDesti) for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val adapter2 = moshi.adapter(Bicicas2::class.java) val json2 = adapter2.toJson(bicicas2) File(\"Bicicas2.json\").writeText(json2) } Segurament aquesta estructura \u00e9s la m\u00e9s coherent. Amb la finalitat \u00fanicament d'escriure un JSON que t\u00e9 com a arrel un array i no un objecte, anem a ferun altre exemple en el qual guardarem en un fitxer aquesta estructura: [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] En aquesta ocasi\u00f3 tenim nom\u00e9s un array d'objectes. L'\u00fanica estructura d'eixida que ens cal \u00e9s la classe EstDesti , ja definida en l'exercici anterior, i per tant ara no caldr\u00e0 definir-la. Nom\u00e9s hem d'anar amb compte amb l'estructura d'eixida, que ara no ser\u00e0 una classe sin\u00f3 una combinaci\u00f3 de List i EstDesti . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_25_MOSHIEscriureBicicas3.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val llistaTipusDesti = Types.newParameterizedType(List::class.java, EstDesti::class.java) val adapter2: JsonAdapter<List<EstDesti>> = moshi.adapter(llistaTipusDesti) val json2 = adapter2.toJson(llistaEstDesti) File(\"Bicicas3.json\").writeText(json2) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.- Documents JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#5-documents-json","text":"JSON vol dir J ava S cript O bject N otation , \u00e9s a dir Notaci\u00f3 d'Objectes de JavaScript. \u00c9s una manera de representar objectes inicialment per a JavaScript, per\u00f2 per la seua senzillesa, i com \u00e9s en text pla, serveix per a qualsevol entorn. Permet representar estructures de dades d'una determinada complexitat, com el XML, per\u00f2 pesa molt menys que aquest, i per aix\u00f2 est\u00e0 convertint-se en un est\u00e0ndar d'intercanvi de dades, sobretot entre un servidor i una aplicaci\u00f3 web. L'extensi\u00f3 d'un fitxer JSON \u00e9s .json","title":"5.- Documents JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#51-estructura-json","text":"Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu","title":"5.1 - Estructura JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#52-driver-orgjson","text":"Hi ha m\u00e9s d'una llibreria per a poder accedir i analitzar els documents json. Per exemple, es comenten prou per Internet s\u00f3n GSON (de Google) i Jackson . Per\u00f2 nosaltres anem a utilitzar dues altres llibreries Una, la del grup org.json que en principi ser\u00e0 la mateixa que s'utilitzar\u00e0 en Android Una altra, la de Moshi , que ens permetr\u00e0 elaborar m\u00e9s el resultat ja que podrem fer una conversi\u00f3 entre Json i objectes de Java o de Kotlin Pel que fa a la primera, en el moment de fer aquestos apunts l'\u00faltima versi\u00f3 estable \u00e9s la 20240303 , \u00e9s a dir, de mar\u00e7 de 2024. En aquest enlla\u00e7 teniu d'on us la podeu baixar: https://jar-download.com/artifacts/org.json/json . Una vegada baixada l'haurem d'incorporar al nostre projecte (sobre el projecte F4 -- > Modules --> pestanya dependencies --> + ) En ella trobem el m\u00e9s b\u00e0sic: JSONObject : equivaldr\u00e0 a un objecte JSONArray : equivaldr\u00e0 a un array JSONTokener :ens permetr\u00e0 analitzar el document Json, i tornar\u00e0 l'objecte arrel. El m\u00e8tode que utilitzarem ser\u00e0 sempre nextValue() .","title":"5.2 Driver org.json"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#521-lectura","text":"JSONTokener El primer que haurem de fer ser\u00e0 analitzar el document per a obtenir l'element arrel (que com hem vist normalment ser\u00e0 un objecte, per\u00f2 de vegades pot ser un array). El constructor de JSONTokener admet un String , amb la qual cosa analitzarem una cadena que posem directament, o tamb\u00e9 un InputStream o un Reader , amb la qual cosa podrem analitzar directament el contingut d'un fitxer El m\u00e8tode nextValue() de JSONTokener tornar\u00e0 l'arrel del document Json, i nom\u00e9s haurem de fer un cast a l'ojecte que \u00e9s l'arrel: un JSONObject o un JSONArray En el seg\u00fcent exemple agafem el json directament d'un string , on ten\u00edem els n\u00fameros parells. { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } Observeu com per a la definici\u00f3 del String ens ha tocat escapar les dobles cometes. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_11_JSONAnalitzarCadena.kt package exemples import org.json.JSONTokener import org.json.JSONObject fun main(args: Array<String>) { val cadena = \"{ \\\"p1\\\" : 2 , \\\"p2\\\" : 4 , \\\"p3\\\" : 6 , \\\"p4\\\" : 8 , \\\"p5\\\" : 10 }\" val arrel = JSONTokener(cadena).nextValue() as JSONObject println(arrel.get(\"p1\")) } Mentre que en aquest exemple accedim al fitxer parelles.json (que assumirem que t\u00e9 el mateix contingut). Podr\u00edem passar el contingut del fitxer a una cadena, per\u00f2 \u00e9s molt m\u00e9s c\u00f2mode passar el Reader com par\u00e0metre en el constructor, i ell s'encarrega de llegir-lo tot. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_12_JSONAnalitzarFitxer.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"parelles.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject println(arrel.get(\"p3\")); } JSONObject Contindr\u00e0 un objecte json . Recordeu que l' objecte es delimita amb les claus: { } El m\u00e8tode m\u00e9s important ser\u00e0 get( clau ) al qual li passem la clau del membre que volem obtenir. Si el membre \u00e9s una parella clau-valor, obtindrem directament el valor. Si \u00e9s un altre objecte, doncs obtindrem l'objecte o tamb\u00e9 podria ser un array. El cas que siga una parella clau-valor, ja l'hem vist en l'exemple anterior. En el seg\u00fcent exemple, en el fitxer Empleat.json tindrem un empleat { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } Observeu com ara de l'element arrel hem d'agafar empleat , que \u00e9s un objecte amb les parelles clau-valor num , nom , .... Copieu el seg\u00faent codi en el fitxer Kotlin Exemple_3_5_13_JSONAnalitzarEmpleat.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empleat.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empleat = arrel.get(\"empleat\") as JSONObject println(\"\" + empleat.get(\"nom\") + \" (\" + empleat.get(\"sou\") + \")\") } Tamb\u00e9 podem utilitzar els m\u00e8todes getJSONObject() , getJSONArray , getInt() , getString() , ..., que directament ens ho d\u00f3na en el tipus especificat, i no cal fer cast. JSONArray Ser\u00e0 l'array, que recordem que ve limitat per els claud\u00e0tors: [ ] Per a obtenir els elements de l'array utilitzarem el m\u00e8tode get( index ) , on l'\u00edndex \u00e9s el n\u00famero d'ordre de l'element que volem obtenir. Tamb\u00e9 tindrem els m\u00e8todes getJSONObject( index ) , getJSONArray( index ) , getInt( index ) , ..., que tornen directament el tipus especificat Posem el primer exemple sobre un json que nom\u00e9s t\u00e9 un array els elements del qual s\u00f3n valors: [ 5 , 7 , 8 , 7 ] Observeu com ara l'arrel \u00e9s un Array, i ens muntem un bucle per obtenir tots els elements. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_14_JSONAnalitzarArray.kt package exemples import org.json.JSONTokener import org.json.JSONArray fun main(args: Array<String>) { val cadena = \"[ 5 , 7 , 8 , 7 ]\" val arrel = JSONTokener(cadena).nextValue() as JSONArray for (i in arrel) println(i) } Com veieu podem fer servir els bucles foreach, per\u00f2 lamentablement no podem obtenir directament un JsonObject, i per tant l'hem de reconvertir. Ho mostrarem en el seg\u00fcent exemple en el qual agafem tots els empleats de l'empresa, on Empresa.json \u00e9s aix\u00ed: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic membre empleat que \u00e9s un array amb 4 elements, cadascun dels empleats. Copieu el seg\u00fcent exemple en el fitxer kotlin Exemple_3_5_15_JSONAnalitzarEmpresa.kt package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empresa.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empresa = arrel.getJSONObject(\"empresa\") for (e in empresa.getJSONArray(\"empleats\")){ val emp = e as JSONObject println(\"\" + emp.get(\"nom\") + \" (\" + emp.get(\"sou\") + \")\") } } Mireu com ens hem estalviat un pas, i no hem definit la variable empleats , sin\u00f3 que ho especifiquem en el bucle. Tamb\u00e9 podr\u00edem haver estalviat la variable empresa si en el bucle hagu\u00e9rem posat : for (e in arrel.getJSONObject(\"empresa\").getJSONArray(\"empleats\")){ Exemple m\u00e9s complet Mirem algun exemple ja m\u00e9s elaborat, on ens tocar\u00e0 analitzar amb detall l'estructura json. Fem-lo sobre l'exemple de BICICAS . Podeu tornar a fer la consulta de l'estat actual en aquest moment a la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php , seleccionar-ho tot i guardar-lo en el fitxer Bicicas.json . \u00c9s molt possible que tinguem problemes amb els car\u00e0cers especials, com les vocals accentuades, a causa de que el navegador utilitzat no les reconega, i en copiar-les al fitxer no tinguem ja la codificaci\u00f3 correcta. No li donarem import\u00e0ncia en aquest moment. Recordem ac\u00ed l'estructura: [ {\"ocupacion\": [{\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\", \"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\", porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podem observar, comen\u00e7a per un array , no per un objecte, com sol ser habitual. L'\u00fanic que ens interessa \u00e9s el primer element de l'array, ja que en posteriors anirien en tot cas missatges. El primer element \u00e9s un objecte que t\u00e9 un \u00fanic membre ocupacion (o si en t\u00e9 m\u00e9s no ens interessen), que \u00e9s un array amb totes les estacions. Cada estaci\u00f3 \u00e9s un objecte amb la informaci\u00f3 que ens interessa. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_16_JSONAnalitzarBicicas.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") for (e in estacions){ val est = e as JSONObject println(\"\" + e.get(\"id\") + \".- \" + e.get(\"punto\") + \" (\" + e.get(\"ocupados\") + \"/\" + e.get(\"puestos\") + \")\") } } Hem agafat l'array, d'ell hem agafat el primer objecte i d'ell l'array. I hem utilitzat un bucle for , per a tots els valors de l'array","title":"5.2.1 - Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#522-escriptura","text":"Ens falta veure com escriure un document JSON. \u00c9s molt f\u00e0cil anar creant l'estructura JSON. Nom\u00e9s hem de recordar la manera d'afegir al JSONObject i al JSONArray . put(\"nom\", element) per afegir un nou membre a un JSONObject put(element) per afegir un nou element a un JSONArray Nota La major part de drivers utilitzen add(element) per a afegir un element a un JSONArray, en compte de put Una vegada tinguem l'estructura, podrem passar-la a un string amb el m\u00e8tode toString , i la podrem guardar directament en un fitxer, per exemple. Farem m\u00e9s d'un exemple, per poder practicar. En el primer exemple generarem un JSON a partir de dades definides en el mateix programa, per mig de vectors. Intentarem generar aquest fitxer JSON: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Analitzem l'estructura. Tenim un objecte arrel, que consta d'un \u00fanic membre, empresa, que \u00e9s un objecte. Aquest objecte t\u00e9 un \u00fanic membre que \u00e9s un array. Cada element de l'array \u00e9s un objecte, i els seus membres ja s\u00f3n clau-valor. Copieu el seg\u00fcent codi en el fitxer kotlin Exemple_3_5_17_JSONEscriureEmpleats.kt : import org.json.JSONObject import org.json.JSONArray import java.io.FileWriter fun main(args: Array<String>) { val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0) val arrel = JSONObject() val empresa = JSONObject() arrel.put(\"empresa\", empresa) val empleats = JSONArray() empresa.put(\"empleat\", empleats) for (i in 0..3){ val emp = JSONObject() emp.put(\"num\", i + 1) emp.put(\"nom\", noms[i]) emp.put(\"departament\", departaments[i]) emp.put(\"edat\", edats[i]) emp.put(\"sou\", sous[i]) empleats.put(emp) } val f = FileWriter(\"Empleats.json\") f.write(arrel.toString(4)) f.close() } Hem posat en el moment de passar el JSONObject a String el par\u00e0metre 4, per a que idente en diferents linies a 4 espais. Com veureu el resultat \u00e9s quasi perfecte {\"empresa\": {\"empleat\": [ { \"num\": 1, \"sou\": 1000, \"nom\": \"Andreu\", \"edat\": 32, \"departament\": 10 }, { \"num\": 2, \"sou\": 1200, \"nom\": \"Bernat\", \"edat\": 28, \"departament\": 20 }, { \"num\": 3, \"sou\": 1100, \"nom\": \"Cl\u00e0udia\", \"edat\": 26, \"departament\": 10 }, { \"num\": 4, \"sou\": 1500, \"nom\": \"Dami\u00e0\", \"edat\": 40, \"departament\": 10 } ]}} Tenim el problema aparent que els membres de cada empleat estan desordenats . No \u00e9s que haja eixit malament, perqu\u00e8 hem de recordar que un objecte JSON \u00e9s un conjunt no ordenat de membres. Exemple BICICAS Un altre exemple, el de Bicicas , i el que farem per a practicar tant la lectura com l'escriptura, ser\u00e0 donar-li una altra estructura. Per tant llegirem l'original, i anirem construint la seg\u00fcent estructura en qu\u00e8 est\u00e0 la informaci\u00f3 m\u00e9s resumida: { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda les estacions d'origen, i per una altra les de dest\u00ed . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_18_JSONEscriureBicicas.kt : import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader import java.io.FileWriter fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") val destEstacions = JSONArray() for (e in estacions){ e as JSONObject val destE = JSONObject(); destE.put(\"num\", e.get(\"id\")); destE.put(\"nom\", e.get(\"punto\")); destE.put(\"llocs\", e.get(\"puestos\")); destE.put(\"ocupats\", e.get(\"ocupados\")); val lliures = e.get(\"puestos\") as Int - e.get(\"ocupados\") as Int destE.put(\"lliures\", lliures) destEstacions.put(destE) } val bicicas = JSONObject() bicicas.put(\"bicicas\", destEstacions) val w_json = FileWriter(\"Bicicas2.json\"); w_json.write(bicicas.toString(4)); w_json.close(); } El resultat seria aquest (observeu que hav\u00edem posat una tabulaci\u00f3 de 4): {\"bicicas\": [ { \"num\": \"01\", \"ocupats\": 23, \"llocs\": 28, \"nom\": \"UJI - FCHS\", \"lliures\": 5 }, { \"num\": \"02\", \"ocupats\": 0, \"llocs\": 28, \"nom\": \"ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES\", \"lliures\": 28 }, ... ]}","title":"5.2.2 - Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#53-driver-moshi","text":"El driver anterior tenia un funcionament molt senzill, per\u00f2 que obliga a seguir en tot moment l'estructura que t\u00e9 el fitxer Json, buscar entre els objectes i arrays cada vegada que es fa un acc\u00e9s. Si s\u00f3n relativament pocs els accessos, \u00e9s molt c\u00f2mode, per\u00f2 si s'ha de fer un acc\u00e9s continuat pot resultar m\u00e9s pesat. Existeix una altra llibreria, que ens permet passar d'un fitxer Json a objectes de Java o Kotlin, la qual cosa ens anir\u00e0 b\u00e9 quan siguen molts els accessos, perqu\u00e8 en definitiva tindrem les dades en l'entorn natural del nostre llenguatge: els objectes. Es tracta de la llibreria MOSHI , i aquest \u00e9s el lloc on poder trobar-la: https://github.com/square/moshi En el moment de fer aquestos apunts, va per la versi\u00f3 1.14.0. Tanmateix en les \u00faltimes versions d\u00f3na un error de compatibilitat. Ens conformarem per tant amb una versi\u00f3 anterior. Podem trobar totes les versions en aquest enlla\u00e7: https://jar-download.com/artifacts/com.squareup.moshi/moshi Podem agafar per exemple versi\u00f3 1.8.0: https://jar-download.com/artifacts/com.squareup.moshi/moshi/1.8.0/source- code Veureu que hi ha dos drivers, el propi de Moshi i un altre driver anomenat okio . Haurem d'incorporar els dos al nostre projecte. Recordeu que la manera d'incorporar els drivers al projecte IntelliJ \u00e9s amb: Sobre el projecte F4 (Project Structure) -- > Modules --> pestanya dependencies --> +","title":"5.3 Driver Moshi"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#531-lectura","text":"Com coment\u00e0vem en la pregunta anterior, la llibreria Moshi permet passar d'un document JSON directament a objectes Java o Kotlin. Ho mostrarem en dos exemples: Primer per a poder llegir Empresa.json, en qu\u00e8 l'element arrel \u00e9s un objecte Json. Despr\u00e9s per a llegir Bicicas,json, en qu\u00e8 l'element arrel \u00e9s un array Json, cosa que ens complica un poc la lectura Cas 1: l'arrel \u00e9s un objecte Tant en un com en l'altre primer haurem de crear les classes Java o Kotlin on anir\u00e0 la lectura del fitxer. Aquestes classes hauran de tenir la mateixa estructura que en JSON, per\u00f2 adaptades a Java o Kotlin. Anem per tant a analitzar Empresa.json , que ja el ten\u00edem creat i tenia aquesta estructura: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tamb\u00e9 ten\u00edem creada la classe Empleat, des de la pregunta 3 d'aquest tema, i tenia aquesta estructura. Empleat.kt : class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) L'hav\u00edem fet Serializable , per\u00f2 aix\u00f2 no importa en aquest exemple. El podem deixar tal qual estava. L'estuctura del fitxer JSON, ens marca que l'arrel \u00e9s un objecte que t\u00e9 un \u00fanic membre que es diu empresa , que \u00e9s un objecte que t\u00e9 un \u00fanic membre anomenat empleats , que \u00e9s un array d'objectes (que coincideixen ja amb la classe Empleat ). Per tant ens hem de construir una classe que que tinga una propietat anomenada empleats , que siga un conjunt de Empleat . Ens vindr\u00e0 b\u00e9 un List . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empleats.kt ; class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) I a partir d'aquesta hem de construir una altra classe que tinga una \u00fanica propietat anomenada empresa que siga de tipus Empleats . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empresa.kt class Empresa(val empresa: Empleats) La lectura del fitxer la fem a partir d'un objecte Moshi al qual per mig del m\u00e8tode adapter definim quina classe volem llegir. Una vegada llegit ja podem utilitzar els objectes Java o Kotlin. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_21_MOSHIAnalitzarEmpresa.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val json = File(\"Empresa.json\").readText() val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val empresa = adapter.fromJson(json) val llEmpleats= empresa!!.empresa.empleats println(\"Hi ha \" + llEmpleats.size + \" empleats:\") for (e in llEmpleats) println(e.nom + \" (\" + e.sou +\")\") } Cas 2: l'arrel \u00e9s un array En cas que l'arrel del fitxer JSON siga un array, se'ns complica un poc, perqu\u00e8 en el moment de definir quina classe volem llegir, no \u00e9s en realitat una classe, sin\u00f3 un col\u00b7lecci\u00f3 (un List hav\u00edem vist que \u00e9s el que utilitz\u00e0vem). Moshi utilitza una t\u00e8cnica per a poder fer la lectura de l'array, que consisteix a crear-se un tipus de dades que seria la concatenaci\u00f3 d'un List i de la classe de la qual volem l'array. Ho veurem molt millor en l'exemple. L'exemple ser\u00e0 per a llegir el fitxer Bicicas.json, que recordem que comen\u00e7ava per un array: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39. 99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Era un array d'un \u00fanic element , per\u00f2 en definitiva un array. Nom\u00e9s ens interessa el primer element, que ser\u00e0 un objecte amb un \u00fanic membre anomenat ocupacion , que \u00e9s un array on cada element \u00e9s un objecte corresponent a una estaci\u00f3, amb les seues caracter\u00edstiques com a parelles clau-valor. Definim per tant la classe Estacio.kt : class Estacio( val id: Long, val punto: String, val puestos: Int, val ocupados: Int, val latitud: Double, val longitud: Double, val porcentajeAltaOcupacion: Int, val porcentajeBajaOcupacion: Int ) I la classe Estacions.kt : class Estacions(val ocupacion: List<Estacio> = listOf<Estacio>()) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_22_MOSHIAnalitzarBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val bicicas = adapter.fromJson(json) val estacions = bicicas!!.get(0).ocupacion println(\"Hi ha \" + estacions.size + \" estacions:\") for (e in estacions) println(\"\" + e.id + \": \" + e.punto + \" (\" + e.ocupados + \"/\" + e.puestos + \")\") }","title":"5.3.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#532-escriptura","text":"Tamb\u00e9 farem 2 exemples d'escriptura, el d'Empleats i el de Bicicas, els mateixos que en la pregunta 5.2.2 Cas 1: Empleats Per a Empleats.json aquest \u00e9s l'estructura que volem aconseguir: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } L'estructura de les classes ser\u00e0 la mateixa que en el cas de la lectura, per\u00f2 ara les dades estaran definides en 4 arrays. A partir dels arrays inicialitzarem els objectes Kotlin, i quan ho tinguem tot ple passarem a JSON. NO HEM DE DEFINIR LES CLASSES, ja que les tenim definides des punt 5.3.1. Les posem ac\u00ed \u00fanicament per a il\u00b7lustrar: class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) class Empresa(val empresa: Empleats) Aleshores, inicialitzem els objectes a partir de les dades que tenim en els 4 arrays, i despr\u00e9s guardem en JSON. Mireu que la definici\u00f3 de les classes de Moshi \u00e9s la mateixa, per\u00f2 ara utilitzem el m\u00e8tode toJson() per a passar d'objectes Kotlin a JSON. Obtenim un String que \u00e9s la cadena JSON, i senzillament l'escrivim en un fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_23_MOSHIEscriureEmpleats.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) val empleats = arrayListOf<Empleat>() for (i in 0..3) empleats.add(Empleat((i+1),noms[i],departaments[i],edats[i],sous[i])) val empresa = Empresa(Empleats(empleats)) val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val json = adapter.toJson(empresa) File(\"Empleats2.json\").writeText(json) } Cas 2: Bicicas Farem el mateix exercici que en l'apartat 5.2.2, per\u00f2 ara utilitzant la llibreria Moshi . Voldrem aconseguir aquesta estructura i guardar-la en el fitxer { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda l'estructura d'origen, per a la qual utilitzem les classes ja definides en l'apartat 5.3.1, \u00e9s a dir, per a llegir el fitxer Bicicas.json original fem el mateix que l'altra vegada, per tant ser\u00e0 copiar les primeres sent\u00e8ncies del programa Exemple_3_5_22_MOSHIAnalitzarBicicas.kt . A partir dels objectes inicialitzats amb la lectura de Bicicas.json, construirem els objectes que ens serviran per a l'escriptura. L'estructura d'aquestes classes que ens serviran per a l'escriptura seran: class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) Per comoditat, com que nom\u00e9s anem a utilitzar-les en aquesta ocasi\u00f3, les definirem en el mateix fitxer del programa. Observeu com senzillament llegim passant a les classes d'entrada, convertim a les classes d'eixida, i utilitzem aquestes \u00faltimes per escriure el fitxer. Copieu el seg\u00fcent codi en el fitxer Kotlin anomenat Exemple_3_5_24_MOSHIEscriureBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() val bicicas2 = Bicicas2(llistaEstDesti) for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val adapter2 = moshi.adapter(Bicicas2::class.java) val json2 = adapter2.toJson(bicicas2) File(\"Bicicas2.json\").writeText(json2) } Segurament aquesta estructura \u00e9s la m\u00e9s coherent. Amb la finalitat \u00fanicament d'escriure un JSON que t\u00e9 com a arrel un array i no un objecte, anem a ferun altre exemple en el qual guardarem en un fitxer aquesta estructura: [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] En aquesta ocasi\u00f3 tenim nom\u00e9s un array d'objectes. L'\u00fanica estructura d'eixida que ens cal \u00e9s la classe EstDesti , ja definida en l'exercici anterior, i per tant ara no caldr\u00e0 definir-la. Nom\u00e9s hem d'anar amb compte amb l'estructura d'eixida, que ara no ser\u00e0 una classe sin\u00f3 una combinaci\u00f3 de List i EstDesti . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_25_MOSHIEscriureBicicas3.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val llistaTipusDesti = Types.newParameterizedType(List::class.java, EstDesti::class.java) val adapter2: JsonAdapter<List<EstDesti>> = moshi.adapter(llistaTipusDesti) val json2 = adapter2.toJson(llistaEstDesti) File(\"Bicicas3.json\").writeText(json2) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/","text":"Exercicis Exercici T3_1 En el projecte anomenat Tema3 , crea't un paquet anomenat exercicis on col\u00b7locarem tot el relatiu als exercicis d'aquest tema. Copia't dins del projecte el fitxer Rutes.dat que us passar\u00e0 el professor. En ell tenim dades pr\u00e8viament guardades que seran unes rutes consistents en una s\u00e8rie de punts amb una descripci\u00f3. Cada punt seran unes coordenades (com en un mapa). L'estructura de les dades guardades \u00e9s la seg\u00fcent nom de la ruta (string) desnivell (int) desnivell acumulat (int) n\u00famero de punts (int) Per cada punt: nom (string) latitud (double) longitud (double) Observa que la quarta dada \u00e9s un enter amb el n\u00famero de punts de la ruta. Fes un programa (amb fun main() ) en el fitxer Kotlin Ex3_1_LlegirRutesSerial.kt que agafe les dades del fitxer (hi ha 2 rutes, per\u00f2 ho heu de fer gen\u00e8ric per a un n\u00famero indeterminat de rutes) i les traga per pantalla amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) Ruta: La Magdalena Desnivell: 51 Desnivell acumulat: 84 T\u00e9 7 punts Punt 1: Primer Mol\u00ed (39.99385,-0.032941) Punt 2: Segon Mol\u00ed (39.99628,-0.029427) Punt 3: Camin\u00e0s (40.00513,-0.022569) Punt 4: Riu Sec (40.006765,-0.02237) Punt 5: Sant Roc (40.017906,-0.02289) Punt 6: Explanada (40.034048,-0.00633) Punt 7: La Magdalena (40.034519,-0.005856) Exercici T3_2 Construeix les seg\u00fcents classes: Coordenades , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar- li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: latitud (double) longitud (double) No caldr\u00e0 contructor, ni getters ni setters, ja que Kotlin els genera autom\u00e0ticament PuntGeo , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar-li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: nom (String) coord (Coordenades) Ruta . Aquesta classe us la passar\u00e0 el professor. Tamb\u00e9 implementa Serializable i cont\u00e9: nom (String)**** desnivell (int) desnivellAcumulat (int) llistaDePunts : un ArrayList de PuntGeo Observa com per a m\u00e9s comoditat t\u00e9 els m\u00e8todes: addPunt(PuntGeo) , que afegir\u00e0 un nou PuntGeo a la llista getPunt(int) , al qual se li passa l'\u00edndex del punt que es vol i torna tot aquest punt getPuntNom(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 el seu nom getPuntLatitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua latitud getPuntLongitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua longitud size() , que ens d\u00f3na el n\u00famero de punts guardats en la llista. L'\u00fanic que has de fer en aquesta classe \u00e9s: Fes un m\u00e8tode nou en la classe Ruta anomenat mostraRuta() , que mostre el contingut de la ruta amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell Acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) En un fitxer Kotlin anomenat Ex3_2_PassarRutesSerialObj.kt , fes el programa que passe del fitxe Rutes.dat al fitxer Rutes.obj . \u00c9s a dir, has d'anar agafant la informaci\u00f3 del fitxer Rutes.dat , guardar la informaci\u00f3 en un objecte Ruta , visualitzar la seua informaci\u00f3 amb mostraRuta() i per \u00faltim guardar la informaci\u00f3 de l'objecte en un fitxer anomenat Rutes.obj . I aix\u00f2 fins el final de fitxer (hi ha 2 rutes) En un fitxer Kotlin anomenat Ex3_2_LlegirRutesObj.kt , llig les rutes guardades en el fitxer Rutes.obj i mostra-les per pantalla utilitzant el m\u00e8tode mostraRuta() Exercici T3_3 Fes un programa en el fitxer Ex3_3_PassarRutesObjXML.kt (amb main) que passe el fitxer Rutes.obj a un fitxer XML anomenat Rutes.xml amb aquest aspecte. Els punts suspensius indiquen que hi ha m\u00e9s d'un punt en cada ruta, i que hi ha m\u00e9s d'una ruta <rutes> <ruta> <nom>Pujada a Penyagolosa</nom> <desnivell>530</desnivell> <desnivellAcumulat>530</desnivellAcumulat> <punts> <punt num=\"1\"> <nom>Sant Joan</nom> <latitud>...</latitud> <longitud>...</longitud> </punt> ... </punts> </ruta> ... </rutes> Exercici T3_4 Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.xml per a que apareguen els noms de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas ens conv\u00e9 getSelectedIndex() , ja que el n\u00famero d'ordre de l'element seleccionat ser\u00e0 el mateix que el n\u00famero d'ordre de la ruta que busquem en el NodeList doc.getElementsByTagName(\"ruta\") L'esquelet del programa seria aquest. Copieu-lo en un fitxer Kotlin anomenat Ex3_4_VisRutesXML.kt : import javax.swing.* import java.awt.* import org.w3c.dom.Document import org.w3c.dom.Element import javax.xml.parsers.DocumentBuilderFactory class Finestra : JFrame() { init { var doc: Document // sent\u00e8ncies per a omplir doc defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1,BorderLayout.NORTH) add(panell2,BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(llistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener{ // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } } Exercici T3_5 Fer un programa en el fitxer Kotlin Ex3_5_PassarRutesObjJSON.kt que passe el fitxer Rutes.obj a un fitxer JSON Rutes.json amb aquest aspecte: { \"rutes\": [ { \"nom\": \"Pujada a Penyagolosa\", \"desnivell\": 530, \"desnivellAcumulat\": 530, \"llistaDePunts\": [ { \"nom\": \"Sant Joan\", \"coord\": { \"latitud\": 40.251036, \"longitud\": -0.354223 } }, ... ] }, ... ] } Com que ja tenim creades les classes Ruta , PuntGeo i Coord , el m\u00e9s c\u00f2mode ser\u00e0 utilitzar Moshi . Tan sols ens far\u00e0 falta una classe que ho englobe tot: class Rutes(var rutes: MutableList<Ruta> = mutableListOf<Ruta>()) Exercici T3_6 Replicar l'exercici 3_4, per\u00f2 ara llegint del fitxer Rutes.json , en compte de Rutes.xml Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.json i que aparega el nom de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas, igual que en l'exercici 3_4, ens conv\u00e9 getSelectedIndex() . I com que ja tenim definides les classes, ens conv\u00e9 utilitzar Moshi . Aquest seria l'esquelet del programa. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Ex3_6_VisRutaJSON.kt : import javax.swing.* import java.awt.* import com.squareup.moshi.Moshi import java.io.File class FinestraJSON : JFrame() { init { var llistaRutes: ArrayList<Ruta> // sent\u00e8ncies per a omplir llistaRutes defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) var nomsLlistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(nomsLlistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"), BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener { // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraJSON().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_1","text":"En el projecte anomenat Tema3 , crea't un paquet anomenat exercicis on col\u00b7locarem tot el relatiu als exercicis d'aquest tema. Copia't dins del projecte el fitxer Rutes.dat que us passar\u00e0 el professor. En ell tenim dades pr\u00e8viament guardades que seran unes rutes consistents en una s\u00e8rie de punts amb una descripci\u00f3. Cada punt seran unes coordenades (com en un mapa). L'estructura de les dades guardades \u00e9s la seg\u00fcent nom de la ruta (string) desnivell (int) desnivell acumulat (int) n\u00famero de punts (int) Per cada punt: nom (string) latitud (double) longitud (double) Observa que la quarta dada \u00e9s un enter amb el n\u00famero de punts de la ruta. Fes un programa (amb fun main() ) en el fitxer Kotlin Ex3_1_LlegirRutesSerial.kt que agafe les dades del fitxer (hi ha 2 rutes, per\u00f2 ho heu de fer gen\u00e8ric per a un n\u00famero indeterminat de rutes) i les traga per pantalla amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) Ruta: La Magdalena Desnivell: 51 Desnivell acumulat: 84 T\u00e9 7 punts Punt 1: Primer Mol\u00ed (39.99385,-0.032941) Punt 2: Segon Mol\u00ed (39.99628,-0.029427) Punt 3: Camin\u00e0s (40.00513,-0.022569) Punt 4: Riu Sec (40.006765,-0.02237) Punt 5: Sant Roc (40.017906,-0.02289) Punt 6: Explanada (40.034048,-0.00633) Punt 7: La Magdalena (40.034519,-0.005856)","title":"Exercici T3_1"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_2","text":"Construeix les seg\u00fcents classes: Coordenades , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar- li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: latitud (double) longitud (double) No caldr\u00e0 contructor, ni getters ni setters, ja que Kotlin els genera autom\u00e0ticament PuntGeo , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar-li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: nom (String) coord (Coordenades) Ruta . Aquesta classe us la passar\u00e0 el professor. Tamb\u00e9 implementa Serializable i cont\u00e9: nom (String)**** desnivell (int) desnivellAcumulat (int) llistaDePunts : un ArrayList de PuntGeo Observa com per a m\u00e9s comoditat t\u00e9 els m\u00e8todes: addPunt(PuntGeo) , que afegir\u00e0 un nou PuntGeo a la llista getPunt(int) , al qual se li passa l'\u00edndex del punt que es vol i torna tot aquest punt getPuntNom(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 el seu nom getPuntLatitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua latitud getPuntLongitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua longitud size() , que ens d\u00f3na el n\u00famero de punts guardats en la llista. L'\u00fanic que has de fer en aquesta classe \u00e9s: Fes un m\u00e8tode nou en la classe Ruta anomenat mostraRuta() , que mostre el contingut de la ruta amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell Acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) En un fitxer Kotlin anomenat Ex3_2_PassarRutesSerialObj.kt , fes el programa que passe del fitxe Rutes.dat al fitxer Rutes.obj . \u00c9s a dir, has d'anar agafant la informaci\u00f3 del fitxer Rutes.dat , guardar la informaci\u00f3 en un objecte Ruta , visualitzar la seua informaci\u00f3 amb mostraRuta() i per \u00faltim guardar la informaci\u00f3 de l'objecte en un fitxer anomenat Rutes.obj . I aix\u00f2 fins el final de fitxer (hi ha 2 rutes) En un fitxer Kotlin anomenat Ex3_2_LlegirRutesObj.kt , llig les rutes guardades en el fitxer Rutes.obj i mostra-les per pantalla utilitzant el m\u00e8tode mostraRuta()","title":"Exercici T3_2"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_3","text":"Fes un programa en el fitxer Ex3_3_PassarRutesObjXML.kt (amb main) que passe el fitxer Rutes.obj a un fitxer XML anomenat Rutes.xml amb aquest aspecte. Els punts suspensius indiquen que hi ha m\u00e9s d'un punt en cada ruta, i que hi ha m\u00e9s d'una ruta <rutes> <ruta> <nom>Pujada a Penyagolosa</nom> <desnivell>530</desnivell> <desnivellAcumulat>530</desnivellAcumulat> <punts> <punt num=\"1\"> <nom>Sant Joan</nom> <latitud>...</latitud> <longitud>...</longitud> </punt> ... </punts> </ruta> ... </rutes>","title":"Exercici T3_3"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_4","text":"Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.xml per a que apareguen els noms de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas ens conv\u00e9 getSelectedIndex() , ja que el n\u00famero d'ordre de l'element seleccionat ser\u00e0 el mateix que el n\u00famero d'ordre de la ruta que busquem en el NodeList doc.getElementsByTagName(\"ruta\") L'esquelet del programa seria aquest. Copieu-lo en un fitxer Kotlin anomenat Ex3_4_VisRutesXML.kt : import javax.swing.* import java.awt.* import org.w3c.dom.Document import org.w3c.dom.Element import javax.xml.parsers.DocumentBuilderFactory class Finestra : JFrame() { init { var doc: Document // sent\u00e8ncies per a omplir doc defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1,BorderLayout.NORTH) add(panell2,BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(llistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener{ // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } }","title":"Exercici T3_4"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_5","text":"Fer un programa en el fitxer Kotlin Ex3_5_PassarRutesObjJSON.kt que passe el fitxer Rutes.obj a un fitxer JSON Rutes.json amb aquest aspecte: { \"rutes\": [ { \"nom\": \"Pujada a Penyagolosa\", \"desnivell\": 530, \"desnivellAcumulat\": 530, \"llistaDePunts\": [ { \"nom\": \"Sant Joan\", \"coord\": { \"latitud\": 40.251036, \"longitud\": -0.354223 } }, ... ] }, ... ] } Com que ja tenim creades les classes Ruta , PuntGeo i Coord , el m\u00e9s c\u00f2mode ser\u00e0 utilitzar Moshi . Tan sols ens far\u00e0 falta una classe que ho englobe tot: class Rutes(var rutes: MutableList<Ruta> = mutableListOf<Ruta>())","title":"Exercici T3_5"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-t3_6","text":"Replicar l'exercici 3_4, per\u00f2 ara llegint del fitxer Rutes.json , en compte de Rutes.xml Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.json i que aparega el nom de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas, igual que en l'exercici 3_4, ens conv\u00e9 getSelectedIndex() . I com que ja tenim definides les classes, ens conv\u00e9 utilitzar Moshi . Aquest seria l'esquelet del programa. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Ex3_6_VisRutaJSON.kt : import javax.swing.* import java.awt.* import com.squareup.moshi.Moshi import java.io.File class FinestraJSON : JFrame() { init { var llistaRutes: ArrayList<Ruta> // sent\u00e8ncies per a omplir llistaRutes defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) var nomsLlistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(nomsLlistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"), BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener { // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraJSON().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici T3_6"},{"location":"AD_T3_Fitxers_de_diferents_formats/objectius/","text":"Objectius Aquest apartat servir\u00e0 per a finalitzar el contacte amb els fitxers. Una vegada hem vist com accedir als fitxers i al seu contingut, ara \u00e9s el moment de plantejar-nos com guardar dades de diferents tipus, com guardar objectes, ... , farem menci\u00f3 especial als fitxers XML i al format JSON Per una banda es gestionen fitxers amb dades de diferents tipus, ben al contrari que en els fitxers de text, o els exemples d'agafar un fitxer i tractar tots els bytes de la mateixa manera. Per una altra els fitxers d'acc\u00e9s directe (tamb\u00e9 anomenats d'acc\u00e9s relatiu o aleatori). Tamb\u00e9 s'introdueix el tema de la seriaci\u00f3 d'objectes, \u00e9s a dir, intentar guardar objectes directament en fitxers. Una t\u00e8cnica senzilla per\u00f2 que t\u00e9 inconvenients. Despr\u00e9s es tracten els documents XML, no com un fitxer de text (que ho \u00e9s), sin\u00f3 amb un tractament espec\u00edfic per poder accedir a la informaci\u00f3 jerarquitzada d'un document XML. I finalment farem el mateix amb el format JSON Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T3_Fitxers_de_diferents_formats/objectius/#objectius","text":"Aquest apartat servir\u00e0 per a finalitzar el contacte amb els fitxers. Una vegada hem vist com accedir als fitxers i al seu contingut, ara \u00e9s el moment de plantejar-nos com guardar dades de diferents tipus, com guardar objectes, ... , farem menci\u00f3 especial als fitxers XML i al format JSON Per una banda es gestionen fitxers amb dades de diferents tipus, ben al contrari que en els fitxers de text, o els exemples d'agafar un fitxer i tractar tots els bytes de la mateixa manera. Per una altra els fitxers d'acc\u00e9s directe (tamb\u00e9 anomenats d'acc\u00e9s relatiu o aleatori). Tamb\u00e9 s'introdueix el tema de la seriaci\u00f3 d'objectes, \u00e9s a dir, intentar guardar objectes directament en fitxers. Una t\u00e8cnica senzilla per\u00f2 que t\u00e9 inconvenients. Despr\u00e9s es tracten els documents XML, no com un fitxer de text (que ho \u00e9s), sin\u00f3 amb un tractament espec\u00edfic per poder accedir a la informaci\u00f3 jerarquitzada d'un document XML. I finalment farem el mateix amb el format JSON Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"}]}